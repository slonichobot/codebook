\documentclass[11pt]{article}
\usepackage{geometry}
\geometry{
 a4paper,
 total={210mm,297mm},
 left=20mm,
 right=20mm,
 top=20mm,
 bottom=20mm,
 } % nastaveni okraju
 
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx} % pro vkladani obrazku
\usepackage{float} % umozni fixni pozici obrazku
\usepackage{titlesec} % tecka za cislem u section
\usepackage{titling} % pro 
%\titlelabel{\thetitle.\quad} % tecka za cislem u section
\date{} % aby tam nebylo datum
\pagenumbering{gobble} % odstrani ocislovani stranek
\setlength{\droptitle}{-4em}  % posunuti titulku vzhuru
\usepackage[usenames,dvipsnames]{color} 
\definecolor{myBlue}{RGB}{0,0,255}
\definecolor{alBlue}{RGB}{0,170,0}
\definecolor{myBrown}{RGB}{180,120,0}
\definecolor{myGreen}{RGB}{0,99,0}
\definecolor{myAzure}{RGB}{180,20,180}
\usepackage[formats]{listings}
\usepackage{listings}
%\usepackage[T1]{fontenc}
%\usepackage{courier}
\lstset{
  literate={~} {$\sim$}{1},
  %literate={\#include} {$#include$}{1},
  language=C++,
  keywordstyle=\color{myBlue},
  commentstyle=\color{Gray},
  stringstyle=\color{myBrown},
  numberstyle=\tiny\color{Plum},
  emph={include,define},
  emphstyle={\color{myGreen}\textit},
  keywordstyle=[2]\color{myAzure},
  keywords=[2]{string},
  %emph={string},
  %emphstyle={\color{myAzure}\textit},
  basicstyle=\footnotesize,% basic font setting
  frame=single,
  numbers=left,
  stepnumber=1,
  breaklines=true,
  %keywords=[3]{string,ll}\color{myAzure},
  %classoffset=1,  
  %morekeywords={string,ll,big},
  %keywordstyle=\color{myAzure},
  emph=[2]{string,ll,big,ld,ii,vi,pll,vii,set,priority_queue,M_PI},
  emphstyle=[2]{\color{myAzure}},
  emph=[3]{F,PB,FT,FF,REP,IN,FOR,aa,bb,MX,ZERO,MOD,INF,CL,EQ,LG,CLR,ADD},
  emphstyle=[3]{\color{alBlue}},
  %classoffset=0,
  breakatwhitespace=true
}
\title{Contest Library}
\author{Morass [Miloslav Brožek]}
\pagenumbering{arabic}
\begin{document}
\maketitle
\tableofcontents
%\chapter{Úlohy}

\newpage\section{Pomocné informace}
\subsection{Bellova čísla}
\textbf{Bellova čísla} se dají počítat pomocí rekurzivního vzorce: $B_{n+1}=\sum\limits_{k=0}^n {n\choose k}B_k$
\begin{table}[h]
\centering
\caption{Bellova čísla}
\begin{tabular}{|l|l|}
\hline
0&1\\ \hline
1&1\\ \hline
2&2\\ \hline
3&5\\ \hline
4&15\\ \hline
5&52\\ \hline
6&203\\ \hline
7&877\\ \hline
8&4140\\ \hline
9&21147\\ \hline
10&115975\\ \hline
\end{tabular}
\end{table}
\\Pozor - při implementaci je nutno brzy použít $big$.
\subsection{Brute Force}
Při hledání prvku lze jednoduše:
\begin{itemize}
\item Zamezit vracení se na stejnou pozici (i pokud není možné počítat stavy).
\item Zjistit, pokud jsme na mřížce ,jestli se lze do určitého počtu tahů vůbec dostat z aktuální pozice na pozici cílovou.
\end{itemize}
\subsection{Carmichaelova čísla}
\begin{table}[H]
\centering
\caption{Carmichaelova čísla}
\begin{tabular}{|l|l|}
\hline
     1	&561\\ \hline
     2	& 1105\\ \hline
     3	& 1729\\ \hline
     4	& 2465\\ \hline
     5	& 2821\\ \hline
     6	& 6601\\ \hline
     7	& 8911\\ \hline
     8	& 10585\\ \hline
     9	& 15841\\ \hline
    10	& 29341\\ \hline
    11	& 41041\\ \hline
    12	& 46657\\ \hline
    13	& 52633\\ \hline
    14	& 62745\\ \hline
    15	& 63973\\ \hline
    16	& 75361\\ \hline
    17	& 101101\\ \hline
    18	& 115921\\ \hline
    19	& 126217\\ \hline
    20	& 162401\\ \hline
    21	& 172081\\ \hline
    22	& 188461\\ \hline
    23	& 252601\\ \hline
    24	& 278545\\ \hline
    25	& 294409\\ \hline
    26	& 314821\\ \hline
    27	& 334153\\ \hline

\end{tabular}
\end{table}
\subsection{Catalanova čísla}
$C_n=\dfrac{1}{n+1}{2n\choose n}=\dfrac{(2n)!}{(n+1)!n!}=\prod_{k=2}^n{\dfrac{n+k}{k}}$
\\Rekurentní vzorec: $C_n=\dfrac{C_{n-1}*(4n-2)}{n+1}$
\begin{table}[h]
\centering
\caption{Catalanova čísla}
\begin{tabular}{|l|l|}
\hline
0&1\\ \hline
1&1\\ \hline
2&2\\ \hline
3&5\\ \hline
4&14\\ \hline
5&42\\ \hline
6&132\\ \hline
7&429\\ \hline
8&1430\\ \hline
9&4862\\ \hline
10&16796\\ \hline
11&58786\\ \hline
12&208012\\ \hline
13&742900\\ \hline
14&2674440\\ \hline
15&9694845\\ \hline
16&35357670\\ \hline
17&129644790\\ \hline
18&477638700\\ \hline
19&1767263190\\ \hline
\end{tabular}
\end{table}
\\Využití:
\begin{itemize}
\item $C_n$ je 2n-té Dyckovo slovo (řetězec 'X' a 'Y', který má víc Y než-li X).
\item $C_n$ je počet výrazů, obsahující n párů závorek (správně uzávorkované):
 "((())),()(()),()()(),(())(),(()())"
\item $C_n$ je počet možností, kterými lze uzávorkovat n+1 faktorů: ((ab)c)d,(a(bc))d,(ab)(cd),a((bc)d),a(b(cd))
\item $C_n$ je počet možných plných binárních stromů s n+1 listy.
\item $C_n$ je počet neisomorfních uspořádaných stromů s n vrcholy.
\item $C_n$ je počet cest na $n*n$ mřížce.
\item $C_n$ je počet možností, kterými lze rozsekat polygon o n+2 vrcholech na trojúhelníky.
\item $C_n$ je počet permutací, které lze seřadit pomocí zásobníku (tedy bez 231 patternu).
\item $C_n$ je počet možností, jak složit schody z n obdélníku délky $1\times (n-i)$, kde $i=1...n$
\item $C_n$ je počet možností, jak složit z n '/' a n '\textbackslash' hory.
\item $C_n$ je počet možností jak spárovat konvexní 2n-gon tak, aby se hrany neprotínali.
\end{itemize}
{\Large Super Catalan Numbers\par}
Rekurentní vzorec: $S_n=\dfrac{3(2n-3)S_{n-1}-(n-3)S_{n-2}}{n}$
\\Pomocí vztahu $S_n-C_{n-1}$ lze vypočítat, kolik existuje nebinárních uzávorkování pro výraz o $n$ členech.
\begin{table}[h]
\centering
\caption{Super Catalan Numbers}
\begin{tabular}{|l|l|}
\hline
0&0 \\ \hline
1&1 \\ \hline
2&1 \\ \hline
3&3 \\ \hline
4&11 \\ \hline
5&45 \\ \hline
6&197 \\ \hline
7&903 \\ \hline
8&4279 \\ \hline
9&20793 \\ \hline
10&103049 \\ \hline
11&518859 \\ \hline
12&2646723 \\ \hline
13&13648869 \\ \hline
14&71039373 \\ \hline
15&372693519 \\ \hline
\end{tabular}
\end{table}
\subsection{Dělitelnost}
\textbf{2}: Poslední číslo je dělitelné 2.
\\\textbf{3}: Ciferný součet je dělitelný 3.
\\\textbf{4}: Poslední dvojčíslí je dělitelné 4.
\\\textbf{5}: Poslední číslo je dělitelné 5.
\\\textbf{6}: Číslo je dělitelné 2 a 3.
\\\textbf{7}: Obrátíme cifry čísla a vytvoříme jejich součet, násoben postupně $\{1,3,2,6,4,5\}$ (opakovaně stále dokola). Výsledek je pak dělitelný 7.
\\\textbf{8}: Poslední trojčíslí je dělitelné 8.
\\\textbf{9}: Ciferný součin je dělitelný 9.
\\\textbf{10}: Poslední cifra je rovna 0.
\\\textbf{11}: Součet cifer, násobených $(-1)^p$ (kde $p$ je pozice, číslováno od 0) je dělitelný 11.
\\\textbf{12}: Číslo je dělitelné 3 a 4.
\\\textbf{13}: Usekneme poslední číslici a její čtyřnásobek přičteme k číslu (pokud je dělitelné 13 tak je i původní číslo) - lze opakovat stále dokola.
\\\textbf{14}: Dělitelnost 7 a 2.
\\\textbf{15}: Dělitelnost 5 a 3.
\\\textbf{16}: Poslední čtyřčíslí je dělitelné 16.
\\\textbf{17}: Odečtení pětinásobku posledního čísla od zbytku.
\\\textbf{18}: Dělitelnost 9 a 2.
\\\textbf{19}: Přičtení dvojnásobku posledního čísla ke zbytku.
\\\textbf{20}: Dělitelnost 10 a 2.
\\\textbf{23}: Sedminásobek poslední číslovky se přičte ke zbytku.
\\\textbf{29}: Přičtení trojnásobku poslední číslovky ke zbytku.
\\\textbf{31}: Odečtení trojnásobku poslední číslovky od zbytku.
\\\textbf{33}: Součet dvojčíslí je dělitelný 33.
\\\textbf{37}: Součet trojčíslí je dělitelný 37.
\\\textbf{41}: Odečtení čtyrnásobku poslední číslovky od zbytku.
\\\textbf{43}: Odečtení třicetinásobku poslední číslovky od zbytku.
\subsection{Gausova Prvočísla}
Gausova prvočísla jsou ve tvaru $z=a+b\textit{i}$
\\O prvočíslo se jedná pouze pokud:
\begin{itemize}
\item $a$ ani $b$ nejsou rovny 0 a zároveň $a^2+b^2$ je prvočíslem
\item $a = 0$, $|b|$ je prvočíslo a zároveň $|b|\equiv 3\ mod\ 4$ 
\item $b = 0$, $|a|$ je prvočíslo a zároveň $|a|\equiv 3\ mod\ 4$
\end{itemize}
Při zápise $z=a+b\sqrt{-k}$ existuje pouze 9 čísel \textit{k} takových, že mají všechna čísla unikátní faktorizaci (1, 2, 3, 7, 11, 19, 43, 67, 163)
\subsection{Grafy}
Planární graf může mít nejvyšší chromatické číslo 4.
\\Simple Graph - Nemá vrcholové smyčky ani multihrany (nemusí být spojitý).
\\Maximální počet uzlů stromu, kde každý uzel má maxmálně \textsf{v} sousedů a je od kořenu maximálně \textsf{d} daleko, je $\dfrac{v((v-1)^d-1)}{v-2}+1$
\\Počet ploch, rozdělených planárním grafem se spočítá: $f=2-v+e$ (pozor - pokud má graf více komponent, je téže nutné tento počet do vzorce zanést).
\\Pokud máme úplný graf, pak maximální počet hranově disjunktních koster je $\lfloor\frac{N}{2}\rfloor$
\subsection{Generalizovaná Pentagonální Čísla}
\begin{table}[H]
\centering
\caption{Generalizovaná Pentagonální Čísla (1)}
\begin{tabular}{|l|l|}
\hline
0&0\\\hline
1&1\\\hline
2&2\\\hline
3&5\\\hline
4&7\\\hline
5&12\\\hline
6&15\\\hline
7&22\\\hline
8&26\\\hline
9&35\\\hline
10&40\\\hline
11&51\\\hline
12&57\\\hline
13&70\\\hline
14&77\\\hline
15&92\\\hline
16&100\\\hline
17&117\\\hline
18&126\\\hline
19&145\\\hline
20&155\\\hline
21&176\\\hline
22&187\\\hline
23&210\\\hline
24&222\\\hline
25&247\\\hline
26&260\\\hline
27&287\\\hline
28&301\\\hline
29&330\\\hline
\end{tabular}
\end{table}
\begin{table}[H]
\centering
\caption{Generalizovaná Pentagonální Čísla (2)}
\begin{tabular}{|l|l|}
\hline
30&345\\\hline
31&376\\\hline
32&392\\\hline
33&425\\\hline
34&442\\\hline
35&477\\\hline
36&495\\\hline
37&532\\\hline
38&551\\\hline
39&590\\\hline
40&610\\\hline
41&651\\\hline
42&672\\\hline
43&715\\\hline
44&737\\\hline
45&782\\\hline
46&805\\\hline
47&852\\\hline
48&876\\\hline
49&925\\\hline
50&950\\\hline
51&1001\\\hline
52&1027\\\hline
53&1080\\\hline
54&1107\\\hline
55&1162\\\hline
56&1190\\\hline
57&1247\\\hline
58&1276\\\hline
59&1335\\\hline
\end{tabular}
\end{table}
\subsection{Geometrie}
Pokud chceme postavit obálku kolem polygonu, v nejbližší vzdálenosti \textit{d} od něj, vypočítáme obvod obálky vzorcem: \textit{obálka polygonu}$+2\pi d$.
\\Počet diagonál v $n$-gonu je $D=\dfrac{n(n-3)}{2}$
\\Počet průsečíků diagonál v $n$-gonu je $\binom{n}{4}$
\\\textbf{Rovnice přímky s úhlem a bodem}:
\\$m*x+n=y$
\\$n = startPoint_Y - (tan ( angle) * startPoint_X )$
\\Pokud máme do kruhu o poloměru \textsf{R} dát \textsf{N} kuliček (na okraj) a maximalizovat jejich velikost, pak jejich poloměr lze vypočítat vzorcem $sin(\pi/N)*R/(sin(\pi /N)+1)$
\\Pokud je proti sobě (na přímkách) rozmístěno \textbf{N} a \textbf{M} bodu, a vede se úsečka z každého z nich do každého protějšího (jako v bipartitním grafu), pak bude počet průsečíků roven $\dfrac{N*(N-1)*M*(M-1)}{4}$
\\Obsah pravidelného \textsf{n}-gonu, který je vepsaný do kružnice o poloměru \textsf{r} je:  $\dfrac{nr^2sin(\dfrac{2\pi}{N})}{2}$
\\Pokud má trojúhelní strany délek \textsf{a},\textsf{b},\textsf{c}, pak poloměr kružnice vepsané bude $\sqrt{\frac{(t-a)*(t-b)*(t-c)}{t}}$, kde $t=\frac{a+b+c}{2}$
\\Pokud má trojúhelní tři těžnice délek \textsf{a},\textsf{b},\textsf{c}, pak obsah trojúhelníka bude $\frac{4\sqrt{t*(t-a)*(t-b)*(t-c)}}{3}$, kde $t=\frac{a+b+c}{2}$
\\Nechť je pentagon o straně \textsf{A}, pak strana největšího čtverce, který do něj lze vepsat je $\frac{sin(\frac{A*72*\pi}{180})}{sin(\frac{63*\pi}{180})}$
\\Nechť je v trojúhelníku vytvořen menší trojůhelník tak, že jsou vždy z třetiny strany vedeny úsečky do protějšího bodu. Jeho obsah pak bude roven sedmině původního trojúhelníka.
\\Ověření, že obdélník (p*q) se vleze do obdélníku (a*n): $p\geq q,a\geq b$: buď $p\leq a$ a $q\leq b$ (na délku) nebo přes diagonálu: $p>a$ a zároveň $b\geq \dfrac{2pqa+(p^2-q^2)\sqrt{p^2+q^2-a^2}}{p^2+q^2}$
\\Pokud na kruh dáme $n$ bodů a z každého vedeme úsečku do každého dalšího, pak budeme mít 
\\Počet čtverců v $N\times M$ boxu s rohama na celých číslech: $\sum_{k=2}^{min(N,M)} (N-k+1)(M-k+1)(k-1)$ (\textbf{bounding-box}). Pokud by byla velikost čtverce $N \times N$, šlo by řešit pomocí vzorce $\dfrac{N^4-N^2}{12}$. Jinak bude vzoreček dosti zvrhlý: 
\\ $\dfrac{(min(N,M)-1)*min(N,M)*(3*min(N,M)^2-(4M+4N+3)*min(N,M)+2(3*M*N+N+M))}{12}$
%(N-k+1)(N-k+2)/2 BB Triangle
\\Obvod elipsy: Nechť máme body $b \leq a$, které jsou poloměry na kříži. Ekcentricitu spočítáme jako: $e=\sqrt{1-\frac{b^2}{a^2}}$. Obvod poté můžeme "přesně" spočítat pomocí nekonečné řady: $2\pi a(1-(\frac{1}{2})^2e^2-(\frac{1*3}{2*4})^2\frac{e^4}{3}-(\frac{1*3*5}{2*4*6})^2\frac{e^6}{5}-...)$
\subsection{Hodiny}
\begin{table}[H]
\centering
\caption{Časy kdy se hodinová ručička míjí s minutovou}
\begin{tabular}{|l|l|}
\hline
 1&00:00  \\ \hline
 2&01:05  \\ \hline
 3&02:10  \\ \hline
 4&03:16  \\ \hline
 5&04:22  \\ \hline
 6&05:27  \\ \hline
 7&06:33  \\ \hline
 8&07:38  \\ \hline
 9&08:43  \\ \hline
 10&09:48  \\ \hline
 11&10:54  \\ \hline
\end{tabular}
\end{table}
Den má $1440$ minut.
\\Rok má $86400$ sekund.
\subsection{Kombinační matematika}
Počet různých krychlí obarvených n barvami:
\begin{center}
$(n^6+3*n^4+12*n^3+8*n^2)/24$
\\$=$
\\$(n^4+3*n^2+12*n+8)*n^2/24$
\end{center}
\begin{table}[H]
\centering
\caption{Faktoriál}
\begin{tabular}{|l|l|}
\hline
0&1\\ \hline
1&1\\ \hline
2&2\\ \hline
3&6\\ \hline
4&24\\ \hline
5&120\\ \hline
6&720\\ \hline
7&5040\\ \hline
8&40320\\ \hline
9&362880\\ \hline
10&3628800\\ \hline
11&39916800\\ \hline
12&479001600\\ \hline
13&6227020800\\ \hline
14&87178291200\\ \hline
15&1307674368000\\ \hline
16&20922789888000\\ \hline
17&355687428096000\\ \hline
18&6402373705728000\\ \hline
19&121645100408832000\\ \hline
20&2432902008176640000\\ \hline
\end{tabular}
\end{table}
\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{pic/pascal.png}
  \caption[Pascalův trojúhelník.]{Pascalův trojúhelník.}
\end{figure}
\begin{table}[H]
\centering
\caption{Počet různých permutací znamének rovnost a menší}
\begin{tabular}{|l|l|}
\hline
1&1\\ \hline
2&3\\ \hline
3&13\\ \hline
4&75\\ \hline
5&541\\ \hline
6&4683\\ \hline
7&47293\\ \hline
8&545835\\ \hline
9&7087261\\ \hline
10&102247563\\ \hline
11&1622632573\\ \hline
12&28091567595\\ \hline
13&526858348381\\ \hline
14&10641342970443\\ \hline
15&230283190977853\\ \hline
\end{tabular}
\end{table}
Počet číslic v čísle: $\left \lfloor{log_{10}(n)+1}\right \rfloor$
\\Počet číslic ve faktoriálu čísla: $\left \lfloor{log_{10}(1)+log_{10}(2)+...+log_{10}(n)+1}\right \rfloor$
\\Lze také aproximovat pomocí: $1+(log(2\pi n)/2+nlog(n)-n)/log(10)$ 
\\Počet permutací řetězce je: $\dfrac{(\sum\limits_{i=0}^U n_i)!}{\prod\limits_{i=1}^U n_i!}$, kde \textsf{U} je univerzum písmen stringu a $n_i$ je počet písmenek. Slovy tedy faktoriál délky řetězce lomeno součin faktoriálů četností slov.
\\Počet permutací \textbf{N} čísel, přičemž v prvních \textbf{M} číslech musí být právě \textbf{K} čísel na své pozici: 
\begin{center}
${M\choose K}*\sum\limits_{i=0}^{M-K}({M-K\choose i}*(N-K-i)!*(-1)^i)$
\end{center}
Počet možností, jak zpermutovat \textsf{N} věcí tak, aby žádná nezbyla na původním místě, se dá vyjádřit rekurentní rovnicí $T(N)=N*T(N-1)+(-1)^N$, kde $T(N<1)=0$
\\Počet binárních stromů, které lze vytvořit za pomocí \textsf{N} elementů: $\frac{(2n)!}{(n+1)!}$. Prvních několik čísel: \{1, 1, 4, 30, 336, 5040, 95040, 2162160, 57657600, 1764322560, 60949324800, 2346549004800\}
\\Počet možností, jak nacpat domina $1\times 1$ a domina tvaru L do $2\times N$ boxu: $T(N)=T(N-1)+4T(N-2)+2T(N-3)$. Prvních několik členů: \{1, 1, 5, 11, 33, 87, 241, 655, 1793, 4895, 13377, 36543, 99841, 272767, 745217, 2035967, 5562369\}
\\Nechť máme $N$ "RGB"\ kuliček, pro jejiž počty platí "0<R<G<B". Pak se toto číslo dá (vcelku přesně) aproximovat pomocí zvorce $\frac{17}{72}+\frac{(N+1)*(N+5)}{12}+\frac{(-1)^N}{8}.+\frac{2}{9}*cos(2*N*\pi/3)+\frac{1}{2}$ pro ($5<N$)
\\Počet možností, jak rozdělit N různých věcí do subsetů stejných velikostí: $\sum\limits_{d|N} \dfrac{N!}{d!*(n/d)!^d}$
\\Počet možností jak vytvořit sekvenci o délce \textsf{M}, skládající se ze znaků $[1..N]$, jejíž LIS (Nejdelší Rostoucí Posloupnost) má délku právě \textsf{N}: $\sum^{M-N}_{x=0}N^x(n-1)^{m-n-x}$  ${N-x-1}\choose{N-1}$
\\Nechť máme všechny premutace čísel $[1..N]$. Dále nečhť máme číslo $K$. Suma prvních členů permutace, které jsou $<=K$ (přes všechny permutace) je $\dfrac{(N-K)!*K*(K+1)*N!}{2*(N-K+1)!}$
\\Vzorec $\sum\limits_{K=0}^N \sum\limits_{i=0}^K {K\choose i}\ mod\ 2$ lze rekurzivně zapsat jako: $a(2k) = 3*a(k), a(2k+1) = 2*a(k) + a(k+1)$, prvních několik členů: ${0, 1, 3, 5, 9, 11, 15, 19, 27, 29}$ (PS: rozvoj je poměrně dobrý, lze počítat vysoko, s dynamičkou pomocí mapy)
\\$X=\frac{A}{B}\%C$ pak $X=\dfrac{A\%(BC)}{B}$
\subsection{Konstanty}
\textbf{Pi($\pi$)} - 3.1415926535897932384626433832 
\\\textbf{Eulerovo číslo} - 2.7182818284590452353602874713527
\\\textbf{Zlatý řez} - 1.61803398874989484820
\subsection{Logické funkce}
$a|b=!(!(a\&a)\&!(b\&b))$
\subsection{Rekurentní rovníce a náhodné vzorce}
\begin{table}[H]
\centering
\caption{Rovnice a vzorce}
\begin{tabular}{|l|l|}
\hline
 $T(n)=(T(n-1)-1)*a,T(0)=x$&$\dfrac{a^n(a*(x-1)-x)+a}{a-1}$  \\ \hline
 $T(n)=(T(n-1)-k)*a,T(0)=x$&$\dfrac{ak-a^n(a(k-x)+x}{a-1}$  \\ \hline
 $T(n)=T(n-1)*a+b,T(0)=H$&$\dfrac{a^n((a-1)H+b)-b}{a-1}$  \\ \hline
  $T(i)=2*(T(i-1)+1)-T(i-2),T(1)=A,T(2)=B$&$(i-1)(B+i-2)-A(i-2)$  \\ \hline
  $T(N)=V*T(N-1)+W*T(N-2),T(0)=A,T(1)=B$&$\frac{1}{\sqrt{V^2+4W}}$  \\ \hline
$T(n)=T(n-1)+a,T(0)=x$&$an+x$  \\ \hline
$T(N)=W*T(N-1),T(0)=A$&$AW^N$  \\ \hline
$T(n)=T(n-1)*V+W,T(0)=A$&$\dfrac{V^n(A(V-1)+W)-W}{V-1}$  \\ \hline
$T(n)=T(n-1)+W^n,T(0)=A$&$\dfrac{A(W-1)+W(W^N-1)}{W-1}$  \\ \hline
$T(n)=T(n-1)^k,T(0)=A$&${A^k}^n$  \\ \hline
$T(n)=T(n-1)-T(n-2),T(0)=A,T(1)=B$&$Acos(\dfrac{\pi n}{3})-\dfrac{(A-2B)sin(\dfrac{\pi n}{3})}{\sqrt{3}}$  \\ \hline
$T(n)=uT(n-1)-vT(n-2), T(0)=2$ a $T(1)=u$& $2^{-n}((u-\sqrt{u^2-4v})^n+(u+\sqrt{u^2+4v})^n)$\\ \hline
$T(i)=T(i-1)+i,T(0)=0$&$(i+1)i/2$  \\ \hline
$\sum\limits_{i=1}^n i2^i$ &$(n-1)2^{n+1}+2$\\ \hline
$\sum\limits_{i=1}^{\inf} \dfrac{1}{i^2}$ &$\dfrac{\pi^2}{6}$\\ \hline
$\sum\limits_{k=1}^{n} k*(k+1)*(k+2)/2$ &$n*(n+1)*(n+2)*(n+3)/8$\\ \hline
$\sum\limits_{k=1}^{n} p^k$ &$\dfrac{p(p^n-1)}{p-1}$\\ \hline
$\sum\limits_{k=0}^{n}{n \choose 4k} $ &$\dfrac{(1-k)^n+(1+k)^n+2^n}{4}$\\ \hline
$\sum\limits_{k=0}^{M-1}N*A^k $ &$\dfrac{N(A^M-1)}{A-1}$\\ \hline
\end{tabular}
\end{table}
Pro rovnici $T(N)=aT(N-1)+bT(N-3)+c$, $T(N<3)=0$, lze nastavit matici na $M[0][0]=a;M[0][2]=b;M[0][3]=M[1][0]=M[2][1]=M[3][3]=1;$ a mocnit $N-2$ (výsledek bude $[0][3]*c$).
\subsection{Matematické věty a vzorce}
\textbf{Velká Fermatova věta}: Neexistují přirozená čísla x,y a z, pro která platí $x^n+y^n=z^n$, pro $n>2$ a $x,y,z \neq 0$
\\\textbf{Diskriminant}: $x_{1,2}=\dfrac{-B\pm\sqrt{B^2-4AC}}{2A}$
\\\underline{Získání $a^n+b^n$ z $a+b$ a $ab$}: Nechť $u=a+b$ a $v=a*b$, pak $a^n+b^n=T(n)$, kde $T(n)=uT(n-1)-vT(n-2), T(0)=2$ a $T(1)=u$ (pozor na krajní hodnoty, tedy $a,b,n \in \{-1,0,1\}$).
\\\textbf{Permutace}: Rozdíl permutací čísel je dělitelný 9.
\\\textbf{Počet možností, kterým lze pomocí součtu dvou a více po sobě jdoucích čísel získat číslo \textsf{N}}: $(k_1+1)(k_2+1)(k_3+1)...(k_l+1)-1$, kde $k$ jsou počty prvočísel ve faktorizaci čísla $> 2$
\\
\\Číslo je kungruentní se součtem číslic onoho čísla na modulu 9. 
\\Pythagorova trojice: (pro \textsf{m} a \textsf{n}): $n^2+m^2$, $n^2-m^2$,$2nm$
\begin{center}
$a=p*q$

$b=(p^2-q^2)/2$

$c=(p^2+q^2)/2$
\end{center}
Produkt všech dělitelů čísla \textbf{N} lze zapsat jako $N^{d(n)/2}$, kde $d(n)$ je počet dělitelů čísla \textbf{N}.
\\Součet x-tých mocnicn dělitelů čísla: $\prod_1^r(\dfrac{p_i^{(a_1+1)x}-1}{p_i^x-1})$
\\Pokud číslo vzniklo z odečtení čísla a čísla bez poslední cifry, zrekonstrujeme ho pomocí $N+\dfrac{N}{9}$. Pokud je navíc číslo dělitelné devíti, mohlo vzniknout ještě z čísla o jedna menšího.
\\Počet kladných čísel $\leq$ N, které lze zapsat jako $a^2-b^2$ je $N-(\dfrac{N-2}{4}+1)$ (pro $N<2$ je to $N$)
\\Počet možností, jak rozdělit set ${1,2,..,N}$ na dva "distinct" subsety tak, že xor prvků prvního subsetu je menší/roven xoru prvků druhého subsetu: $(3^N-1)/2$
\\Reverzní gausův vzorec: z $\frac{N*(N+1)}{2}$ je $\dfrac{1+\sqrt{1+8N}}{2}$ (+/-)
\\$\phi(N)$ značí počet čísel $1 \leq a \leq N$, které mají $gcd(a,N)=1$. $\phi(N/a)$ by pak mělo dát počet čísel, jejiž $gcd(N,a)==a$
\\Počet vyplnění $2\times 2 \times N$ kvádru pomocí $1\times 1 \times 2$ kostky lze vyjádřit jako $a(n)=3a(n-1)+3a(n-2)-a(n-3)$
\\Počet jedniček v číslech $0 \leftarrow N$ lze zapsat pomocí rekurzí: $a(0) = 0, a(2n) = a(n)+a(n-1)+n, a(2n+1) = 2a(n)+n+1$
\\$(p-1)!\equiv p-1\ mod\ p$, kde p je prvočíslo
\subsection{Mersennova čísla}
\begin{table}[H]
\centering
\caption{Mersenova čísla}
\begin{tabular}{|l|l|}
\hline
 2&3  \\ \hline
 3&7  \\ \hline
 5&31  \\ \hline
 7&127  \\ \hline
 13&8191  \\ \hline
 17&131071  \\ \hline
 19&524287  \\ \hline
 31&2147483647  \\ \hline
 61&2305843009213693951  \\ \hline
\end{tabular}
\end{table}
\subsection{Prvočísla [náhodná]}
\begin{table}[H]
\centering
\caption{Prvočísla}
\begin{tabular}{|l|l|}
\hline
 2531  \\ \hline
 300043 \\\hline
 30 000 251 \\\hline
 1 000 000 009  \\ \hline
 100 000 000 061 \\\hline
 1 000 000 000 669 \\\hline
 100 000 000 000 000 003 \\\hline
 
\end{tabular}
\end{table}
\subsection{Suma druhých mocnin matic}
Zadaná rekurence:

\[ a_{n+k} = A_{k-1} a_{n+k-1} + A_{k-2} a_{n+k-2} + \cdots + A_{0} a_{n} \]

Vypočetní matice:

\[
 \begin{pmatrix}
    a_{n+k-1} \\
    a_{n+k-2} \\
    \vdots    \\
    a_{n+1} \\
    a_{n}
 \end{pmatrix}
 \begin{pmatrix}
  A_{k-1} & A_{k-2} & \cdots & A_{1} & A_{0} \\
  1 & 0 &  \cdots & 0 & 0 \\
  0  & 1  &  &  & 0 \\
  \vdots &  & \ddots &  & \vdots \\
  0 & \cdots & 0 & 1 & 0
 \end{pmatrix}
 =
 \begin{pmatrix}
    a_{n+k}   \\
    a_{n+k-1} \\
    \vdots    \\
    a_{n+2}  \\
    a_{n+1}
 \end{pmatrix}
\]

Obecný tribonacci: \[ a_{n+3} = A a_{n+2} + B a_{n+1} + C a_{n}\]

\[
 \begin{pmatrix}
    a_{n+2} \\
    a_{n+1} \\
    a_{n}
 \end{pmatrix}
 \begin{pmatrix}
  A & B & C \\
  1 & 0 & 0 \\
  0 & 1 & 0
 \end{pmatrix}
 =
 \begin{pmatrix}
    a_{n+3} \\
    a_{n+2} \\
    a_{n+1}
 \end{pmatrix}
\]

\textbf{Rekurence kvadratických členů}

Pro rekurenci:
\[ a_{n+2}=A a_{n+1} + B a_{n} \]

nás zajíma jak vypadá posloupnost kvadrátů:
\[ b_{n} = a_{n}^2 \]

idea: vyjádřit $b_{n+3}$ a $b_{n+2}$ a pak sečíst $b_{n+3}-Bb_{n+2}$


\begin{align*}
    b_{n+3} &= (A^2+B)b_{n+2} + (B^2 + 2A^2B - A^2B)b_{n+1} +(-B^3)b_{n}
\end{align*}
\subsection{Zajímavosti}
Nechť hrají 2 hráči hru, kde jsou 2 krabice s $n$ a 1 kuličkami a tah spočívá ve vysypání jedné krabice a libovolném přerozdělení druhé (alespoň 1 kulička musí být umístěna). Prohraje ten na koho zbude kdo nemůže udělat tah. Při perfektním hraní vyhraje první hráč, pokud nedostane v první krabici $2^k-1$ kuliček.
\\Pokud můžeme prohazovat pouze sousedy, je na prohození [reverse] sekvence třeba $N\&1?((N>>1)*((N>>1)-1)>>1)+(((N>>1)+1)*(N>>1)>>1):(N>>1)*((N>>1)-1)$ swapů.
\newpage\section{Čísla, Soustavy a Operace}
\subsection{BigInt}
Lze do něj pomocí '=' přiřadit int ($<1000000000$).
\\Podporuje operaci $+=$ na \textsl{big}.
\\Funkce $eq$ umí porovnat \textsl{big} s intem.
\\Funkce $prt$ umí \textsl{big} vytisknout.
\begin{lstlisting}[language=C++]
struct big{
    static const long long MM=999999999;
    long long l,a[1024];
    big(int A=0):l(1){a[0]=A;}
    bool eq(int h){return l==1&&a[0]==h;}
    void operator=(int h){
        a[0]=h;
        l=1;
    }/*Care - if used on itself, remove '&'!*/
    void operator+=(big &b){
        for(int i(0);i<b.l;++i)
            add(b.a[i],i);
    }
    void add(long long s,int nd){
        if(nd==l)
            a[l++]=0;
        a[nd]+=s;
        if(a[nd]>MM)
            a[nd]-=MM+1,add(1,nd+1);
    }
    void prt(void){
        printf("%lld",a[l-1]);
        for(int i(l-2);~i;--i)
            printf("%09lld",a[i]);
    }
};
\end{lstlisting}
\begin{center}
Dále Big podporující násobení skalárem.
\end{center}
\begin{lstlisting}[language=C++]
struct big{
    static const long long MM=999999999;
    long long l,a[1024];
    big(int A=0):l(1){a[0]=A;}
    bool eq(int h){return l==1&&a[0]==h;}
    void operator=(int h){
        a[0]=h,l=1;
    }
    void prt(void){
        printf("%lld",a[l-1]);
        for(int i(l-2);~i;--i)
            printf("%09lld",a[i]);
    }
    void operator*=(unsigned k){
        for(int i(0);i<l;++i)
            a[i]*=k;
        for(int i(l-1);~i;--i)
            if(a[i]>MM)
                add(a[i]/(MM+1),i+1),a[i]%=MM+1;
    }
    void add(long long s,int nd){
        if(nd==l)
            a[l++]=0;
        a[nd]+=s;
        if(a[nd]>MM)
            a[nd]-=MM+1,add(1,nd+1);
    }
};
\end{lstlisting}
Metoda pro násobení $big$-em.
\begin{lstlisting}[language=C++]
    void operator*=(big &b){
        static ll A[1024];
        ll L(l);
        l+=b.l-1;
        F(L)A[i]=a[i];
        F(l)a[i]=0;
        F(b.l)FF(L)
            if((a[i+j]+=A[j]*b.a[i])>MM)
                add(a[i+j]/(MM+1),i+j+1),a[i+j]%=MM+1;
    }
\end{lstlisting}
Metodu pro násobení skalárem pak lze upravit tak, aby podporovala i násobení dlouhým intem.
\begin{lstlisting}[language=C++]
    void operator*=(ll k){
        if(k>MM){
            big tp(k);
            *this*=tp;
            return;
        }
        for(int i(0);i<l;++i)
            a[i]*=k;
        for(int i(l-1);~i;--i)
            if(a[i]>MM)
                add(a[i]/(MM+1),i+1),a[i]%=MM+1;
    }
    big(ll A=0):l(1){a[0]=A;*this*=1;}
\end{lstlisting}
\begin{center}
Dále Big podporující odečítání menšího čísla od většího;
\end{center}
\begin{lstlisting}[language=C++]
    void sub(long long s,int nd){
        a[nd]-=s;
        if(!a[nd]&&l==nd)
            --l;
        else if(a[nd]<0)
            a[nd]+=MM+1,sub(1,nd+1);
    }
    void operator-=(big&r){
        for(int i(0);i<r.l;++i)
            sub(r.a[i],i);    
		while(l>1&&!a[l-1])--l;
    }
\end{lstlisting}
\begin{center}
Metoda na načtení bigu (dlouhého).
\end{center}
\begin{lstlisting}[language=C++]
    void st(int u,char *c,int L){
        a[u]=0;l=u+1;
        F(L)a[u]*=10,a[u]+=c[i]-'0';
    }
    void scan(void){
        static char c[1024];
        scanf("%s",c);
        int L(strlen(c)),I(0);
        while(L>0)
            st(I++,c+L-(L>=9?9:L),(L>=9?9:L)),L-=9;
    }
\end{lstlisting}
\begin{center}
Metody na porovnání.
\end{center}
\begin{lstlisting}[language=C++]
    bool operator<(const big&r)const{
        if(r.l!=l)return l<r.l;
        F(l)if(a[l-i-1]!=r.a[l-i-1])return a[l-i-1]<r.a[l-i-1];
        return 0;
    }
    bool operator==(const big&r)const{
        if(r.l!=l)return 0;
        F(l)if(a[l-i-1]!=r.a[l-i-1])return 0;
        return 1;
    }
\end{lstlisting}
\begin{center}
Metoda na mocnění.
\end{center}
\begin{lstlisting}[language=C++]
    big(const big&r):l(r.l){
        F(l)a[i]=r.a[i];
    }
    void pow(int k){
        if(!k){l=1;a[0]=1;return;}
        big n(*this),N(n);--k;
        while(k){
            if(k&1)
                *this*=n;
            n*=N,k>>=1,N=n;
        }
    }
\end{lstlisting}
\begin{center}
Metoda na dělení intem
\end{center}
\begin{lstlisting}[language=C++]
    void div(int u,ll r,ll d){
        if(!~u)return;
        ll h(a[u]+(MM+1)*r);
        div(u-1,h%d,d);
        a[u]=h/d;
    }
    void operator/=(ll d){
        div(l-1,0,d);
        while(l>1&&!a[l-1])--l;
    }
\end{lstlisting}
\begin{center}
Metoda na zbytek po dělení (longem)
\end{center}
\begin{lstlisting}[language=C++]
    ll rem(int u,ll r,ll d){
        return ~u?rem(u-1,(a[u]+(MM+1)*r)%d,d):r;
    }
    ll operator%(ll d){
        return rem(l-1,0,d);
    }
\end{lstlisting}
\begin{center}
Metoda pro dělení bigem
\end{center}
\begin{lstlisting}[language=C++]
    void mm(big&b,int k,int m){
        CL(a,0),l=b.l+m;
        ll c(0);
        F(b.l)c+=b.a[i]*k,a[i+m]=c%(MM+1),c/=(MM+1);
        while(c)a[l++]=c%(MM+1),c/=(MM+1);
    }
    void operator/=(big&b){
        big t,x(*this);
        if(x<b){*this=0;return;}
        //if(x==b){*this=1;return;}
        CL(a,0),l-=b.l-1;
        for(int i(l-1);~i;--i)for(ll k(1ll<<29);k;k>>=1){
            t.mm(b,k,i);
            if(!(x<t))x-=t,a[i]+=k;
            if(a[i]>MM)add(a[i]/(MM+1),i+1),a[i]%=(MM+1);
        }
        while(l>1&&!a[l-1])--l;
    }
\end{lstlisting}
\begin{center}
Metoda na modulo bigem
\end{center}
\begin{lstlisting}[language=C++]
    void mm(big&b,int k,int m){//share with /=
        CL(a,0),l=b.l+m;
        ll c(0);
        F(b.l)c+=b.a[i]*k,a[i+m]=c%(MM+1),c/=(MM+1);
        while(c)a[l++]=c%(MM+1),c/=(MM+1);
    }
    big operator%(big&b){
        big t,x(*this);
        for(int i(l-b.l);~i;--i)for(int k(1<<29);k;k>>=1){
            t.mm(b,k,i);
            if(!(x<t))x-=t;
        }
        return x;
    }
\end{lstlisting}
\begin{center}
GCD
\end{center}
\begin{lstlisting}[language=C++]
    big gcd(big&b){
        big A(*this),B(b),C;
        if(B<A)swap(A,B);
        while(!A.eq(0))C=A,A=B%A,B=C;
        return B;
    }
\end{lstlisting}
Dohromady
\begin{lstlisting}[language=C++]
struct big{
    static const ll MM=999999999;
    ll l,a[1024];
    big(int A=0):l(1){a[0]=A;}
    bool eq(int h){return l==1&&a[0]==h;}
    void operator=(int h){*a=h,l=1;}
    void operator+=(int a){add(a,0);}
    void operator+=(big &b){F(b.l)add(b.a[i],i);}
    void add(ll s,int nd){
        if(nd==l)a[l++]=0;
        a[nd]+=s;
        if(a[nd]>MM)a[nd]-=MM+1,add(1,nd+1);
    }
    ll rem(int u,ll r,ll d){return ~u?rem(u-1,(a[u]+(MM+1)*r)%d,d):r;}
    ll operator%(ll d){return rem(l-1,0,d);}
    void operator++(){add(1,0);}
    void operator--(){
        int L(0);
        while(!a[L])a[L++]=MM;
        --a[L];
    }
    void div(int u,ll r,ll d){
        if(!~u)return;
        ll h(a[u]+(MM+1)*r);
        div(u-1,h%d,d);
        a[u]=h/d;
    }
    void operator/=(ll d){
        div(l-1,0,d);
        while(l>1&&!a[l-1])--l;
    }
    big(const big&r):l(r.l){F(l)a[i]=r.a[i];}
    void pow(int k){
        if(!k){l=1;a[0]=1;return;}
        big n(*this),N(n);--k;
        while(k){
            if(k&1)*this*=n;
            n*=N,k>>=1,N=n;
        }
    }
    void operator*=(big &b){
        static ll A[1024];
        ll L(l);
        l+=b.l-1;
        F(L)A[i]=a[i];
        F(l)a[i]=0;
        F(b.l)FF(L)
            if((a[i+j]+=A[j]*b.a[i])>MM)
                add(a[i+j]/(MM+1),i+j+1),a[i+j]%=MM+1;
    }
    void operator*=(unsigned k){
        F(l)a[i]*=k;
        for(int i(l-1);~i;--i)
            if(a[i]>MM)add(a[i]/(MM+1),i+1),a[i]%=MM+1;
    }
    void prt(void){
        printf("%lld",a[l-1]);
        for(int i(l-2);~i;--i)
            printf("%09lld",a[i]);
    }
    int prt(char*c){
        sprintf(c,"%lld",a[l-1]);
        int L(strlen(c));
        for(int i(l-2);~i;--i)
            sprintf(c+L,"%09lld",a[i]),L+=9;
        return L;
    }
    bool operator<(int A)const{return l==1&&*a<A;}
    bool operator>(int A)const{return l>1||*a>A;}
    bool operator<(const big&r)const{
        if(r.l!=l)return l<r.l;
        F(l)if(a[l-i-1]!=r.a[l-i-1])return a[l-i-1]<r.a[l-i-1];
        return 0;
    }
    bool operator>(const big&r)const{
        if(r.l!=l)return l>r.l;
        F(l)if(a[l-i-1]!=r.a[l-i-1])return a[l-i-1]>r.a[l-i-1];
        return 0;
    }
    bool operator==(const big&r)const{
        if(r.l!=l)return 0;
        F(l)if(a[l-i-1]!=r.a[l-i-1])return 0;
        return 1;
    }
    void sub(ll s,int nd){
        a[nd]-=s;
        if(!a[nd]&&l==nd)--l;
        else if(a[nd]<0)a[nd]+=MM+1,sub(1,nd+1);
    }
    void operator-=(big&r){
        F(r.l)sub(r.a[i],i);    
		while(l>1&&!a[l-1])--l;
    }
    void mm(big&b,int k,int m){
        CL(a,0),l=b.l+m;
        ll c(0);
        F(b.l)c+=b.a[i]*k,a[i+m]=c%(MM+1),c/=(MM+1);
        while(c)a[l++]=c%(MM+1),c/=(MM+1);
    }
    void operator/=(big&b){
        big t,x(*this);
        if(x<b){*this=0;return;}
        //if(x==b){*this=1;return;}
        CL(a,0),l-=b.l-1;
        for(int i(l-1);~i;--i)for(ll k(1ll<<29);k;k>>=1){
            t.mm(b,k,i);
            if(!(x<t))x-=t,a[i]+=k;
            if(a[i]>MM)add(a[i]/(MM+1),i+1),a[i]%=(MM+1);
        }
        while(l>1&&!a[l-1])--l;
    }
    void st(int u,char *c,int L){
        a[u]=0;l=u+1;
        F(L)a[u]*=10,a[u]+=c[i]-'0';
    }
    bool scan(void){
        static char c[1024];
        if(!~scanf("%s",c))return 0;
        return scan(c),1;
    }
    void scan(char*c){
        int L(strlen(c)),I(0);
        while(L>0)st(I++,c+L-(L>=9?9:L),(L>=9?9:L)),L-=9;
    }
    big operator%(big&b){
        big t,x(*this);
        for(int i(l-b.l);~i;--i)for(int k(1<<29);k;k>>=1){
            t.mm(b,k,i);
            if(!(x<t))x-=t;
        }
        return x;
    }
    big gcd(big&b){
        big A(*this),B(b),C;
        if(B<A)swap(A,B);
        while(!A.eq(0))C=A,A=B%A,B=C;
        return B;
    }
    big operator*(big b){
        b*=*this;
        return b;
    }
    big operator+(big b){
        b+=*this;
        return b;
    }
    big operator-(big b){
        big A(*this);
        A-=b;
        return A;
    }
};
\end{lstlisting}
\subsection{Dělitelnost}
Dělitelnost libovolně dlouhého čísla čísly $\{1,2,...,11,12\}$.
\\V proměnné $s$ je uloženo číslo.
\\Složitost $O(n)$, kde $n$ je počet číslic v čísle.
\begin{lstlisting}[language=C++]
#define DB(A,B) (!((A)%(B)))
int d,l,tt,SD[]={1,3,2,6,4,5},x;
string s,r;
long long sm(void){
    long long S(0);
    for(char c:s)
        S+=c-'0';
    return S;
}
long long smI(void){
    long long S(0),u(1);
    for(char c:s)
        S+=(c-'0')*u,u=~u?-1:1;
    return S;
}
int ld(int k){
    if(k>(int)r.size())
        return stoi(s);
    int S(0);
    for(int i(r.size()-k);i<(int)r.size();++i)
        S*=10,S+=(s[i]-'0');
    return S;
}
bool dbs(void){
    int S(0);
    for(int i(0);i<(int)r.size();++i)
        S+=(r[i]-'0')*SD[i%6];
    return DB(S,7);
}
bool div(int b){
    switch(b){
        case 2: return DB(ld(1),2);
        case 3: return DB(sm(),3);
        case 4: return DB(ld(2),4);
        case 5: return DB(ld(1),5);
        case 6: return div(2)&&div(3);
        case 7: return dbs();
        case 8: return DB(ld(3),8);
        case 9: return DB(sm(),9);
        case 10: return DB(ld(2),10);
        case 11: return DB(smI(),11);
        case 12: return div(3)&&div(4);
    }return 1;
}
r=string(s.rbegin(),s.rend());
\end{lstlisting}
Počet čísel, menších/rovno, než-li \textsf{K}, dělitelných číslem \textsf{N}, jejiž ciferný součin je dělitelný číslem \textsf{N} (implementace pro čísla $<2^{31}$).
\begin{lstlisting}[language=C++]
int dp[10][82][82][2];
int dyn(int d,int n,int g,int f,int L,ll H,int K){
    if(d==L)return !(n%K)&&!(g%K);
    int &v(dp[d][n][g][f]),t(H%10);
    if(~v)return v;
    v=0;
    F(10&&(!f||i<=t))v+=dyn(d+1,(n*10+i)%K,(g+i)%K,i<t?0:f,L,H/10,K);
    return v;
}
int lt(int K,int N){
    if(N<2)return K;//81 for 10^10
    if(N>81)return 0;
    int L(0),t(K);
    ll H(0);
    while(t)++L,H*=10,H+=t%10,t/=10;
    CL(dp,-1);
    return dyn(0,0,0,1,L,H,N);
}
\end{lstlisting}
Počet spojitých posloupností (pole \textsf{A} o délce \textsf{N}), jejiž suma je dělitelná \textsf{M}.
\\Složitost $O(N)$
\begin{lstlisting}[language=C++]
#define MX (100001)
int N,A[MX],C[MX],M;
ll dv(){
    CL(C,0);
    ++C[*A%=M];
    FT(1,N)++C[A[k]=(A[k]+A[k-1])%M];
    ll S(*C);
    F(M)S+=(C[i]*(C[i]-1ll))>>1;
    return S;
}
\end{lstlisting}
Vygenerování všech dělitelů čísla \textsf{N} do \textsf{o}.
\\Jetřeba importovat faktorizaci.
\\Složitost $O(D+H)$, kde \textsf{H} je složitost faktorizace a \textsf{D} je počet dělitelů.
\begin{lstlisting}[language=C++]
void rec(int*f,int*c,int p,int L,vi&o,int S){
    if(p==L)o.PB(S);
    else F(c[p]+1)rec(f,c,p+1,L,o,S),S*=f[p];
}
void dsr(int N,vi&o){
    o.clear();
    static int f[64],c[64];
    int L(fc(N,f,c));
    rec(f,c,0,L,o,1);
//    sort(o.begin(),o.end());
}
\end{lstlisting}
\subsection{Eulerova Funkce}
Eulerova funkce \textsf{N}
\\Složitost závisí od faktorizace
\begin{lstlisting}[language=C++]
int phi(int N){
    static int f[64],c[64];
    int L(fc(N,f,c)),P(1);
    F(L)P*=pow(f[i],c[i])-pow(f[i],c[i]-1)+ZERO;
    return P;
}
\end{lstlisting}
Eulerova funkce na intevalu 0 až \textsf{MX}.
\\V \textsf{O} bude uloženo $\phi(N)$. V \textsf{T} pak bude prefixový součin Eulerových Funkcí.
\begin{lstlisting}[language=C++]
#define MX (5000001)
bool cn[MX];
int O[MX];
ll T[MX]={0,1};
ll pw(ll n,ll k){
    ll r(1);
    while(k){
        if(k&1)r*=n;
        n*=n,k>>=1;
    }
    return r;
}
void phi(){
    FT(1,MX)O[k]=1;
    FT(2,MX){
        if(!cn[k]){
            O[k]*=k-1;
            for(int j(k<<1);j<MX;j+=k){
                cn[j]=1;
                int c(0),h(j);
                while(!(h%k))h/=k,++c;
                O[j]*=pw(k,c)-pw(k,c-1);
            }
        }
        T[k]=T[k-1]+O[k];
    }
}
\end{lstlisting}
\subsection{Faktorizace}
Číslo \textsf{N} je faktorizováno do polí \textsf{f} (faktor) a \textsf{c} (četnost).
\\Návratovou hodnotou je počet různých faktorů.
\\Je nutné mít v \textsf{P} předgenerovaná prvočísla.
\begin{lstlisting}[language=C++]
int fc(int N,int*f,int*c){
    int L(0);
    for(int i(0),h(0);N>=P[i]*P[i];++i,h=0){
        while(!(N%P[i]))++h,N/=P[i];
        if(h)f[L]=P[i],c[L++]=h;
    }
    if(N>1)f[L]=N,c[L++]=1;
    return L;
}
\end{lstlisting}
Pokud můžeme nagenerovat čísla až do \textsf{N}, pak lze faktorizovat takto v $O(log(N)loglog(N))$
\begin{lstlisting}[language=C++]
#define MX (1<<17)
int P[MX],L,D[MX]={0,1};
void gen(){
    FT(2,MX){
        if(!D[k])D[k]=k,P[L++]=k;
        FF(L&&P[j]<=D[k]&&k*P[j]<MX)D[k*P[j]]=P[j];
    }
}
int fc(int N,int*f,int*c){
    static int H[64];
    int J=0,I=0;
    while(D[N]^N)H[J++]=D[N],N/=D[N];
    H[J++]=N;
    sort(H,H+J);
    F(J)if(!i||H[i]^f[I-1])f[I]=H[i],c[I++]=1;
        else ++c[I-1];
    return I;
}
\end{lstlisting}
Předfaktorizace postupem, jako se generují prvočísla
\\V poli \textsf{L} bude počet různých faktorů.
\\V poli \textsf{C} bude počet, kolikrát se faktor objevil.
\\V poli \textsf{f} budou faktrory,
\\Místo pro 8 různých faktorů by mělo stačit až do $\geq 9*10^6$
\\Pro $MX=4*10^6$ to běží na lokálu zhruba kolem sekundy. 
\begin{lstlisting}[language=C++]
#define MX (101)
int L[MX],H[MX],C[MX][8],f[MX][8];
void gen(void){
    F(MX)H[i]=i;
    for(int i(2);i<MX;++i)if(H[i]>1)
        for(int j(i),c(0);j<MX;j+=i,c=0){
            while(!(H[j]%i))H[j]/=i,++c;
            if(c)C[j][L[j]]=c,f[j][L[j]++]=i;
        }
}
\end{lstlisting}
Pollard Rho's Factorisation pro inty
\\Složitost $O(\sqrt[4]{n})$
\\Nutno otestovat!!
\begin{lstlisting}[language=C++]
ll pw(int a, int n, int M){
    ll P(a),r=1;
    while(n){
        if(n&1)r=(r*P)%M;
        P=(P*P)%M,n>>=1;
    }
    return r;
}
bool wt(int a, int n){
    int t(1),u(n>>1);
    ll p,c;
    while(!(u&1))
        u>>=1,++t;
    p=pw(a,u,n);
    F(t){
        c=(p*p)%n;
        if((c==1)&&(p!=1)&&(p!=n-1))return 1;
        p=c;
    }
    return c!=1;
}

bool isP(int n){
    if(((!(n&1))&&n!=2)||(n<2)||(!(n%3)&&n!=3))return 0;
    if(n<1373653){
        for(int k=1;36*k*k-12*k<n;++k)
            if(!(n%(6*k+1))||!(n%(6*k-1)))return 0;
        return 1;
    }
    if(n<9080191)return !wt(31,n)&&!wt(73,n);
    return !wt(2,n)&&!wt(7,n)&&!wt(61,n);
}
int rnd(int b){
    int r(0);
    F(b)r<<=1,r|=rand()&1;
    return r;
}
int gcd(int a,int b){  
    return b?gcd(b,a%b):a;    
}
int mm(int a,int b,int N){
    return (a*1ll*b)%N;
}
int rho(int N) {
    if(!(N&1))return 2;
    int d,c(rnd(ceil(log2(N)-ZERO))),x(rnd(ceil(log2(N)-ZERO))),xx=x;
    do{
        x=mm(x,x,N),x+=c,x%=N;
        xx=mm(xx,xx,N),xx+=c,xx%=N;
        xx=mm(xx,xx,N),xx+=c,xx%=N;
        d=gcd(abs(x-xx),N);
    }while(d==1);
    return d;
}
int ff(int N,int*f,int L){
    if(N<=1)return L;
    if(isP(N))return f[L]=N,++L;
    int d(rho(N));
    return ff(N/d,f,ff(d,f,L));
}
int fc(int N,int*f,int*c){
    static int G[66];
    int L(ff(N,G,0)),I(0),l(0);
    G[L]=-1;
    sort(G,G+L);
    while(I<L){
        f[l]=G[I++],c[l]=1;
        while(G[I]==G[I-1])++c[l],++I;
        ++l;
    }
    return l;
}
\end{lstlisting}
Pollard Rho's Factorisation
\\Složitost $O(\sqrt[4]{n})$
\begin{lstlisting}[language=C++]
ll R[]={2,3,5,7,11,13,17,19,23,29,31,37},nt(INF);
ll mm(ll a,ll b,ll M){
    if(a<INF&&b<INF)return (a*b)%M;
    ll v(0),w(a%M);
    while(b)v=b&1?(v+w)%M:v,w=(w<<1)%M,b>>=1;
    return v%M;
}
ll pw(ll n,ll k,ll M){
    ll r=1;
    while(k){
        if(k&1)r=mm(r,n,M);
        n=mm(n,n,M),k>>=1;
    }
    return r%M;
}
bool isP(ll n){
    if(n<2)return 0;
    if(!(n&1))return n==2;
    ll s=n-1;
    while(!(s&1))s>>=1;
    if(n<40){FT(3,n)if(!(n%k))return 0;return 1;}
    F(12){
        ll z(R[i]),t(s),r(pw(z,t,n));
        if(r==1)continue;
        while(t!=n-1&&r!=n-1)
            r=mm(r,r,n),t<<=1;
        if(r!=(n-1))return 0;
    }
    return 1;
}
ll rnd(int b){ll r(0);F(b)r<<=1,r|=rand()&1;return r;}
#define GF(X) (mm(X,X,N)+c)%N
ll rho(ll N){
    if(!(N&1))return 2;
    ll d,c(rnd(ceil(log2(N)-ZERO))),x(rnd(ceil(log2(N)-ZERO))),xx=x;
    do x=GF(x),xx=GF(xx),xx=GF(xx),d=__gcd(llabs(x-xx),N); while(d==1);
    return d;
}
int ff(ll N,ll*f,int L){
    if(N<=1)return L;
    if(isP(N))return f[L]=N,++L;
    ll d(N);
    while(d==N)d=rho(N);
    return ff(N/d,f,ff(d,f,L));
}
int fc(ll N,ll*f,int*c){
    static ll G[66];
    int L(ff(N,G,0)),I(0),l(0);
    G[L]=-1;
    sort(G,G+L);
    while(I<L){
        f[l]=G[I++],c[l]=1;
        while(G[I]==G[I-1])++c[l],++I;
        ++l;
    }
    return l;
}
\end{lstlisting}
\subsection{Faktorizované číslo}
Číslo ve struktuře fn se bude držet pomocí "faktorů".
\\Funkce $ad$ vynásobí číslo číslem, které je v argumentu
\\Funkce $sb$ vydělí číslo číslem, které je v argumentu
\\Struktura slouží k uchovávání faktoriálů / kombinačních čísel - nesmí se tedy nikdá dělit něčím, co v čísle není. Všechna čísla musí být navíc menší, než-li MX
\\Funkce $ev$ vrátí číslo takové, jaké je.
\\Funkce $clr$ musí být zavolána před operací s číslem ($gen$ se volá zní - ale pouze u prvního zavolání).
\begin{lstlisting}[language=C++]
#define MX (22)
int L[MX],H[MX],C[MX][8],f[MX][8],X;
void gen(void){
    F(MX)H[i]=i;
    for(int i(2);i<MX;++i)if(H[i]>1)
        for(int j(i),c(0);j<MX;j+=i,c=0){
            while(!(H[j]%i))H[j]/=i,++c;
            if(c)C[j][L[j]]=c,f[j][L[j]++]=i;
        }
}
ll pw(ll n,ll k){
    ll r(1);
    while(k){
        if(k&1)r*=n;
        n*=n,k>>=1;
    }
    return r;
}
struct fn{
    int F[MX];
    void clr(){CL(F,0);if(!X++)gen();}
    void ad(int a){F(L[a])F[f[a][i]]+=C[a][i];}
    void sb(int a){F(L[a])F[f[a][i]]-=C[a][i];}
    ll ev(){ll S(1);F(MX)if(F[i])S*=pw(i,F[i]);return S;}
};
\end{lstlisting}
\subsection{FFT}
Algoritmus pro násobení dvou polynomů.
\\Vstupem jsou vždy dvojice polynom a velikost. Pátým parametrem je pak polynom výstupní
\\MX by mělo být nastaveno na dvojnásobek (pro jistotu 4-násobek) délky vstupního polynomu
\\Return value je délka výsledného polynomu.
\\Složitost $O(nlog(n))$
\begin{lstlisting}[language=C++]
typedef complex<double> cpx;
void dft(const cpx *s,cpx *r,int n,const cpx &wn,cpx *h){
    if(n==1){*r=*s;return;}
    int N=n>>1,j(-2),k(-1);;
    cpx *os=h,*es=h+N,*oR=h+2*N,*eR=h+3*N;
    F(N)es[i]=s[j+=2],os[i]=s[k+=2];
    cpx w(1,0),t(wn*wn);
    dft(es,eR,N,t,h+4*N),dft(os,oR,N,t,h+4*N);
    F(N)t=w*oR[i],r[i]=eR[i]+t,r[i+N]=eR[i]-t,w=wn*w;
}
int fft(ll *f,int A,ll *s,int B,ll *r){
    static cpx ra[MX],b[MX],a[MX],rb[MX],tr[MX],wn,o[(MX)<<2];
    int N(1),h(max(A,B)*2-1),H(A+B-1);
    while(N<=h)N<<=1;
    F(N)a[i]=b[i]=ra[i]=rb[i]=tr[i]={0,0};
    F(A)a[i].real(f[i]);
    F(B)b[i].real(s[i]);
    wn={cos(2*M_PI/N),sin(2*M_PI/N)};
    dft(a,ra,N,wn,o),dft(b,rb,N,wn,o);
    F(N)tr[i]=ra[i]*rb[i];
    dft(tr,rb,N,pow(wn,-1),o);
    F(N)rb[i].real(rb[i].real()/N);
    F(H)r[i]=(ll)(rb[i].real()+0.5);
    return H;
}
\end{lstlisting}
Diskrétní verze FFT.
\begin{lstlisting}[language=C++]
#define MX (1<<19)
ll gcd(ll a,ll b,ll&s,ll&t){
    if(!b)return t=0,s=a<0?-1:1,a<0?-a:a;
    ll g=gcd(b,a%b,t,s);t-=a/b*s;return g; 
}
ll inv(ll n,ll m){ll s,t;return gcd(n,m,s,t),s>0?s:s+m;}
const ll RW=1<<25,m=5*RW+1,R=243,R1=114609789;
void fft(ll*a,int n,bool I){
    int J=0;
    FT(1,n){
        int b=n>>1;
        while(J>=b)J-=b,b>>=1;
        J+=b;
        if(k<J)swap(a[k],a[J]);
    }
    for(int k=2;k<=n;k<<=1) {
        ll W=I?R1:R;
        for(ll i=k;i<RW;i<<=1)W*=W,W%=m;
        for(int i=0;i<n;i+=k) {
            ll w=1;
            FF(k/2){
                ll u=a[i+j],v=a[i+j+k/2]*w%m;
                a[i+j]=u+v<m?u+v:u+v-m;
                a[i+j+k/2]=u-v>=0?u-v:u-v+m;
                w*=W,w%=m;
            }
        }
    }
    ll r=inv(n,m);
    if(I)F(n)a[i]=a[i]*1ll*r%m;
}
int fftV(ll*A,int S,ll*B,int R,ll*C){
    int L=1;
    while(L<=S<<1||L<=R<<1)L<<=1;
    fft(A,L,0),fft(B,L,0);
    F(L)C[i]=A[i]*B[i]%m;
    return fft(C,L,1),L;
}
\end{lstlisting}
\subsection{Friedvaldův Algoritmus}
Zjistí, jestli pro [$N\times N$]matice \textbf{A,B,C} platí $A*B==C$.
\\Algoritmus je "probabilistický", takže je vhodné pustit ho na více iteracích
\\Složitost $O(IT*N^2)$
\begin{lstlisting}[language=C++]
#define MX 1000
#define IT (5)
void mm(int M[][MX],int*x,int N,int*R){
    F(N)R[i]=0;
    F(N)FF(N)R[i]+=M[i][j]*x[j];
}
bool sm(int N,int A[][MX],int B[][MX],int C[][MX]){
    static int U[MX],V[MX],W[MX],v[MX];
    F(IT){
        F(N)v[i]=rand();//care for overflow! [while "mm"]
        mm(A,v,N,U),mm(B,U,N,V),mm(C,v,N,W);
        F(N)if(V[i]^W[i])return 0;
    }
    return 1;
}
#define INI srand(time(0))
\end{lstlisting}
\subsection{Gauss-Jordan}
Použití:
\begin{itemize}
	\item Vyřešení systému lineárních rovnic ($AX=B$)
	\item Invertování matice ($AX=I$)
	\item Spočítání determinantu čtvercové matice
\end{itemize}
Input: Matice \textsf{A} ($n \times n$), matice \textsf{B} ($n \times m$)
\\Output:
\begin{itemize}
\item \textbf{X} ($n \times m$) - uložená v \textsf{B};
\item \textbf{$A^{-1}$} - uložená v \textsf{A};
\item Determinant (návratová hodnota)
\end{itemize}
Složitost $O(N^3)$
\begin{lstlisting}[language=C++]
#define MX (101)
ld GJ(ld a[MX][MX],ld b[MX][MX],int n,int m) {
    static int R[MX],C[MX],P[MX];
    CL(R,0),CL(C,0),CL(P,0);
    ld D=1;
    F(n){    
        int J(-1),K(-1);
        FF(n)if(!P[j])FT(0,n)if(!P[k]&&(!~J||fabs(a[j][k])>fabs(a[J][K])))J=j,K=k;
        assert(!EQ(a[J][K],ZERO));//Singularni
        ++P[K],swap(a[J],a[K]),swap(b[J],b[K]);
        if(J!=K)D=-D;
        R[i]=J,C[i]=K;
        ld c(1./a[K][K]);
        D*=a[K][K],a[K][K]=1.;
        F(n)a[K][i]*=c;
        F(m)b[K][i]*=c;
        FF(n)if(j!=K){
            c=a[j][K],a[j][K]=0;
            F(n)a[j][i]-=a[K][i]*c;
            F(m)b[j][i]-=b[K][i]*c;
        }
    }
    for(int j(n-1);~j;--j)if(R[j]!=C[j])
        F(n)swap(a[i][R[j]],a[i][C[j]]);
    return D;
}
\end{lstlisting}
Sem se nacpou rovnice $N\times (N+1)$ a v \textsf{W} se objeví výsledky!
\begin{lstlisting}[language=C++]
#define MX (20)
void GS(ld A[MX][MX],int N,ld*W){
    static int E[MX],K;
    CL(E,0);
    F(N){
        K=i;
        FT(i,N)if(fabs(A[K][i])<fabs(A[k][i]))K=k;
        if(fabs(A[K][i])<ZERO)continue;
        if(K^i)FF(N+1)swap(A[K][j],A[i][j]);
        FF(N)if(i^j)for(int k=N;k>=i;--k)
            A[j][k]-=A[j][i]/A[i][i]*A[i][k];
    }
    for(int i=N-1;~i;--i) {
        if(fabs(A[i][i])<ZERO)E[i]=1;
        else W[i]=fabs(A[i][N])<ZERO?0:A[i][N]/A[i][i];
        FT(i+1,N)E[i]|=fabs(A[i][k])>ZERO&&E[k];
    }
}
\end{lstlisting}
\subsection{Inverze čísla na modulu}
Pozor, není otestováno!
\\Výstupem je inverze, pokud existuje. Pokud ne, pak je výstupem \textbf{-1}.
\begin{lstlisting}[language=C++]
#define MOD (1000000007)
ll gcdE(ll a,ll m,ll &x,ll &y){
    if(!a)return x=0,y=1,m;
    ll u,v,g(gcdE(m%a,a,u,v));
    return x=v-(m/a)*u,y=u,g;
}
ll inv(ll a,ll m=MOD){
    ll x,y,g(gcdE(a,m,x,y));
    return g==1?(x%m+m)%m:-1;
} 
\end{lstlisting}
\begin{lstlisting}[language=C++]
#define MOD (1000000007)
ll pw(ll n,ll k){
    ll r(1);
    while(k){
        if(k&1)r*=n,r%=MOD;
        n*=n,n%=MOD,k>>=1;
    }
    return r;
}
ll inv(ll a){return pw(a,MOD-2);}
\end{lstlisting}
\subsection{Karatsubův algoritmus}
Algoritmus pro násobení dvou polynomů.
\\Vstupem jsou vždy dvojice polynom a velikost. Pátým parametrem je pak polynom výstupní
\\MX by mělo být nastaveno na dvojnásobek (pro jistotu 4-násobek) délky vstupního polynomu
\\Return value je délka výsledného polynomu.
\\Složitost $O(n^{1.585})$
\begin{lstlisting}[language=C++]
#define MX (1<<14)
void kal(ll *a,ll *b,ll L,ll *c,ll *v,ll *w,ll h,ll m){
    if(h>=m)return;
    if(L<=8){
        F(L)FF(L)c[i+j]+=a[i]*b[j];
        return;
    }
    ll d(L>>1),*A=v,*B=w;
    v=v+L,w=w+L;
    F(L)A[i]=B[i]=0;
    kal(a,b,d,A,v,w,h,m);
    kal(a+d,b+d,d,B,v,w,h+d,m);
    F(L)c[i]+=A[i],c[i+L]+=B[i],c[i+d]-=A[i]+B[i];
    F(d)A[i]=a[i]+a[i+d],B[i]=b[i]+b[i+d];
    kal(A,B,d,c+d,v,w,h,m);
}
ll kar(ll *a,ll A,ll *b,ll B,ll *c){
    static ll V[MX],W[MX];
    ll l(max(A,B)),N(1);
    while(N<l)N<<=1;
    FT(A,N)a[k]=0;
    FT(B,N)b[k]=0;
    F(N<<1)c[i]=0;
    kal(a,b,N,c,V,W,0,min(A,B));
    return (A+B)-1;
}
\end{lstlisting}
\subsection{Mocnina}
Mocnina v modulu
\begin{lstlisting}[language=C++]
#define MOD (1000000007)
ll pw(ll n,ll k){
    ll r(1);
    while(k){
        if(k&1)r*=n,r%=MOD;
        n*=n,n%=MOD;
        k>>=1;
    }
    return r;
}
\end{lstlisting}
Mocnina obecná
\begin{lstlisting}[language=C++]
ll pw(ll n,ll k){
    ll r(1);
    while(k){
        if(k&1)r*=n;
        n*=n,k>>=1;
    }
    return r;
}
\end{lstlisting}
Mocnina v modulu
\begin{lstlisting}[language=C++]
ll pw(ll n,ll k){
    if(!k)return 1;
    if(k&1)return n*pw(n,k-1)%MOD;
    ll t=pw(n,k/2);return t*t%MOD;
}
\end{lstlisting}
\subsection{Mocnění matice}
Argumenty jsou vstupní čtvercová matice \textsf{A}, výstupní matice \textsf{R}, velikost matice \textsf{W} a modulu \textsf{MD}.
\begin{lstlisting}[language=C++]
void mul(ll A[MM][MM],ll B[MM][MM],ll R[MM][MM],int W,ll M){
    F(W)FF(W)R[i][j]=0;
    F(W)FF(W)FT(0,W)R[i][j]+=A[i][k]*B[k][j],R[i][j]%=M;
}
void pw(ll M[MM][MM],ll R[MM][MM],int W,ll k,ll MD){
    static ll E[MM][MM],H[MM][MM];
    F(W)FF(W)R[i][j]=E[i][j]=i==j;
    while(k){
        if(k&1)mul(E,M,R,W,MD),memcpy(E,R,sizeof(E));
        mul(M,M,H,W,MD);
        memcpy(M,H,sizeof(H));
        k>>=1;
    }
}
\end{lstlisting}
O něco rychlejší verze pro matici $2\times2$
\begin{lstlisting}[language=C++]
void m2(ll A[MM][MM],ll B[MM][MM],ll R[MM][MM],int W,ll M){
    R[0][0]=(A[0][0]*B[0][0]+A[0][1]*B[1][0])%M;
    R[0][1]=(A[0][0]*B[0][1]+A[0][1]*B[1][1])%M;
    R[1][0]=(A[1][0]*B[0][0]+A[1][1]*B[1][0])%M;
    R[1][1]=(A[1][0]*B[0][1]+A[1][1]*B[1][1])%M;
}
\end{lstlisting}
\subsection{Modulo}
Modulo celého (kladného i záporného) čísla.
\begin{lstlisting}[language=C++]
ll MD(ll a){return (a>=0?a%MOD:a+(-a/MOD+1)*MOD)%MOD;}
\end{lstlisting}
Násobení v modulu
\begin{lstlisting}[language=C++]
ll mm(ll a,ll b,ll M){
    ll v(0),w(a%M);
    while(b)v=b&1?(v+w)%M:v,w=(w<<1)%M,b>>=1;
    return v%M;
}
\end{lstlisting}
Další způsob násobení v modulu (rychlejší, ale jen pro menší čísla [do $10^{12}$])
\begin{lstlisting}[language=C++]
ll mm(ll a,ll b,ll M){
	ll C=1000000,u=a/C,U=a%C,w=b/C,W=b%C;
    return (U*w*C%M+W*u*C%M+U*W)%M;
}
\end{lstlisting}
\subsection{Nega-numbers}
Převádění z \textit{r-ární} negované soustavy do desítkové a naopak.
\begin{lstlisting}[language=C++]
string conv(int d){
    string nm;
    int x;
    while(d){
        if(d>0)x=d%r,d=-d/r;
        else x=(-d)%r,x=x>0?r-x:x,d=-(d-x)/r;
        nm+=to_string(x);
    }
    return nm.empty()?"0":string(nm.rbegin(),nm.rend());
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
int toD(char *c){
    int x(0);
    for(int i(strlen(c)-1),R(1);~i;--i)
        x+=R*(c[i]-'0'),R*=-r;
    return x;
}
\end{lstlisting}
\subsection{Nejmenší číslo, které je dělitelné n děliteli}
Ve vektoru $o$ jsou uloženy faktory čísla \textsf{n} (viz faktorizace).
\\Princip: Faktorizujeme si číslo \textsf{n} (počet dělitelů - včetně sebe a jedničky). Ty pak pronásobit (všemi možnostmi) taky, aby tvořili nerostoucí posloupnost ($a_1\geq a_2 \geq ... \geq a_k$). Poté prvních \textsf{k} prvočísel umocnit na $a_i-1$ a vynásobit mezi sebou.
\\Tato implementace vrací nulu pro čísla větší jak \textsf{TP} - jinak samozřejmě lze nalézt pro každé číslo - jen by bylo nutné využít $big$.
\\Složitost není triviální, nicméně je mnohonásobně vyšší, než-li $O(log(n)!)$.
\begin{lstlisting}[language=C++]
#define TP (1000000000000001LL)
ll mul(ll a,ll b){
    ll c(a*b);
    return b&&c/b==a&&c<=TP?c:0;
}
ll pw(ll n,ll k){
    ll r(1);
    while(k){
        if(k&1)r=mul(r,n);
        n=mul(n,n);
        k>>=1;
    }
    return r;
}
#define OK(K) (h.empty()||S<=h.back())
#define MIN(A,B) (A?B?min(A,B):A:B)
ll rc(const vector<int> &o,vector<int> &h,int p){
    if(p==(ll)o.size()){
        ll S(1);
        F((ll)h.size())S=mul(S,pw(P[i],h[i]-1));
        return S;
    }
    ll S(1),H(0),t;
    F((ll)o.size()-p){
        S*=o[p+i];
        if(OK(S)){
            h.push_back(S);
            t=rc(o,h,p+i+1);
            H=MIN(H,t);
            h.pop_back();
        }
    }
    return H;
}
do S=MIN(S,rc(o,p,0));
while(next_permutation(o.begin(),o.end()));
\end{lstlisting}
\subsection{Nejmenší společný násobek}
\begin{lstlisting}[language=C++]
int lcm(int a,int b){
    int t(gcd(a,b));
    return t?(a/t*b):0;
}
\end{lstlisting}
\begin{center}
Pokud chceme pro vícero hodnot.
\end{center}
\begin{lstlisting}[language=C++]
#include <numeric>
accumulate(arr,arr+n,1,lcm);
\end{lstlisting}
Short
\begin{lstlisting}[language=C++]
int lcm(int a,int b){return  a/__gcd(a,b)*b;}
\end{lstlisting}
\subsection{Největší společný dělitel}
Algoritmus skončí nejpozději po $5d(a)$ krocích (kde $d(a)$ je počet cifer čáska \textsf{a}).
\\Složitost je tedy $log(N)$.
\begin{lstlisting}[language=C++]
int gcd (int a,int b){
  int c;
  while(a)
     c=a,a=b%a,b=c;
  return b;
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
int gcd(int a, int b){  
    return b?gcd(b,a%b):a;    
}
\end{lstlisting}
\begin{center}
Rozšířený \textsf{GCD}
\end{center}
\begin{lstlisting}[language=C++]
ll eGCD(ll a,ll b,ll &x,ll &y){
    ll xx,yy,r;
    if(a<b)return eGCD(b,a,y,x);
    if(!b)return x=1,y=0,a;
    return r=eGCD(b,a%b,xx,yy),x=yy,y=(xx-a/b*yy),r;
}
\end{lstlisting}
Rozšířený \textsf{GCD}
\\$gcd(a,b)==g==a*x+b=y$
\begin{lstlisting}[language=C++]
void eGCD(ll a,ll b,ll&x,ll&y,ll&g) {
  if(!b)x=1,y=0,g=a;
  else eGCD(b,a%b,y,x,g),y-=a/b*x;
}
\end{lstlisting}
\begin{center}
Největší společný dělitel pole.
\end{center}
\begin{lstlisting}[language=C++]
int gcd_arr(int *n,int s){
    if(s<2)
        return 0;
    int lgcd(gcd(n[0],n[1]));
    for(int i(2);i<s;++i)
        lgcd=gcd(lgcd,n[i]);
    return lgcd;
}
\end{lstlisting}
\begin{center}
Největší společný dělitel - binární metoda.
\end{center}
\begin{lstlisting}[language=C++]
int gcd(int u,int v){
    int shl(0),t;
    while(u&&v&&u!=v){
        bool eu(!(u&1)),ev(!(v&1));
        if(eu&&ev)++shl,u>>=1,v>>=1;
        else if(eu&&!ev)u>>=1;
        else if(!eu&&ev)v>>=1;
        else if(u>=v)u=(u-v)>>1;
        else t=u,u=(v-u)>>1,v=t;
    }
    return !u?v<<shl:u<<shl;
}
\end{lstlisting}
První čas, kdy se dva dvě periodicky opakující věci setkají (začátek v \textsf{b}/\textsf{B}) / (perioda \textsc{d}/\textsf{D})
\\Pokud se nesetkají, funkce vrátí -1.
\\Funkce je bezpečná pro inty [hodnoty jejiž násobek se vleze do $ll$]
\begin{lstlisting}[language=C++]
void eGCD(ll a,ll b,ll&x,ll&y,ll&g){
    if(!b)x=1,y=0,g=a;
    else eGCD(b,a%b,y,x,g),y-=a/b*x;
}
ll mm(ll a,ll b,ll M){
    ll v(0),w(a%M);
    while(b)v=(v+b%2*w)%M,w=w*2%M,b>>=1;
    return v%M;
}
ll sol(ll b,ll d,ll B,ll D){
    ll P,Q,g,L,S;
    eGCD(d,D,P,Q,g);
    if((B-b)%g)return -1;
    L=d/g*D,S=mm((B-b)/g*P,d,L)+b;
    return S+(S<max(b,B))*L;
}
\end{lstlisting}
\subsection{Normalizace čísel v posloupnosti}
\begin{lstlisting}[language=C++]
void rnm(int*A,int N){
    static int B[MX],L;
    memcpy(B,A,N<<2);
    sort(B,B+N),L=unique(B,B+N)-B;
    unordered_map<int,int> T;
    F(L)T[B[i]]=i;
    F(N)A[i]=T[A[i]];
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
void rnm(int*A,int N){
    static ii B[MX];
    int L=0;
    F(N)B[i]={A[i],i};
    sort(B,B+N);
    F(N)A[B[i].bb]=L+=i&&B[i].aa^B[i-1].aa;
}
\end{lstlisting}
\subsection{Odmocnina}
Spíš zajímavost, stejně je pomalejší než-li knihovní
\begin{lstlisting}[language=C++]
double SQ(double n){
    double x(n),y(1);
    while(!EQ(x,y))
        x=(x+y)/2,y=n/x;
    return x;
}
\end{lstlisting}
\subsection{Ohodnocení matice}
Vrátí ohodnocení matice (počet lineárně nezávislých řádků).
\\Matice bude znehodnocena
\\Metoda využívá modulo ~ existuje tedy jistá pravděpodobnost, že výsledek nebude správný - ta je ovšem velmi nízká (případně vyzkoušet jiné prvočíslo).
\\Složitost $O(n^3log(U))$, kde $O(n^3)$ je za gaussovu eliminační metodu a $O(log(U))$ je používání lcm (pro lepší zacházení s čísly).
\begin{lstlisting}[language=C++]
#define MX (256)
#define MOD (1500000001)
ll nm(ll A){
    if(A<0)A+=(-A/MOD+1)*MOD;
    return A%MOD;
}
ll gcd(ll a,ll b){  
    return b?gcd(b,a%b):a;    
}
ll lcm(ll a,ll b){
    ll t(gcd(a,b));
    return t?(a/t*b):0;
}
void sl(ll*A,ll*B,int L){
    F(L)swap(A[i],B[i]);
}
bool zr(ll*A,int L){
    F(L)if(A[i])return 0;
    return 1;
}
int rnk(ll X[MX][MX],int N,int M){
    ll o,I,a,b,l,S(0),W(0);
    F(N){
        I=W;
        while(I<N&&!X[I][i])++I;
        if(I==N)continue;
        if(I!=W)sl(X[W],X[I],M);
        FT(W+1,N)if(X[k][i]){
            o=0,l=lcm(X[W][i],X[k][i]),a=l/X[W][i],b=l/X[k][i];
            FOR(j,i,M)o|=X[k][j]=nm(a*X[W][j]-b*X[k][j]);
            if(!o)sl(X[--N],X[k--],M);
        }
        ++W;
    }
    F(N)S+=!zr(X[i],M);
    return S;
}
\end{lstlisting}
Verze ohodnocení matice pro matici obsahující pouze nuly/jedničky!
\\Složitost $O(N^3)$
\begin{lstlisting}[language=C++]
#define MX (30001)
#define MM (55)
void sl(bool*A,bool*B,int L){F(L)swap(A[i],B[i]);}
int rnk(bool X[MX][MM],int N,int M){
    ll I,W(0);
    F(M){
        I=W;
        while(I<N&&!X[I][i])++I;
        if(I>=N)continue;
        if(I^W)sl(X[W],X[I],M);
        FT(W+1,N)if(X[k][i])FOR(j,i,M)X[k][j]^=X[W][j];
        ++W;
    }
    return W;
}
\end{lstlisting}
\subsection{Počet číslic}
Počet číslic mezi čísly 0 až $n$.
\begin{lstlisting}[language=C++]
ll tdig(ll n){
    ll a(0),k(-1),N(n),P(1),D;
    while(N)a=N,N/=10,++k,P*=10;
    P/=10;
    D=(k+1)*((n%(P*a))+1+(a-1)*P);
    F(k)D+=9*(i+1)*pow(10,i);
    return D+1;
}
\end{lstlisting}
Počet jedné číslice mezi čísly 0 až $n$.
\begin{lstlisting}[language=C++]
ll dg(ll n,ll d);
ll zr(ll n,ll d){
    ll D=tdig(n);
    FT(1,10)D-=dg(n,k);
    return D;
}
ll dg(ll n,ll d){
    if(n<10)return d<=n;
    if(!d)return zr(n,d);
    ll a(0),k(-1),N(n),P(1);
    while(N)a=N,N/=10,++k,P*=10;
    P/=10;
    if(a<d) return dg(n%(P*a),d)+k*P*a/10;
    if(a==d)return dg(n%(P*a),d)+k*P*a/10+1+(n%(P*a));
    return (a*k+10)*(P/10)+dg(n%(P*a),d);
}
\end{lstlisting}
Počet čísel, které obsahují číslici \textsf{d} (od 0 do \textsf{n}) - netestováno pro 0. 
\\Pro vícero číslic je pak nutné upravit to, jak vypadá pole \textsf{H} a mocnit menší číslo.
\begin{lstlisting}[language=C++]
typedef long long ll;
ll pw(ll n,ll k){
    ll r(1);
    while(k){
        if(k&1)
            r*=n;
        n*=n,k>>=1;
    }return r;
}
ll cod(ll N,ll d){
    static ll H[10];
    F(10)H[i]=i>=d?i-1:i;
    K=k=0;P=N;
    while(P)K+=H[P%10]*pw(9,k++),P/=10;
    return N-K;
}
\end{lstlisting}
Počet číslic ve faktoriálu čísla \textsf{n} v bázi \textsf{b}.
\\Složitost $~O(Nlog(N))$
\\Pozor, jedná se o heuristiku (nicméně dosti přesnou)
\\Pro menší čísla lze využít přesnější vzorec $log(N!)=log(N)+log(N-1)+...+log(2)+log(1)$ (chceme horní celou část!)
\\Dále, že $log_b(N)=log(N)/log(b)$
\begin{lstlisting}[language=C++]
int dfH(int n,int b){
    if(!n)return 1;
    return 1-ZERO+((log(n)-1)*n+log(sqrt(2*M_PI))+log(n)/2+pow(n,-1)/12+pow(n,-3)/360+
    pow(n,-5)/260+pow(n,-7)/1680)/log(b);
}
\end{lstlisting}
Jiná implementace
\begin{lstlisting}[language=C++]
ll db(ll N,ll b){
    ld S(0);
    FT(2,N+1)S+=log(k);
	return S/log(b)+ZERO+1;
}
\end{lstlisting}
Počet nul na konci čísla \textsf{N} v bázi \textsc{b}
\begin{lstlisting}[language=C++]
ll tz(ll N,ll b){
    ll Z(INF),A,B;
    FT(2,b+1)if(!(b%k)){
        A=B=0;
        while(!(b%k)&&b)++B,b/=k;
        for(ll j(k);j<=N;j*=k)A+=N/j;
        Z=min(Z,A/B);
    }
    return Z;
}
\end{lstlisting}
Počet čísel mezi $0 \leftarrow N$, které končí sudým počtem nul.
\begin{lstlisting}[language=C++]
int z[]={1,2,3,4,5,5,5,5,5,5,6,7,8,9,10,10,10,10,10,10,11,12,13,14,15,16};
ll eve(ll N){
    if(N<25)return z[N];
    bool X=1;
    ll S=0,p,C,t,a;
    while(N>25){
        p=t=a=1,C=0;
        while(p*5<=N)a=t&1?a*5:3*a+2*(p-a),C+=p,++t,p*=5;
        if(X)S+=a;
        else S+=p-a;
        if(C&1)X^=1;
        N-=p;	
    }
    return S+(X?z[N]:N+1-z[N]);
}
\end{lstlisting}
Počet číslic kombinačního čísla
\begin{lstlisting}[language=C++]
int cd(int N,int K){
    K=min(K,N-K);
    ld S(0);
    F(K)S+=log10(N-i)-log10(i+1);
    return S+1;
}
\end{lstlisting}
\subsection{Počet dělitelů}
Počet dělitelů čísla.
\\\textsf{P} jsou prvočísla (sqrt(MAX))
\begin{lstlisting}[language=C++]
int sl(ll n){
    ll t(1);
    for(ll i(0),ct(0);P[i]*P[i]<=n;++i,ct=0){
        while(!(n%P[i]))
            n/=P[i],++ct;
        t*=ct+1;
    }
    if(n!=1)t<<=1;
    return t;
}
\end{lstlisting}
\subsection{Počet inverzí}
Inverze znamená že $a[i]>a[j]$ a zároveň $i<j$.
\\Do $V[i]$ se uloží počet inverzí pro daný prvek.
\\Složitost $O(nlog(n))$
\begin{lstlisting}[language=C++]
int N,a[MX],V[MX],W[MX];
void foo(int a){
    while(a<MX)++W[a],a+=a&-a;
}
int bar(int a){
    int S(0);
    while(a)S+=W[a],a-=a&-a;
    return S;
}
for(int i(N-1);~i;--i)
    V[i]=bar(a[i]-1),foo(a[i]);
\end{lstlisting}
Přemapování - hodí se, pokud bychom dostali čísla ve velkém rozmezí (tedy ne permtaci ale prostě inty/longy).
\begin{lstlisting}[language=C++]
void mp(ll *a,int N){
    static int b[MX];
    F(N)b[i]=a[i];
    sort(b,b+N);
    int C(1);
    unordered_map<ll,int> T;
    F(N)if(!T.count(b[i]))T[b[i]]=C++;
    F(N)a[i]=T[a[i]];
}
\end{lstlisting}
Zde je verze s $Merge\ Sortem$. Seřadí vstupní pole a návratovou hodnotou bude počet inverzí.
\\Je to o něco lehčí a není nutné přemapovávat.
\\Vstupní paramtetry jsou pole \textsf{A} a jeho velikost \textsf{N}.
\\Složitost $O(Nlog(N))$.
\begin{lstlisting}[language=C++]
#define MX (1<<19)
ll mg(int*A,int a,int*B,int b,int*R){
    ll S(0);
    int I(0),J(0),L(0);
    while(I<a&&J<b)
        if(A[I]<=B[J])R[L++]=A[I++];
        else R[L++]=B[J++],S+=a-I;
    while(I<a)R[L++]=A[I++];
    while(J<b)R[L++]=B[J++];
    return S;
}
int R[MX];
ll ms(int N,int *A){
    if(N<2)return 0;
    ll L(N>>1),S(ms(L,A)+ms(L+(N&1),A+L));
    S+=mg(A,L,A+L,L+(N&1),R);
    F(N)A[i]=R[i];
    return S;
}
\end{lstlisting}
\subsection{Počet prvočísel}
Zjistí počet prvočísel menších než \textsf{N} (nějak docela rychle).
\\$SQ$ je o něco větší než odmocnina
\begin{lstlisting}[language=C++]
#define SQ (8000)
#define LIM 350
bool p[SQ];
int C[SQ],dp[LIM*LIM][LIM],P[SQ],L;
ll rec(ll N,int K) {
    if(N<=1||K<0)return 0;
    if(N<=P[K])return N-1;
    if(N<SQ&&P[K]*1ll*P[K]>N)return N-1-C[N]+C[P[K]];
    bool x=N<LIM*LIM;
    if(x&&dp[N][K])return dp[N][K];
    ll S= N/P[K]-rec(N/P[K],K-1)+rec(N,K-1);
    if(x)dp[N][K]=S;
    return S;
}
ll cps(ll N) {
    if(N<SQ)return C[N];
    int K=C[(int)sqrt(N)+1];
    return N-1-rec(N,K)+C[P[K]];
}
void ini(){
    p[2]=1;
    FT(3,SQ)p[k++]=1;
    for(int i=3;i*i<SQ;i+=2)if(p[i])
        for(int j=i*i;j<SQ;j+=i+i)p[j]=0;
    F(SQ)if(p[i])P[L++]=i;
    FT(1,SQ)C[k]=C[k-1]+p[k];
}
\end{lstlisting}
\subsection{Postfix}
Funkce vypočte hodnotu postfixem zapsané formule uložené ve stringu \textsf{s}.
\\Je nutné aby operátory a operandy byly odděleny mezerou.
\begin{lstlisting}[language=C++]
double cnt(double a,double b,char c){
    return c=='+'?a+b:c=='-'?a-b:c=='*'?a*b:a/b;
}
double cntPos(const string &s){
    string r;
    istringstream sin(s);
    double a,b;
    stack<double> q;
    while(sin>>r)
        if(isdigit(r[0]))
            q.push(stod(r));
        else
            a=q.top(),q.pop(),b=q.top(),q.pop(),q.push(cnt(b,a,r[0]));
    return q.top();
}
\end{lstlisting}
Převod Infixu na Postfix (s mezerami).
\begin{lstlisting}[language=C++]
#define MX 128
#define TP S[sl-1]
#define PP (--sl)
#define PS(C) (S[sl++]=C)
#define mrk(C) (isalpha(C)||isdigit(C))
#define iso(C) (C=='+'||C=='-'||C=='*'||C=='/'||C=='$')
#define ra(C) (C=='$')
#define UN(C) (0)
int wth(char o){
    switch(o){
	case '+':case '-':return 1;
	case '*':case '/':return 2;
	case '$':return 3;
    }return -1;
}
int hhp(char a,char b){
    int aw(wth(a)),bw(wth(b));
    return aw==bw?!ra(a):aw>bw;
}
string itp(string e){
    static char S[MX];
    string p;
    int sl(0);
    F((int)e.length())if(e[i]!=' '&&e[i]!=','){
        p+=' ';
        if(UN(e[i]))PS(e[i]);
        else if(iso(e[i])){
            while(sl&&TP!='('&&hhp(TP,e[i]))
                p+=' ',p+=TP,PP;
            PS(e[i]);
        }else if(mrk(e[i])){
            p+=e[i];
            while(i+1<(int)e.size()&&mrk(e[i+1]))
                p+=e[++i];
        }else if(e[i] == '(')PS(e[i]);
        else if(e[i] == ')'){
            while(sl&&TP!='(')
                p+=TP,PP;
            PP;
        }
    }
    while(sl)p+=' ',p+=TP,PP;
    return p;
}
\end{lstlisting}
\subsection{Prvočísla - generování}
Funkce vygeneruje \textsl{L} prvočísel do pole \textsl{P} (pro 10000 existuje 1229 prvočísel).
\begin{lstlisting}[language=C++]
#define MX (1<<20)
int P[MX],L,cn[MX]={1,1};
void gen(void){
    for(int i(2);i<MX;++i)
        if(!cn[i]){
            P[L++]=i;
            for(int j(i<<1);j<MX;j+=i)
                cn[j]=1;
        }
}
\end{lstlisting}
Funkce vygeneruje \textsl{L} prvočísel do pole \textsl{P}.
\\Jedná se o bitově optimalizované Erathoserovo Sýto - je třeba méně paměti.
\\Pokud se chceme dotazovat, zda je něco prvočíslo, použijeme makro $IS(A)$. Dále je nutno odkomentovat cyklus - jinak by makro vracelo true i pro sudá čísla (pokud chceme jen využívat pole \textsf{P}, tak odkomentovávat nemusíme).
\begin{lstlisting}[language=C++]
#define MX (1<<27)
#define IS(A) ((cn[A>>6]>>(A&63))&1)
#define ST(A) (cn[A>>6]|=1ULL<<((A&63)))
ll P[MX>>1]={2},L(1),cn[1+(MX>>6)];
void gen(){
    ST(0),ST(1);
    int Q(1+sqrt(MX));
    for(ll i(4);i<MX;i+=2)ST(i);
    for(int k(3);k<=Q;k+=2)if(!IS(k))
        for(ll h(k<<1),j(k*k);j<MX;j+=h)ST(j);
    for(int i(3);i<MX;i+=2)if(!IS(i))P[L++]=i;
}
\end{lstlisting}
Toto by mělo být lineární sýto, ale je nutno ověřit (moc se mi to nezdá :P). Fakt, jestli je číslo "prime" se ověří tak že je samo v \textsf{D}, kde \textsf{D} je nějaký jeho dělitel.
\begin{lstlisting}[language=C++]
#define MX (1<<17)
int P[MX],L,D[MX]={0,1};
void gen(){
    FT(2,MX){
        if(!D[k])D[k]=k,P[L++]=k;
        FF(L&&P[j]<=D[k]&&k*P[j]<MX)D[k*P[j]]=P[j];
    }
}
\end{lstlisting}
Atkinsovo Sýto.
\begin{lstlisting}[language=C++]
bool cn[MX]={0,0,1,1};
int P[1<<23],L;
void atk(int n){
    int Q=ceil(sqrt(n)),h;
    FT(1,Q+1)FOR(y,1,Q+1){
        h=((k*k)<<2)+y*y;
        if(h<=n&&(h%12==1||h%12==5))
            cn[h]=1;
        h=(3*k*k+y*y);
        if(h<=n&&(h%12== 7))
            cn[h]=1;
        if(k>y){
            h=(3*k*k-y*y);
            if(h<=n&&(h%12==11))
                cn[h]=1;
        }
    }
    for(int i(5);i<=Q;i+=2)if(cn[i])
        for(int j=(i*i),h(i<<1);j<=n;j+=h)
            cn[j]=0;
    for(int i(2);i<=n;++i)
        if(cn[i])P[L++]=i;
}
\end{lstlisting}
\subsection{Prvočísla - testování}
Rabin-Miller pro inty (s vybíráním počtu iterací)
\begin{lstlisting}[language=C++]
ll mm(ll a,ll b,ll M){
    return (a*b)%M;
}
ll pw(ll n,ll k,ll M){
    ll r=1;
    while(k){
        if(k&1)r= mm(r,n,M);
        n=mm(n,n,M),k>>=1;
    }
    return r%M;
}
bool isP(ll n,int Q=20){
    if(n<2)return 0;
    if(!(n&1))return n==2;
    ll s=n-1;
    while(!(s&1))s>>=1;
    F(Q){
        ll z(rand()%(n-1)+1),t(s),r(pw(z,t,n));
        if(r==1||!~r==-1)continue;
        while(t!=n-1&&r!=n-1)
            r=mm(r,r,n),t<<=1;
        if(r!=n-1)return 0;
    }
    return 1;
}
\end{lstlisting}
Rabin-Miller pro inty (rychlá verze)
\begin{lstlisting}[language=C++]
ll pw(int a, int n, int M){
    ll P(a),r=1;
    while(n){
        if(n&1)r=(r*P)%M;
        P=(P*P)%M,n>>=1;
    }
    return r;
}
bool wt(int a, int n){
    int t(1),u(n>>1);
    ll p,c;
    while(!(u&1))
        u>>=1,++t;
    p=pw(a,u,n);
    F(t){
        c=(p*p)%n;
        if((c==1)&&(p!=1)&&(p!=n-1))return 1;
        p=c;
    }
    return c!=1;
}

bool isP(int n){
    if(((!(n&1))&&n!=2)||(n<2)||(!(n%3)&&n!=3))return 0;
    if(n<1373653){
        for(int k=1;36*k*k-12*k<n;++k)
            if(!(n%(6*k+1))||!(n%(6*k-1)))return 0;
        return 1;
    }
    if(n<9080191)return !wt(31,n)&&!wt(73,n);
    return !wt(2,n)&&!wt(7,n)&&!wt(61,n);
}
\end{lstlisting}
Rabin-Miller - předurčení svědci (měli by fungovat do $2^{64}$) (funguje i pro longy (pro inty pomalé))
\begin{lstlisting}[language=C++]
ll R[]={2,3,5,7,11,13,17,19,23,29,31,37};
ll mm(ll a,ll b,ll M){
    ll v(0),w(a%M);
    while(b)v=b&1?(v+w)%M:v,w=(w<<1)%M,b>>=1;
    return v%M;
}
ll pw(ll n,ll k,ll M){
    ll r=1;
    while(k){
        if(k&1)r= mm(r,n,M);
        n=mm(n,n,M),k>>=1;
    }
    return r%M;
}
bool isP(ll n){
    if(n<2)return 0;
    if(!(n&1))return n==2;
    ll s=n-1;
    while(!(s&1))s>>=1;
    if(n<40){FT(3,n)if(!(n%k))return 0;return 1;}
    F(12){
        ll z(R[i]),t(s),r(pw(z,t,n));
        if(r==1||!~r==-1)continue;
        while(t!=n-1&&r!=n-1)
            r=mm(r,r,n),t<<=1;
        if(r!=n-1)return 0;
    }
    return 1;
}
\end{lstlisting}
Fermatův test (ještě trochu promakat)
\begin{lstlisting}[language=C++]
ll mm(ll a,ll b,ll M){
    if(a<INF&&b<INF)return (a*b)%M;
    ll v(0),w(a%M);
    while(b)v=b&1?(v+w)%M:v,w=(w<<1)%M,b>>=1;
    return v%M;
}
ll pw(ll n,ll k,ll M){
    ll r=1;
    while(k){
        if(k&1)r=mm(r,n,M);
        n=mm(n,n,M),k>>=1;
    }
    return r%M;
}
ll rnd(int b){ll r(0);F(b)r<<=1,r|=rand()&1;return r;}
bool isP(ll n){
    ll h(ceil(log2(n)-ZERO)),a;
    F(10){
        a=rnd(h)%(n-1)+1;
        if(pw(a,n-1,n)-1)return 0;
    }
    return 1;
}
\end{lstlisting}
\subsection{Převod mezi bázemi}
Funkce přijme parametr \textsf{n} (číslo v dekadické soustavě), \textsf{b} (báze, do které se má číslo převést) a \textsf{c} (pole ve kterém bude výsledek uložen).
\\Návratovou hodnotou je délka čísla (tedy řetězce, ve kterém je uloženo).
\begin{lstlisting}[language=C++]
int toBas(int n,int b,char *c){
    if(!n)
        return 1+(c[0]=0);
    int l(0);
    while(n)
        c[l++]=n%b,n/=b;
    return l;
}
\end{lstlisting}
Převede z nějaké báze \textbf{b} číslo \textbf{c} o \textbf{l} číslicích do soustavy dekadické. 
\begin{lstlisting}[language=C++]
typedef long long ll;
ll toDec(int b,int l,int *c){
    ll D(0),k(1);
    for(int i(0);i<l;++i)
        D+=k*c[i],k*=b;
    return D;
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
strtoull(r.c_str(),0,b));
\end{lstlisting}
Převod z libovolné báze do jiné libovolné báze (2 až 62).
\\Parametry jsou vždy dvojice číslo a báze.
\\Číslování:
\begin{itemize}
\item \textbf{0-9}: 0-9
\item \textbf{10-35}: A-Z
\item \textbf{36-61}: a-z
\end{itemize}
\begin{lstlisting}[language=C++]
#define NM(C) (islower(C)?(C)+36-'a':isupper(C)?(C)+10-'A':(C)-'0')
#define CR(N) (N>35?(N)-36+'a':N>9?(N)-10+'A':(N)+'0')
void b2b(char *r,int a,char *s,int b){
    static int A[1024],t[1024];
    int i,k(i=strlen(r)),l;
    while(i--)t[k-1-i]=NM(r[i]);
    for(l=0;k;){
        for(int i(k);i-->1;)
            t[i-1]+=t[i]%b*a,t[i]/=b;
        A[l++]=t[0]%b,t[0]/=b;
        while(k&&!t[k-1]&&--k);
    }s[l]=0;
    F(l)s[l-1-i]=CR(A[i]);
}
\end{lstlisting}
\subsection{Rekurentní rovnice}
Vyřešení rekurentní rovnice, ve tvaru $T(n)=a*T(n-1)+b*T(n-2)$, $T(0)=Z$ a $T(1)=O$ (O je písmeno).
\\Funkce $pw$ mocní matice.
\\Složitost $O(log(N))$
\\PS: Jednoduše lze přidat modulo
\begin{lstlisting}[language=C++]
#define MM (2)
ll A[MM][MM],R[MM][MM];
ll bar(ll a,ll b,ll Z,ll O,ll n){
    if(n<2)return n?O:Z;
    A[0][0]=a;
    A[0][1]=b;
    A[1][0]=1;
    A[1][1]=0;
    pw(A,R,2,n-1);
    return R[0][0]*O+R[0][1]*Z;
}
\end{lstlisting}
\subsection{Soustava N rovnic o M neznámých}
Vyřešení \textbf{N} rovnic (uložených v \textsf{a}) o \textbf{M} neznámých. Na pozici $i$ je $i$-tá promenná a na pozici \textbf{M} je výsledek rovnice.
\\Řešení prbíhá za pomoci zlomků (tedy čísla jsou uchovávána celá).
\\Výsledek viz konec funkce
\\Složitost $(O(N^3))$
\begin{lstlisting}[language=C++]
#define MX (64)
fr a[MX][MX],r[MX],q;
int N,M;
void le(){
    int I(0),J(0),X,C(0),z;
    while(I<N&&J<M){
        X=I;
        FT(I+1,N)if(fr::abs(a[X][J])<fr::abs(a[k][J]))X=k;
        if(!a[X][J].zr()){
            if(I!=X)F(M+1)swap(a[I][i],a[X][i]);
            F(N)if(i!=I){
                q=a[i][J]/a[I][J];
                FT(J+1,M+1)a[i][k]-=a[I][k]*q;
                a[i][J]={0,1};
            }
            ++I;
        }
        ++J;
    }
    F(N){
        z=1;
        FF(M&&z)if(!a[i][j].zr())z=0;
        if(z&&!a[i][M].zr())C=-1,i=INF;
    }
    if(~C){
        I=J=0;
        while(I<N&&J<M){
            if(!a[I][J].zr())r[J]=a[I][M]/a[I][J],++C,++I;
            ++J;
        }
    }
    if(!~C)printf("No Solution.\n");//NO SOLUTION
    else if(C<M)printf("Infinitely many solutions containing %d arbitrary constants.\n",M-C);//Any number of solutions (M-C are set)
    else F(M)printf("x[%d] = ",i+1),r[i].prt(),putchar_unlocked(10);//solution in "r"
}
\end{lstlisting}
\subsection{Suma dělitelů čísel na intervalu}
Suma dělitelů všech čísel na intervalu od 1 do \textsf{P}.
\\Složitost $O(sqrt(n))$
\\Pravděpodobně hází špatné výsledky pro čísla $\leq 3$
\begin{lstlisting}[language=C++]
#define gs(B,E) ((E+B)*(E-(B)+1)/2)
ll som(ll P){
    ll A(sqrt(P)),S(0),L(P),H;
    FT(1,P&&((H=P/k)>=A))S+=H*k;
    FT(1,A)H=P/(k+1),S+=gs(H+1,L)*k,L=H;
    return S;
}
\end{lstlisting}
Počet dělitelů čísel na intervalu
\begin{lstlisting}[language=C++]
ll som(ll P){
    ll A(sqrt(P)),S(0),L(P),H;
    FT(1,P&&((H=P/k)>A))S+=H;
    FT(1,A+1)H=P/(k+1),S+=k*(L-H),L=H;
    return S;
}
\end{lstlisting}
\subsection{Vyhodnocení polynomu}
Inicializace proběhne pomocí ini (do kterého se dá polynom a jeho velikost)
\\V $T$ pak budou hodnoty polynomu v bodě (podle indexu)
\\Vyhodnocení probíhá na modulu $MOD$. To musí být ve tvaru $KK*2^{LG}$
\begin{lstlisting}[language=C++]
#define LG (18)
#define KK 3
#define MOD ((KK<<LG)+1)
#define MX MOD
int T[MX],P,a[LG+1][MX];
ll pw(ll n,ll k){
    if(!k)return 1;
    if(k&1)return n*pw(n,k-1)%MOD;
    ll t=pw(n,k/2);return t*t%MOD;
}
void eva(int S,ll X,int G){
    if(!G){T[S]=**a;return;}
    ll g=G-1,f=pw(S,1<<g);
    F(1<<g)a[g][i]=(a[G][i]+a[G][i+(1<<g)]*f)%MOD;
    eva(S,X*X%MOD,G-1),S=S*X%MOD,f=MOD-f;
    F(1<<g)a[g][i]=(a[G][i]+a[G][i+(1<<g)]*f)%MOD;
    eva(S,X*X%MOD,G-1);
}
void ini(int N,int*A){
    F(N)a[18][i]=A[i];
    *T=*a[18],P=1;
    F(KK)eva(P,1000,LG),P*=10;
}
\end{lstlisting}
\subsection{Vyhodnocení výrazu}
Vyhodnocení s operacemi sčítání a odčítání (není otestováno!)
\\Vstupem jsou \textsf{b} (začátek - nastavit na nulu), \textsf{e} (koncový char - zřejmě 0) a \textsf{x} (zápornost formule - nastavit na nulu).
\begin{lstlisting}[language=C++]
typedef long long ll;
ll gn(int &b,int x){
    ll K(0);
    while(isdigit(s[b]))K*=10,K+=s[b++]-'0';
    return x?-K:K;
}
ll eval(int &b,char e,int x){
    ll h,K(0);
    if(s[b]=='(')return eval(++b,')',x);
    if(isdigit(s[b]))K=gn(b,x);
    while(s[b]!=e){
        h=s[b++]=='-';
        if(s[b]=='(')K+=eval(b,')',(x+h)&1);
        else K+=gn(b,(x+h)&1);
    }++b;
    return K;
}
\end{lstlisting}
Vyhodnocení výrazu bez závorek (pozor na dělení - je celočíselné!)
\begin{lstlisting}[language=C++]
#define MN(A,B) ((A-B))
#define PS(A,B) (A+B)
#define DV(A,B) (A/B)
#define MP(A,B) (A*B)
ll gin(const char *s,ll &b){
    ll S(0),m(0);
    while(s[b]=='-')++b,m^=1;
    while(isdigit(s[b]))S*=10,S+=s[b++]-'0';
    return m?-S:S;
}
ll now(const char *s,ll &b,ll a){
    char c;
    ll A;
    while(s[b]=='*'||s[b]=='/'){
        c=s[b++];
        A=gin(s,b);
        a=c=='*'?MP(a,A):DV(a,A);
    }
    return a;
}
#define OP(A,B,C) (C=='-'?MN(A,B):PS(A,B))
ll evl(const char *s){
    ll b(0),a(gin(s,b)),l;
    if(!s[b])return a;
    if(s[b]=='*'||s[b]=='/')a=now(s,b,a);
    while(s[b]){
        char d(s[b++]);
        l=gin(s,b);
        if(s[b]=='*'||s[b]=='/')l=now(s,b,l);
        a=OP(a,l,d);
    }
    return a;
}
\end{lstlisting}
\subsection{XOR}
Nalezení počtu dvojic \textit{L}/\textit{R} na zadaném intervalu, pro které platí, že XOR je $a_l => a_r$ je roven \textsf{K}. Dvojice jsou uloženy v \textsf{q} ($q.aa.aa$ je levá hranice (inclusive) a $q.aa.bb$ je hranice pravá (exclusive)). 
\\\textsf{M} je počet query
\\\textsf{R} bude uložen výsledek (počet intervalů).
\\$MX$ je počet prvků zadaného pole \textsf{A}.
\\$MM$ je maximální hodnota prvku.
\\$C$ je číslo, blížící se $\sqrt{N}$
\\Složitost $O((N+M)sqrt(N))$ 
\begin{lstlisting}[language=C++]
#define MX (1<<17)
#define MM (1<<20)
#define C (666)
typedef pair<ii,int> pp;
int N,K,M,A[MX],b[MX];
pp q[MX];
ll R[MX],t[MM];
bool cmp(pp a,pp b){
    if(a.aa.aa/C!=b.aa.aa/C)return a.aa.aa/C<b.aa.aa/C;
    return a.aa.bb<b.aa.bb;
}
void pre(){
    ll l(0),r(-1),c(0);
    *b=0,CL(t,0);
    F(N)b[i+1]=b[i]^A[i];
    F(M)q[i].bb=i;
    sort(q,q+M,cmp);
    F(M){
        while(r<q[i].aa.bb)
            c+=t[b[++r]^K],++t[b[r]];
        while(l>q[i].aa.aa)
            c+=t[b[--l]^K],t[b[l]]++;
        while(r>q[i].aa.bb)
            --t[b[r]],c-=t[b[r--]^K];
        while(l<q[i].aa.aa)
            --t[b[l]],c-=t[b[l++]^K];
        R[q[i].bb]=c;    
    }
}
\end{lstlisting}
Počet spojitých podposloupností, jejiž xor je vetší či roven \textsf{X}.
\\Posloupnost \textsf{a} má \textsf{N} prvků.
\begin{lstlisting}[language=C++]
#define MX (1<<20)
int T[MX],v[MX],w[MX];
ll mxr(int N,int X,int*a){
    F(N)T[i+1]=T[i]^a[i];
    sort(T,T+N+1);
    ll S=(N+1ll)*(N+1),z,C,p,I;
    while(X){
        I=0,p=-1,z=1;while(!(X&z))z<<=1;X-=z;
        F(N+1)v[i]=T[i]/z,w[i]=v[i]^(X/z);
        sort(w,w+N+1);
        F(N+1)  if(v[i]^p){
                    p=v[i],C=0;
                    for(;I<=N&&w[I]<=v[i];++I)C+=w[I]==v[i];
                    S-=C;
                }else S-=C;
    }
    return S>>1;
}
\end{lstlisting}
XORová trie
\\Funkce \textit{add} přidá číslo \textsf{I} do trie. 
\\Čísla mají \textsf{p} bitů.
\\u je počáteční node trie - pokud chce být více trií, jsou počáteční nodes 0 - M
\\Funkce bm nalezne nejvetší číslo po xoru s čísle \textsf{I}
\\Je nutno napsat funkci clear: M=Number of nodes, Nastavení \textsf{V},\textsf{W},\textsf{H} (levý syn, pravý syn a \textbf{zbytek}) na 0 (ideálně to dělat v ad, ale to by se muselo napsat! :)).
\begin{lstlisting}[language=C++]
#define TS (1<<24)
int V[TS],W[TS],H[TS],M;
void ad(int I,int p,int u=0){
    if(!p)return;
    if(!V[u]&&!W[u]&&!H[u]){
        H[u]=I+1;
        return;
    }
        GT:
    if(I&1){
        if(!V[u])V[u]=M++;
        ad(I>>1,p-1,V[u]);
    }else{
        if(!W[u])W[u]=M++;
        ad(I>>1,p-1,W[u]);
    }
    if(H[u]){I=H[u]-1;H[u]=0;goto GT;}
}
int bm(int I,int p,int u=0){
    if(!p)return 0;
    if(H[u])return (H[u]-1)^I;
    if(I&1){
        if(W[u])return bm(I>>1,p-1,W[u])<<1|1;
                return bm(I>>1,p-1,V[u])<<1;
    }
    if(V[u])return bm(I>>1,p-1,V[u])<<1|1;
            return bm(I>>1,p-1,W[u])<<1;
}
int rv(int a){ //reverse bits
    int S(0);
    F(20)S<<=1,S|=a&1,a>>=1;
    return S;
}
\end{lstlisting}
Podobné, jako nahoře.
\\Zde je napsaný i clear
\\Změnou oproti minule je, že tyto funkce operují navíc s indexem (který se hledá) [nenalezne se tedy nejvyšší XOR, nýbrž index prvku, který má nejvyšší XOR]. Pokud je vícero řešení, vrátí se index první. (viz pole \textsf{J}) \\Dále zde není zkracovadlo (H).
\begin{lstlisting}[language=C++]
#define TS (1<<23)
int V[TS],W[TS],J[TS],M;
void ad(ll I,int p,int X,int u=0){
    if(!p&&!J[u])J[u]=X;
    if(!p)return;
    if(I&1){
        if(!V[u])V[M]=W[M]=J[M]=0,V[u]=M++;
        ad(I>>1,p-1,X,V[u]);
    }else{
        if(!W[u])V[M]=W[M]=J[M]=0,W[u]=M++;
        ad(I>>1,p-1,X,W[u]);
    }
}
int bm(ll I,int p,int u=0){
    if(!p)return J[u];
    if(I&1){
        if(W[u])return bm(I>>1,p-1,W[u]);
                return bm(I>>1,p-1,V[u]);
    }
    if(V[u])return bm(I>>1,p-1,V[u]);
            return bm(I>>1,p-1,W[u]);
}
ll rv(ll a){
    ll S(0);
    F(32)S<<=1,S|=a&1,a>>=1;
    return S;
}
#define CLR (M=1,*V=*W=*J=0)
\end{lstlisting}
Xorová trie jako MULTISET (podporuje více čísel a "light" delete)
\\Dodělat $CLR$
\\$ad$ přidá prvek
\\$del$ odebere prvek (funguje pouze pokud tam prvek je, jinak by bylo nutno ošetřit)
\\$bst$ najde nejlepší XOR match
\\$rv$ obrátí bity čísla
\\V \textsf{S} je v konečných nodech uložen počet prvků toho typu.
\begin{lstlisting}[language=C++]
#define BT (32)
#define MX (1<<24)
struct XT{
    int G[2][MX],S[MX],P;
    int al(){return G[0][P]=G[1][P]=-1,P++;}
    void ad(int u,int a,int p){
        if(!p){++S[u];return;}
        if(!~G[a&1][u])G[a&1][u]=al();
        ad(G[a&1][u],a>>1,p-1);
    }
    bool del(int u,int a,int p){
        if(!p)return !--S[u];
        if(del(G[a&1][u],a>>1,p-1))
            return G[a&1][u]=-1,!~G[!(a&1)][u];
        return 0;
    }
    int bst(int u,int a,int p){
        if(!p||(!G[0][u]&&!G[1][u]))return a;
        if(~G[!(a&1)][u])return bst(G[!(a&1)][u],a>>1,p-1)<<1|1;
        return bst(G[a&1][u],a>>1,p-1)<<1;
    }
    void CLR(){al();}
}T;
int rv(int a){int b=0;F(BT)b<<=1,b|=a&1,a>>=1;return b;}
\end{lstlisting}
Xorová trie, která umožňuje zjištění, počtu "nějakého intu" ve vzdálenosti nejméně \textsf{a} a nejvýše \textsf{b} před aktuálním indexem.
\\Složitost je $O(N^2)$ ale musí se to brát dost s nadhledem [na $3*10^5$ to prošlo]. Pro zlepšení je třeba nahradit vektor něčím jiným(např Fenwickem - což ale paradoxně neprošlo)
\begin{lstlisting}[language=C++]
#define MX (1<<24)
struct Xtr{
    vi H[MX];
    int W[MX][2];
    int S,n,a,b;
    int nw(){return *W[S]=W[S][1]=0,H[S].clear(),S++;}
    void clr(int N,int A,int B){S=0,nw(),n=N,a=A,b=B;}
    void add(ll x,int I){
        int u=0,l;
        F(n){
            l=x>>i&1;
            if(!W[u][l])W[u][l]=nw();
            u=W[u][l];
        }
        H[u].PB(I);
    }
    int gt(ll x,int I){
        int u=0,l,A=0;
        F(n){
            l=(x>>i&1)^1;
            if(!W[u][l])return 0;
            u=W[u][l];
        }
//return upper_bound(H[u].begin(),H[u].end(),I-a)-lower_bound(H[u].begin(),H[u].end(),I-b);
//If indices added in right order
        for(auto&h:H[u])A+=I-h>=a&&I-h<=b;
        return A;
    }
}T;
\end{lstlisting}
\subsection{Základní číselné a bitové operace}
\begin{center}
Overflow Check
\end{center}
\begin{lstlisting}[language=C++]
int hp(ll a){int p(0);while(a)a>>=1,++p;return p;}
bool sf(ll a,ll b){return (hp(a)+hp(b)<=64);}//ui
\end{lstlisting}
\begin{center}
ABS
\end{center}
\begin{lstlisting}[language=C++]
#define abs(N) (((N>>31)^N)-(N>>31))
\end{lstlisting}
\begin{center}
XOR
\end{center}
\begin{lstlisting}[language=C++]
~(~a&~b)&~(a&b)
\end{lstlisting}
\begin{center}
Maximum x a y
\end{center}
\begin{lstlisting}[language=C++]
x^((x^y)&-(x<y))
\end{lstlisting}
\begin{center}
Minimum x a y
\end{center}
\begin{lstlisting}[language=C++]
y^((x^y)&-(x<y))
\end{lstlisting}
\begin{center}
Mocnina dvojky? (nefunguje pro nulu)
\end{center}
\begin{lstlisting}[language=C++]
(v&(v-1))==0
\end{lstlisting}
\begin{center}
Odstranění 1 bitů v \textsf{k} z \textsf{f}.
\end{center}
\begin{lstlisting}[language=C++]
f-(f&k)
\end{lstlisting}
\begin{center}
Opačná znaménka? (true pokud ano)
\end{center}
\begin{lstlisting}[language=C++]
((x^y)<0)
\end{lstlisting}
\begin{center}
Počet 1 bitů v čísle
\end{center}
\begin{lstlisting}[language=C++]
int bts(int n){
    int ct(0);
    while(n)
        n&=n-1,++ct;
    return ct;
}
\end{lstlisting}
\begin{center}
Prohození dvou bitů
\end{center}
\begin{lstlisting}[language=C++]
unsigned int i, j; // positions of bit sequences to swap
unsigned int n;    // number of consecutive bits in each sequence
unsigned int b;    // bits to swap reside in b
unsigned int r;    // bit-swapped result goes here
unsigned int x = ((b >> i) ^ (b >> j)) & ((1U << n) - 1); // XOR temporary
r = b ^ ((x << i) | (x << j));
\end{lstlisting}
\begin{center}
Prohození dvou prvků
\end{center}
\begin{lstlisting}[language=C++]
a^=b,b^=a,a^=b;
\end{lstlisting}
\begin{center}
Výměna 0 za 1 a naopak
\end{center}
\begin{lstlisting}[language=C++]
++c&=1;
\end{lstlisting}
\begin{lstlisting}[language=C++]
c^=1;
\end{lstlisting}
\begin{center}
Vypnutí k-tého bitu (1 => 0, 0 => 0)
\end{center}
\begin{lstlisting}[language=C++]
(n & ~(1 << (k)))
\end{lstlisting}
\begin{center}
Zabudované C++ operace
\end{center}
Všechny funkce přijímají unsigned long/long longy se suffixem l/ll;
\begin{lstlisting}[language=C++]
int __builtin_popcount (unsigned int x); //Returns the number of 1-bits in x.
uint8_t reverse_bits(uint8_t b) { return (b * 0x0202020202ULL & 0x010884422010ULL) % 1023; }
int __builtin_clz (unsigned int x); //Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined. 
// Usage: nearest higher power of 2: 1ULL << (sizeof(x)*8-__builtin_clz(x))
int __builtin_ffs (int x)
//Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero.
int __builtin_ctz (unsigned int x)
//Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.
int __builtin_clrsb (int x)
//Returns the number of leading redundant sign bits in x, i.e. the number of bits following the most significant bit that are identical to it. There are no special cases for 0 or other values.
\end{lstlisting}
\subsection{Zlomek}
Číslo uchovávané jako zlomek (tedy jako podíl dvou celých čísel).
\\U comparatoru se da přidat "double", na zvýšení velikosti porovnávaných zlomků.
\begin{lstlisting}[language=C++]
struct fr{
    ll u,l;
    fr(ll U=1,ll L=1):u(U),l(L){nr();}
    void nr(){nr(u,l);}
    void nr(ll&a,ll&b){
        ll g(__gcd(a,b));
        a/=g,b/=g;
        if(!a)b=1;
        if(b<0)a=-a,b=-b;
    }
    fr operator+=(fr r){ll g=__gcd(l,r.l);return u=r.l/g*u+l/g*r.u,l*=r.l/g,nr(),*this;}
    fr operator+(fr r){return r+=*this;}
    fr operator-=(fr r){return r.u=-r.u,*this+=r;}
    fr operator-(fr r){fr t(*this);return t-=r;}
    fr operator*=(fr r){return u*=r.u,l*=r.l,nr(),*this;}
    fr operator*(fr r){return r*=*this;}
    fr operator/=(fr r){return swap(r.u,r.l),*this*=r;}
    fr operator/(fr r){fr t(*this);return t/=r;}
    void prt(){
        nr();
        if(l<0)l=-l,u=-u;
        if(!u)putchar(48);
        else if(l==1)printf("%lld",u);
        else printf("%lld/%lld",u,l);
    }
    bool operator<(const fr&r)const{return u*r.l<r.u*l;}
    bool operator==(const fr&r)const{return u*r.l==r.u*l;}
    static fr abs(fr r){return r.u=llabs(r.u),r.l=llabs(r.l),r;}
    bool zr(){return !u;}
};
\end{lstlisting}
\newpage\section{Geometrie}
\subsection{Bod v polygonu [T/F]}
Polygon je uložen v polích \textsf{x} a \textsf{y} (bod na indexu 0 je též na indexu \textsf{n}).
\\V argumentech \textsf{X} a \textsf{Y} jsou koordináty bodu, pro který zjišťujeme, zda-li je uvnitř polygonu.
\\Princip fungování algoritmu je, že se ptáme jestli:
\begin{itemize}
\item Bod leží na nějaké z krajních hran?
\item Počet průsečíků s polopřímkou od bodu směrem nahoru je lichý?
\end{itemize}  
Složitost algoritmu je $O(n)$ vzhledem k počtu hran polygonu.
\\Pokud bude polygon opravdu polygonem (tedy alespoň 3 vrcholy), lze vynechat první podmínku ve funkci \textsf{isIn}
\begin{figure}[H]
  \centering
  \includegraphics[width=3in]{pic/polygon}
  \caption[Bod v polygonu.]{Crossing test.}
\end{figure}
\begin{lstlisting}[language=C++]
#define MX (2048)
int nn,x[MX],y[MX];
int side(int x1,int y1,int x2,int y2,int x3,int y3){
    int tm((y2-y1)*(x3-x2)-(x2-x1)*(y3-y2));
    return tm?tm>0?1:-1:0;
}
double llY(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){
    return ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
}
bool isOn(int i,int X,int Y){
    return X==x[i]&&x[i]==x[i+1]&&Y>=min(y[i],y[i+1])&&Y<=max(y[i],y[i+1]);
}
bool isIn(int X,int Y){
    if(nn<3)
        return nn==1?X==x[0]&&Y==y[0]:x[0]==x[1]?isOn(0,X,Y):
            (min(x[0],x[1])<=X&&max(x[0],x[1])>=X&&!side(x[0],y[0],x[1],y[1],X,Y));
    int S(0);
    for(int i(0);i<nn;++i)
        if(x[i]==x[i+1]&&x[i]==X)return Y<=max(y[i],y[i+1])&&Y>=min(y[i],y[i+1]);
        else if(min(x[i],x[i+1])<=X&&max(x[i],x[i+1])>=X&&x[i]!=x[i+1]){
            if(!side(x[i],y[i],x[i+1],y[i+1],X,Y))
                return 1;
            S+=Y<llY(x[i],y[i],x[i+1],y[i+1],X,0,X,1)&&(X!=x[i]||
      		(x[i+1]>x[i]&&(i?x[i-1]>x[i]:x[nn-1]>x[i]))||
      		(x[i+1]<x[i]&&(i?x[i-1]<x[i]:x[nn-1]<x[i])));
        }else if(isOn(i,X,Y))
            return 1;
    return S&1;
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
pt H[MX];
bool isIn(pt G,pt*P,int N){
    int R(0),L(0);
    F(N)H[i]=P[i]-G;
    F(N){
        if(EQ(H[i].x,0)&&EQ(H[i].y,0))return 1;
        int j((i+N-1)%N),r((H[i].y>0)^(H[j].y>0)),l((H[i].y<0)^(H[j].y<0));
        if(r|l){
            double x((H[i].x*H[j].y-H[j].x*H[i].y)*1./(H[j].y-H[i].y));
            R+=r&&x>0,L+=l&&x<0;
        }
    }
    return R&1||((R&1)^(L&1));
}
\end{lstlisting}
Pokud se jedná o konvexní polygon
\begin{lstlisting}[language=C++]
#define SS(A) (EQ(A,0)?0:A<0?-1:1)
bool in(pt*p,int N,pt&h){
    p[N]=*p;
    F(N)if(EQ(p[i].dst(p[i+1]),p[i+1].dst(h)+p[i].dst(h)))return 1;
    F(N-1)if(SS(XX(p[i],p[i+1],h))^SS(XX(p[i+1],p[i+2],h)))return 0;
    return 1;
}
\end{lstlisting}
Bod v trojúhelníku
\begin{lstlisting}[language=C++]
double AR(pt a,pt b,pt c){return fabs(a.x*b.y-a.y*b.x+b.x*c.y-b.y*c.x+c.x*a.y-c.y*a.x)/2;}
int it(pt P,pt A,pt B,pt C){return AR(A,B,P)+AR(A,P,C)+AR(P,B,C)<=AR(A,B,C)+ZERO;}
\end{lstlisting}
\subsection{Body na stranách obdélníka}
Nalezne nejvyšší možný počet bodů, které lze umístit na strany obdélníka.
\\Složitost $O(N^3)$
\begin{lstlisting}[language=C++]
struct pt{
    int x,y;
    bool operator<(const pt&r)const{return x<r.x;}
}p[MX];
int bps(int N){
    static int m,y[MX],I,X,K,o[MX],O[MX],l[MX],M;
    F(N)y[i]=p[i].y;
    sort(p,p+N);
    sort(y,y+N);
    int r(0);
    if((m=unique(y,y+N)-y)<=2)return N;
    FF(m)FT(j+1,m){
        I=y[j],X=y[k],K=0;
        F(N){
            if(!i||p[i].x!=p[i-1] .x)
                ++K,o[K]=O[K]=0,l[K]=K==0?0:l[K-1]+O[K-1]-o[K-1];
            if(p[i].y>I&&p[i].y<X)
                ++o[K];
            if(p[i].y>=I&&p[i].y<=X)
                ++O[K];
        }
        if(K<=2)return N;
        M=0;
        F(K+1)if(i)r=max(r,l[i]+O[i]+M),M=max(M,o[i]-l[i]);
    }
    return r;
}
\end{lstlisting}
\subsection{Body na přímce}
Nalezne největší počet bodů, které leží na přímce (libovolné).
\\Body modou být i $int$.
\\Složitost $O(N^2log(N))$
\begin{lstlisting}[language=C++]
#define MX (1024)
struct pt{
    double x,y;
}p[MX];
int gx(pt *p,int n){
    static double a[MX];
    int K,s(0);
    F(n){
        K=0;
        FT(i+1,n)if(p[i].x==p[k].x)a[K++]=INF;
                 else a[K++]=(p[i].y-p[k].y)*1.0/(p[i].x-p[k].x);
        sort(a,a+K);
        FF(K){
            int c=1;
            while(j+1<K&&fabs(a[j]-a[j+1])<ZERO)j++,c++;
            s=max(s,c);
        }
    }
    return ++s;
}
\end{lstlisting}
Počet celočíselných bodů na úsečce
\begin{lstlisting}[language=C++]
int iol(pt a,pt b){
    pt P(a-b);
    P.x=abs(P.x),P.y=abs(P.y);
    if(!P.x||!P.y)return max(P.x,P.y);
    return __gcd(P.x,P.y);
}
\end{lstlisting}
\subsection{Čtverec - dodělání}
Z diagonály $X/Y_{1,2}$ jsou dopočítány zbylé dva body.
\\Pozor, počítá li-se na celých číslech, nemusí vyjít výsledek nutně také na celých číslech.
\begin{lstlisting}[language=C++]
void tst(double x1,double y1,double x2,double y2,double &x3,double &y3,double &x4,double &y4){
    double xc=(x1+x2)/2.0,yc=(y1+y2)/2.0,xd=(x1-x2)/2.0,yd=(y1-y2)/2.0; 
    x3=xc-yd,y3=yc+xd,x4=xc+yd,y4=yc-xd;
}
\end{lstlisting}
\subsection{Délka výseku kruhu}
Parametry jsou úhel ve stupních a poloměr.
\\Pozor, pokud chceme vzdálenost bodů na kružnici, pak místo první proměnné dosadit komentář (úhel pak nemůže přesáhnout $180^\circ$).
\begin{lstlisting}[language=C++]
double doc(double A,double r){
    return A*M_PI*r/180;
}
//(A>180?360-A:A)
\end{lstlisting}
\subsection{Diagonály polygonu}
Maximální počet průsečíků diagonál \textit{ngonu} se 2 diagonálami vedoucími z každého uzlu.
\begin{lstlisting}[language=C++]
for(int i(4),j(4),k(1);i<MX;++i)
    if(i&1)D[i]=D[i-1]+j,j+=3;
    else D[i]=D[i-1]+k++;
\end{lstlisting}

\subsection{Existence bodu ze kterého je vidět polygon}
Funkce vrátí \textit{true}, pokud existuje v polygonu takový bod, ze kterého je vidět do všech míst polygonu.
\\V poli \textsf{p} jsou uloženy postupně souřadnice bodů v polygonu a v \textsf{n} je pak počet bodů.
\begin{lstlisting}[language=C++]
#define ZERO 1e-13
struct pt{
    double x,y;
}tp[64],p[64],t[64],tt;
int n,nm,tn;
#define SGN(X) ((X)<-ZERO?-1:(X)>ZERO)
void add(pt&r,pt&s,double a,double b,double c){
    double tx(fabs(a*r.x+b*r.y+c)),ty(fabs(a*s.x+b*s.y+c));
    tt.x=(r.x*ty+s.x*tx)/(tx+ty);
    tt.y=(r.y*ty+s.y*tx)/(tx+ty);
    t[++tn]=tt;
}
void slv(double a,double b,double c){
    tn=0;
    for(int i(1);i<=nm;++i)
        if(SGN(a*tp[i].x+b*tp[i].y+c)<=0)
            t[++tn]=tp[i];
        else{
            if(!~SGN(a*tp[i-1].x+b*tp[i-1].y+c))
                add(tp[i-1],tp[i],a,b,c);
            if(!~SGN(a*tp[i+1].x+b*tp[i+1].y+c))
                add(tp[i+1],tp[i],a,b,c);
        }
    for(int i(1);i<=tn;++i)
        tp[i]=t[i];
    tp[0]=tp[tn],tp[tn+1]=tp[1];
    nm=tn;
}
bool exst(void){
    int S(0);
    for(int i(0);i<n;++i)	
	S+=(-(p[i].x+p[i+1].x))*(p[i+1].y-p[i].y);
    if(S>0)
        for(int i(1),j(n-1);i<j;++i,--j)
            swap(p[i],p[j]);
    for(int i(0);i<n;++i)
        tp[i+1]=p[i];
    p[nm=n]=p[0],tp[0]=tp[n],tp[n+1]=tp[1];
    for(int i(0);i<n;++i)
        slv(p[i+1].y-p[i].y,p[i].x-p[i+1].x,p[i+1].x*p[i].y-p[i+1].y*p[i].x);
    return nm;
}
\end{lstlisting}
Pokud budeme chtít i plochu, ze které je polygon vidět, musíme přidat následující funkčnost.
\begin{lstlisting}[language=C++]
double area(pt *p,int n){
    double A(0);
    for(int i(0);i<nm;++i)
        A+=(p[i].x*p[i+1].y)-(p[i].y*p[i+1].x);
    return A/2;
}
double gAr(void){
    if(!exst()||nm<3)
        return 0;
    return area(tp,nm);
}
\end{lstlisting}
Zjistí plochu v $O(Nlog(N))$
\\Byl fail na nejakem malem Test-casu
\begin{lstlisting}[language=C++]
#define MX (1<<17)
int pn,dq[MX],E,B,J;
struct pt{ld x,y;}p[MX],W;
struct ln{pt a,b;ld A;}l[MX];
int cp(ld k){return EQ(k,0)?0:k>0?1:-1;}
ld mp(pt p0, pt p1,pt p2){return (p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x);}
bool cmp(ln l,ln L){
    int d=cp(l.A-L.A);
    return d?d<0:cp(mp(l.a, L.a, L.b))<0;
}
void add(ln&l,ld X,ld Y,ld x,ld y){l={{X,Y},{x,y},atan2(y-Y,x-X)};}
void is(ln l,ln L,pt&p){
    ld A=l.b.y-l.a.y,B=l.a.x-l.b.x,C=(l.b.x-l.a.x)*l.a.y-(l.b.y-l.a.y)*l.a.x,
    a=L.b.y-L.a.y,b=L.a.x-L.b.x,c=(L.b.x-L.a.x)*L.a.y-(L.b.y-L.a.y)*L.a.x;
    p={(c*B-C*b)/(A*b-a*B),(C*a-c*A)/(A*b-a*B)};
}
bool exs(ln A,ln l,ln L){return is(l,L,W),cp(mp(W,A.a,A.b))>0;}
void HP(){
    J=pn=0,sort(l,l+n,cmp);
    F(n)if(cp(l[i].A-l[J].A)>0)l[++J]=l[i];
    n=J+1,B=*dq=0,E=dq[1]=1;
    FT(2,n){
        while(E>B&&exs(l[k],l[dq[E]],l[dq[E-1]]))--E;
        while(E>B&&exs(l[k],l[dq[B]],l[dq[B+1]]))++B;
        dq[++E]=k;
    }
    while(E>B&&exs(l[dq[B]],l[dq[E]],l[dq[E-1]]))--E;
    while(E>B&&exs(l[dq[E]],l[dq[B]],l[dq[B+1]]))++B;
    dq[++E]=dq[B];
    FT(B,E)is(l[dq[k+1]],l[dq[k]],p[pn++]);
}
ld AR(){
    if(pn < 3)return 0;
    ld S(0);
    FT(1,pn-1)S+=mp(*p,p[k],p[k+1]);
    return fabs(S/2);
}
ld isx(pt*p,int n){
    F(n-1)add(l[i],p[i].x,p[i].y,p[i+1].x,p[i+1].y);
    add(l[n-1],p[n-1].x,p[n-1].y,p[0].x,p[0].y),HP();
    return AR();
}
\end{lstlisting}
\subsection{Kolmice - dopočítání bodu}
Nechť je přímka z $[xa,ya]$ do $[xb,yb]$. Do \textsf{X},\textsf{Y} se uloží nějaký bod kolmice na tuto přímku, která prochází bodem $[xa,ya]$.
\\Otestovat
\begin{lstlisting}[language=C++]
void pnr(double xa,double ya,double xb,double yb,double &X,double &Y){
    double dx(ya-yb),dy(-(xa-xb));
    X=dx+xa;Y=dy+ya;
}
\end{lstlisting}
\subsection{Konvexní obálka}
Grahamova convexní obálka.
\\Složitost $O(Nlog(N))$
\begin{lstlisting}[language=C++]
#define MX (1024)
struct pt{
    double x,y;
}p[MX],Q[MX],p0;
#define dist(A,B) ((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y))
#define dst(A,B) (sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y)))
int ori(const pt &p,const pt &q,const pt &r){
    double v=(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);
    return EQ(v,0)?0:v>0?-1:2;
}
bool CMP(const pt &a,const pt &b){
    int o(ori(p0,a,b));
    return o?~o:dist(p0,b)>=dist(p0,a);
}
double hull(pt *P, int n){
   double Y(P[0].y),y;
   int m(0),b(2);
   FT(1,n)if (((y=P[k].y)<Y)||(Y==y&&P[k].x<P[m].x))
       Y=P[k].y,m=k;
   swap(P[0],P[m]),p0=P[0];
   sort(P+1,P+n,CMP);
   Q[0]=P[0],Q[1]=P[1];
   FT(2,n){
      while(b>1&&ori(Q[b-2],Q[b-1],P[k])!=2)--b;
      Q[b++]=P[k];
   }
   double d(dst(Q[0],Q[b-1]));
   F(b-1)d+=dst(Q[i],Q[i+1]);
   return d;//There are b points in "Q"
}
\end{lstlisting}
Andrewova Konvexní Obálka
\\Složitost $O(Nlog(N))$ (pokud by se nemusel použít sort - tedy vstup byl už seřazený, bude složitost lineární).
\\Využívá structury $pt$, viz sekce \textit{Bod}
\begin{lstlisting}[language=C++]
int hAW(pt*P,int N,pt*r){
	if(N==1)return *r=*P,1;
    sort(P,P+N);
    int M(0),K;
    F(N){
        while(M>1&&(r[M-1]-r[M-2]).XP(P[i]-r[M-2])<0)--M;
        r[M++]=P[i];
    }K=M;
    for(int i(N-2);~i;--i){
        while(M>K&&(r[M-1]-r[M-2]).XP(P[i]-r[M-2])<0)--M;
        r[M++]=P[i];
    }
    return max(M-1,0);
}
\end{lstlisting}
Další verze - pozor - žere dvojnásobek místa!.
\begin{lstlisting}[language=C++]
#define ar(A,B,C) (A.XP(B)+B.XP(C)+C.XP(A))
int hull(pt*p,int N,pt*r){
    int k=0;
    sort(p,p+N);
    F(2*N)r[i]={0,0};
    F(N){
        while(k>=2&&ar(r[k-2],r[k-1],p[i])<=0)--k;
        r[k++]=p[i];
    }
    for(int i(N-2),t(k+1);~i;--i){
        while(k>=t&&ar(r[k-2],r[k-1],p[i])<=0)--k;
        r[k++]=p[i];
    }
    return k-1;
}
\end{lstlisting}
Další verze - otestovat
\begin{lstlisting}[language=C++]
int hAW(pt*p,int n,pt*r) {
    sort(p,p+n);
    int m=0;
    F(n){
        while(m>=2&&XX(r[m-2],r[m-1],p[i])<=0)--m;
        r[m++]=p[i];
    }
    for(int i=n-1,t=m+1;~i;--i){
        while(m>=t&&XX(r[m-2],r[m-1],p[i])<=0)--m;
        r[m++]=p[i];
    }
    return m-1;
}
\end{lstlisting}
\subsection{Konvexnost polygonu}
Funkce zjistí, zda-li jsou všechny body na jedné stejné straně od úsečky (tedy po iterace přes všechny dvojice po sobě jdoucích bodu lze zjistit konvexnost polygonu).
Funkce "side" viz "Strana bodu vůči přímce".
\begin{lstlisting}[language=C++]
bool cvx(int k,int l){
    int sd(0),tm;
    for(int i(0);i<N;++i)
        if(i!=k&&i!=l){
            tm=side(cx[k],cy[k],cx[l],cy[l],cx[i],cy[i]);
            if(!tm)
                continue;
            if(!sd)
                sd=tm;
            if(sd!=tm)
                return 0;
        }
    return 1;
}
\end{lstlisting}
\subsection{Kružnice ze tří bodů}
\begin{lstlisting}[language=C++]
cl cr(pt a,pt b,pt c){
    double x,y,z,X,Y,Z,D,E;
    pt U({(a.x+b.x)/2,(a.y+b.y)/2}),V({(a.x+c.x)/2,(a.y+c.y)/2}),o;
    x=a.x-b.x,y=a.y-b.y,z=x*U.x+y*U.y;
    X=a.x-c.x,Y=a.y-c.y,Z=X*V.x+Y*V.y;
    D=x*Y-X*y,E=x*Z-X*z,o={(z*Y-Z*y)/D,E/D};
    return {o,o.dst(a)};
}
\end{lstlisting}
\subsection{Minimální počet přímek protínající všechny body}
Minimální počet přímek, které je nutno vést, aby byly protnuty všechny body (těch jě \textsf{N} a jsou uloženy v \textsf{x} a \textsf{y}).
\\Složitost je exponencielní, nicméně dobře optimalizováno, takže to snese i několik desítek (co se vleze do dlouhého intu).
\begin{lstlisting}[language=C++]
#define MX (64)
int N,x[MX],y[MX],L;
map<ll,int> dp;
set<ii> s;
ll q[1<<17],b;
int bts(ll n){
    int ct(0);
    while(n)n&=n-1,++ct;
    return ct;
}
bool ol(int x1,int y1,int x2,int y2,int x3,int y3){
     return !((y2-y1)*(x3-x2)-(x2-x1)*(y3-y2));
}
int dyn(ll b){
    if(dp.count(b))return dp[b];
    int v((1+bts(b))>>1);
    F(L)if(bts(b&q[i])>2)v=min(v,1+dyn(b&(~q[i])));
    return dp[b]=v;
}
int ls(void){
    int a,c,d;
    s.clear(),dp.clear(),L=0;
    F(N)FT(i+1,N){
        a=0,d=k,b=(1LL<<i)|(1LL<<k);
        FOR(l,k+1,N)if(ol(x[i],y[i],x[k],y[k],x[l],y[l]))c=d,d=l,++a,b|=(1LL<<l);
        if(a&&!s.count({c,d}))s.insert({c,d}),q[L++]=b;
    }
    return dyn((1LL<<N)-1);
}
\end{lstlisting}
\subsection{Největší obdélník bez žádného bodu uvnitř}
Je zadána šířka, výška, počet bodů a body.
\\Je nalezen největší možná plocha obdélníka, který má strany rovnoběžné s osami a neobsahuje žádné body (kromě okrajů)
\\Složitost $O(N^2)$
\begin{lstlisting}[language=C++]
struct pt{
    int x,y;
    bool operator<(const pt &p)const{return x^p.x?x<p.x:y<p.y;}
};
int are(int N,int W,pt*P){
    int l,u,X=0;
    sort(P,P+N);
    F(N){
        l=0,u=W;
        FT(i+1,N){
            X=max(X,(P[k].x-P[i].x)*(u-l));
            if(P[k].x^P[i].x){
                if(P[k].y>P[i].y)u=min(u,P[k].y);
                else l=max(l,P[k].y);
            }
        }
    }
    return X;
}
int ar(int H,int W,int N,pt*P){
    P[N++]={0,0},P[N++]={H,W};
    P[N++]={H,0},P[N++]={0,W};
    int X=0;
    X=are(N,W,P);
    F(N)swap(P[i].x,P[i].y);
    X=max(X,are(N,H,P));
//    F(N)swap(P[i].x,P[i].y);//only if needed original
    return X;
}
\end{lstlisting}
\subsection{Nejvzdálenější body}
Nalezne vzdálenost nejvzdálenějších bodů.
\\Nutné dodat funkci dd, která počítá vzdálenost bodů.
\\Složitost $O(nlog(n))$
\begin{lstlisting}[language=C++]
struct pt{
    double x,y,i;
}p[MX],Q[MX],p0;
#define dist(A,B) (dd(A.x,A.y,B.x,B.y))
int A,B,O;
int ori(const pt &p,const pt &q,const pt &r){
    double v=(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);
    return EQ(v,0)?0:v>0?-1:2;
}
bool CMP(const pt &a,const pt &b){
    int o(ori(p0,a,b));
    return o?~o:dist(p0,b)>=dist(p0,a);
}
double hull(pt *P, int n){
   double Y(P[0].y),y;
   int m(0),b(2);
   FT(1,n)if (((y=P[k].y)<Y)||(Y==y&&P[k].x<P[m].x))
       Y=P[k].y,m=k;
   swap(P[0],P[m]),p0=P[0];
   sort(P+1,P+n,CMP);
   Q[0]=P[0],Q[1]=P[1];
   FT(2,n){
      while(b>1&&ori(Q[b-2],Q[b-1],P[k])!=2)--b;
      Q[b++]=P[k];
   }
     int v(0),w,A,B;
   double G,D(0);
   F(b){
       while(dist(Q[i],Q[v])<dist(Q[i],Q[w=(v+1)%b]))v=w;
       G=dist(Q[i],Q[v]);
       if(G>D)D=G,A=Q[i].i,B=Q[v].i;
   }
   return D;
}
\end{lstlisting}
Funkci jsou předány body v pořadí, ve kterém jsou na vstupu. Funkce pak vyhodnotí (do \textsf{o}) největší vzdálenost dvou nejvzdálenějších bodů po každém query.
\\Momentálně je to mocnina vzdálenost (případně upravit $dd$)
\\Pravděpodobně to jde rozbít nějakým vstupem, ale pokud jsou body na vstupu permutovány zhruba náhodně, pak to běhá hodně rychle.
\\Funkce využívá convex-hullu.
\begin{lstlisting}[language=C++]
#define MX (750001)
int C;
ll o[MX];
struct pt{
    ll id,x,y;
    bool operator<(const pt&p)const{return x^p.x?x<p.x:y<p.y;}
    ll dd(pt&r){return (x-r.x)*(x-r.x)+(y-r.y)*(y-r.y);}
    void gt(){scanf("%lld%lld",&x,&y);}
}*S[MX],*A,*B;
void ud(pt*P1,pt*P2){if(P1->dd(*P2)>A->dd(*B)||(P1->dd(*P2)==A->dd(*B)
                     &&max(P1->id,P2->id)<max(A->id,B->id)))A=P1,B=P2;}
void HUL(int T,pt*P){
    int J=0,m=0,F=0,t=1;
    F(C){
        while(J<C&&P[J].id>T)J++;
        if(J==C){C=i;break;}
        P[i]=P[J++];
    }
    F(C){while(m>1&&(P[i].y-S[m-1]->y)*ll(S[m-1]->x-S[m-2]->x)
               >=(P[i].x-S[m-1]->x)*ll(S[m-1]->y-S[m-2]->y))--m;
         S[m++]=P+i;
    }
    for(int i=C-1,E=m;~i;--i){
        while(m>E&&(P[i].y-S[m-1]->y)*ll(S[m-1]->x-S[m-2]->x)
               >=(P[i].x-S[m-1]->x)*ll(S[m-1]->y-S[m-2]->y))--m;
        S[m++]=P+i;
    }
    S[m]=P,A=*S,B=S[1];
    while(F<m){
        while(666){
            ll x=S[F+1]->x-S[F]->x,X=S[t+1]->x-S[t]->x,
               y=S[F+1]->y-S[F]->y,Y=S[t+1]->y-S[t]->y;
            if(x*Y>=X*y)break;
            ud(S[F],S[t]),++t%=m;
        }
        ud(S[F++],S[t]);
    }
}
void dis(int N,pt*P){
    F(N)P[i].id=i+1;
    sort(P,P+N),C=N;
    for(int j=N,K;j>1;j=K){
		HUL(j,P),K=max(A->id,B->id)-1;
        FT(K,j)o[k]=A->dd(*B);//A,B - furthest
	}
}
\end{lstlisting}
\subsection{Nejbližší body}
Z počátku musí být body v \textsf{P} a \textsf{p}. Dále se hodí nastavit \textsf{N}.
\\Strom se inicializuje pomocí $ini(0,N-1,0)$
\\Pokud posléze budeme chtít vzdálenost nejbližšího bodu k "danému" bodu, zavoláme funkci $gt$, která nám ji vrátí. Vzdálenost je umocněná (aby nedocházelo ke ztrátě na přesnosti).
\\Pokud chceme ty samé body tak zálohovat!
\\Složitost $O(N^{1.5})$
\begin{lstlisting}[language=C++]
#define MX (100001)
const int D=2;//DIMENSION
int N,C;
struct pt{ll x[D];}p[MX];
bool cmp(pt a,pt b){return a.x[C]<b.x[C];}
#define PW(A) ((A)*(A))
void ini(int l=0,int r=N-1,int d=0){
    if(l>=r)return;
    int M=(l+r)>>1;
    C=d%D,nth_element(p+l,p+M,p+r+1,cmp);
    ini(l,M-1,d+1),ini(M+1,r,d+1);
}
ll dis(pt x,pt y){
    ll S=0;
    F(D)S+=PW(x.x[i]-y.x[i]);
    return S?S:1e17;
}
ll gt(pt x,int l=0,int r=N-1,int d=0){
    ll t,C=d%D,M=(l+r)>>1;
    if(l>=r)return l^r?1e17:dis(x,p[l]);
    if(x.x[C]<p[M].x[C]){
        if((t=gt(x,l,M-1,d+1))>PW(x.x[C]-p[M].x[C]))
            t=min(t,gt(x,M+1,r,d+1));
    }else if((t=gt(x,M+1,r,d+1))>PW(x.x[C]-p[M].x[C]))
            t=min(t,gt(x,l,M-1,d+1));
    return min(dis(x,p[M]),t);
}
\end{lstlisting}
Nalezne nejkratší vzdálenost od bodu \textbf{[a,b]} ($qr$) na Manhattenské Vzdálenosti.
\\Vybudování: $O(Nlog(N)^2)$
\\Query: $O(log(N)^3log(|U|))$
\\Inicializace proběhne pomocí $bld$, kde se předávají body v \textsf{x} a \textsf{y} souřadnici.
\begin{lstlisting}[language=C++]
#define MX (100001)
struct pt{
    ll x,y;
    bool operator<(const pt&r)const{return x<r.x;}
}v[MX];
bool cp(pt a,pt b){return a.y<b.y;}
struct nd{
    nd *l,*r;
    int B,E;
    vector<pt> p;
}T[MX<<1];
int C;
nd* RT(int a, int b){
    nd*r=&T[C++];
    r->B=a,r->E=b,r->p.assign(&v[a],&v[b]);
    sort(r->p.begin(),r->p.end(),cp);
    r->l=r->r=0;
    if(b-a>1)r->l=RT(a,(a+b)/2),r->r=RT((a+b)/2,b);
    return r;
}
bool fnd(ll x,ll y,ll d,nd*r){
    if(!r)return 0;
    ll U=v[r->B].x,V=v[r->E-1].x;
    if(x+d<U||x-d>V)return 0;
    if(x-d<=U&&V<=x+d){
        pt p={0,y-d};
        auto h=lower_bound(r->p.begin(),r->p.end(),p,cp);
        return h!=r->p.end()&&h->y<=y+d;
    }
    return fnd(x,y,d,r->l)|fnd(x,y,d,r->r);
}
void bld(ll*x,ll*y,int N){
    F(N)v[i]={x[i]+y[i],x[i]-y[i]};
    sort(v,v+N),RT(C=0,N);
}
ll qr(ll a,ll b){
    ll x=a+b,y=a-b,m;
    if(fnd(x,y,0,&T[0]))return 0;
    b=1;
    while(!fnd(x,y,b,&*T))b<<=1;
    a=b>>1;
    while(b-a!=1)
        if(fnd(x,y,m=(a+b)/2,&*T))b=m;
        else a=m;
    return b;
}
\end{lstlisting}
\subsection{Oblouk na kružnici mezi průsečíky}
Vypočítá délku oblouku na kružnici mezi průsečíky $ax,ay,bx,by$
\begin{lstlisting}[language=C++]
double gAng(double x1,double y1,double x2,double y2,double x3,double y3){
    double wx(x2-x1),wy(y2-y1),ux(x2-x3),uy(y2-y3),dt(wx*ux+wy*uy)
    ,cs(wx*uy-wy*ux),tt(atan2(cs,dt));
    return tt>=0?tt:-tt;
}
double getSegment(int k){
    double ang(gAng(ax,ay,x[k],y[k],bx,by));
    return r[k]*ang;
}
\end{lstlisting}
\subsection{Obsah čtyřúhelníku [obecného konvexního]}
$A=\dfrac{1}{4}\sqrt{4p^2q^2-(b^2+d^2-a^2-c^2)^2}$
\begin{figure}[h]
  \centering
  \includegraphics[width=2in]{pic/quadrilateral.jpg}
  \caption[Čtyřúhelník.]{Čtyřúhelník.}
\end{figure}
\begin{lstlisting}[language=C++]
double qa(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){
    return sqrt(4*pow(dst(x1,y1,x3,y3),2)*pow(dst(x2,y2,x4,y4),2)-
    pow(pow(dst(x1,y1,x2,y2),2)+pow(dst(x3,y3,x4,y4),2)-
    pow(dst(x4,y4,x1,y1),2)-pow(dst(x2,y2,x3,y3),2),2))/4;
}
\end{lstlisting}
\subsection{Obsah kruhu}
Obsah kružnice opasené (zadány délky stran trojúhelníka)
\begin{lstlisting}[language=C++]
double TR(double A,double B,double C){double t=(A+B+C)/2;return sqrt(t*(t-A)*(t-B)*(t-C));}
double oC(double A,double B,double C){
    double R(A*B*C*.25/TR(A,B,C));
    return M_PI*R*R;
}
\end{lstlisting}
Obsah kružnice vepsané (zadány délky stran trojúhelníka)
\begin{lstlisting}[language=C++]
double TR(double A,double B,double C){double t=(A+B+C)/2;return sqrt(t*(t-A)*(t-B)*(t-C));}
double iC(double A,double B,double C){
    double R(TR(A,B,C)*2/(A+B+C));
    return M_PI*R*R;
}
\end{lstlisting}
\subsection{Obsah čtverce (nejmenšího) obalujícího body}
Je potřeba přidat \textbf{convex hull} a \textbf{pt}.
\\Aproximuje obsah obalujícího čtverce
\begin{lstlisting}[language=C++]
double dts(ln l,pt&p){
    pt A(p-l.a),B(l.b-l.a);
    double d(A.DT(B)/B.DT(B));
    if(d<0)return l.a.dst(p);
    if(d>1)return l.b.dst(p);
    return (l.a+(B*d)).dst(p);
}
int ARE(ln a,ln b,pt &p) {
    double A,B,C,U,V,W,d,x,y;
    A=a.a.y-a.b.y,B=-a.a.x+a.b.x;
    U=b.a.y-b.b.y,V=-b.a.x+b.b.x;
    C=A*a.a.x+B*a.a.y,W=U*b.a.x+V*b.a.y;
    d=A*V-U*B,x=C*V-W*B,y=A*W-U*C;
    if(EQ(d,0))return 0;
    p={x/d,y/d},A=dts(a,p),B=dts(b,p);
    return EQ(A,0)&&EQ(B,0);
}
int IP(pt*p,int N,pt q){
    int J=N-1,S=0;
    F(N)S+=(p[i].y>q.y)^(p[J].y>q.y)&&q.x<(p[J].x-p[i].x)*(q.y-p[i].y)
                                /(p[J].y-p[i].y)+p[i].x,J=i;
    return S&1;
}
double are(pt*p,int N) {
    if(N<3)return 0;
    double S=0;
    F(N)S+=p[i].x*p[(i+1)%N].y-p[i].y*p[(i+1)%N].x;
    return fabs(S)/2;
}
double SQa(double m,pt p,pt*P,int N) {
    double d,a=sin(m),b=-cos(m),c=-(a*p.x+b*p.y),l=hypot(a,b),w=0,V=0,U=0;
    int B=0,E=0;
    F(N)d=fabs(a*P[i].x+b*P[i].y+c)/l,w=max(w,d),
        B+=a*P[i].x+b*P[i].y+c<-ZERO,E+=a*P[i].x+b*P[i].y+c>ZERO;
    a=cos(m),b=sin(m),c=-(a*p.x+b*p.y),l=hypot(a,b);
    F(N){
        d=fabs(a*P[i].x+b*P[i].y+c)/l;
        if(a*P[i].x+b*P[i].y+c<0)V=max(V,d);
        else U=max(U,d);
    }
    return max(w,V+U)*max(w,V+U);
}
double ts(double l,double r,pt p,pt*P,int N) {
    double M,m,t,o,S=1e18;
    while(!EQ(l,r)){
        M=(l+r)/2,m=(M+r)/2;
        t=SQa(M,p,P,N),o=SQa(m,p,P,N);
        S=min(S,t),S=min(S,o);
        if(t<o)r=m;
        else l=M;
    }
    return S;
}
double SS(int N,pt*w){
    static pt P[MX];
    N=hAW(w,N,P);
    if(N==1)return 0;
    double S=1e18,l,r;
    int J=N-1;
    F(N){
        l=atan2(P[J].y-P[i].y,P[J].x-P[i].x);
        r=l+fmod(atan2(P[(i+1)].y-P[i].y,P[(i+1)].x-P[i].x)-M_PI-l+2*M_PI,2*M_PI);
        if(l<=r)S=min(S,ts(l,r,P[i],P,N));
        else S=min(S,ts(l,M_PI,P[i],P,N)),S=min(S,ts(-M_PI,r,P[i],P,N));
        J=i;
    }
    return S;
}
\end{lstlisting}
\subsection{Obsah obdélníka (nejmenšího) obalujícího polygon}
Vstupem je polygon a počet bodů v něm.
\begin{lstlisting}[language=C++]
double DP(pt a,pt b,pt c){return (c.x-a.x)*(b.x-a.x)+(c.y-a.y)*(b.y-a.y);}
double mr(pt*P,int n){
    if(n<3)return 0;
    int p(1),q(1),r;
    double A(1e10);
    F(n){
        while(XX(P[i],P[i+1],P[p+1])+ZERO>XX(P[i],P[i+1],P[p]))
            ++p,p%=n;
        while(DP(P[i],P[i+1],P[q+1])+ZERO>DP(P[i],P[i+1],P[q]))
            ++q,q%=n;
        if(!i)r=q;
        while(DP(P[i],P[i+1],P[r+1])-ZERO<DP(P[i],P[i+1],P[r]))
            ++r,r%=n;
        A=min(A,XX(P[i],P[i+1],P[p])*(DP(P[i],P[i+1],P[q])-
              DP(P[i],P[i+1],P[r]))/DP(P[i],P[i+1],P[i+1]));
    }
    return A;
}
\end{lstlisting}
Obdobně pro nejmenší obvod!
\begin{lstlisting}[language=C++]
double dot(pt a,pt b){return a.x*b.x+a.y*b.y;}
double mp(pt*p,int n){
	if(n<3)return 0;
	int l=1,r=1,u=1;
    double A=INF,d,w,h;
    F(n){
		pt e=p[(i+1)%n]-p[i];
        e.x/=d=p[(i+1)%n].dst(p[i]),e.y/=d;
		while(dot(e,p[r%n]-p[i])<dot(e,p[(r+1)%n]-p[i]))++r;
		while(u<r||e.XP(p[u%n]-p[i])<e.XP(p[(u+1)%n]-p[i]))++u;
		while(l<u||dot(e,p[l%n]-p[i])>dot(e,p[(l+1)%n]-p[i]))++l;
		h=fabs((p[i]-p[u%n]).XP(p[(i+1)%n]-p[u%n])/p[i].dst(p[(i+1)%n]));
        w=dot(e,p[r%n]-p[i])-dot(e,p[l%n]-p[i]),A=min(A,(w+h)*2);
	}
    return A;
}
\end{lstlisting}
\subsection{Obsah polygonu}
$A=\dfrac{1}{2}(x_1y_2-x_2y_1+x_2y_3-x_3y_2+...+x_ny_1-x_1y_n)$
\vspace{2mm}
\\Pokud je polygon zadán po směru hodinových ručiček je výsledek záporný.
\\Pozor! Může blbnout, pokud jsou v polygonu prvky navíc (př: $[0,0],[0,1],[0,2]$).
\begin{lstlisting}[language=C++]
double are(pt*p,int n){
    double A(0);
    F(n)A+=p[i].XP(p[i+1]);
    return fabs(A/2);
}
\end{lstlisting}
Otestovat - Obsah čtyřúhelnníka.
\begin{lstlisting}[language=C++]
double qta(double xa,double ya,double xb,double yb,double xc,double yc,double xd,double yd){
    return fabs((xa*yb)-(ya*xb)+(xb*yc)-(yb*xc)+(xc*yd)-(yc*xd)+(xd*ya)-(yd*xa))/2;
}
\end{lstlisting}
\subsection{Obsah průsečíků kruhů}
\begin{center}
Pro dva kruhy.
\end{center}
\begin{lstlisting}[language=C++]
#define dst(AX,AY,BX,BY) (sqrt(pow(AX-BX,2)+pow(AY-BY,2)))
#define aoc(r) (M_PI*r*r)
ld br(ld r,ld R,ld d){
    return 2*acos((d*d+r*r-R*R)/(2*d*r));
}
ld ct(ld a,ld r){
    return a*r*r/2-sin(a)*r*r/2;
}
ld cca(ld x,ld y,ld r,ld X, ld Y, ld R){
    ld d(dst(x,y,X,Y)),dx(x-X),dy(y-Y),h(hypot(dx,dy));
    if(d>r+R)return 0;
    if(h<=fabs(r-R))return aoc(min(r,R));
    return ct(br(r,R,d),r)+ct(br(R,r,d),R);
}
\end{lstlisting}
\subsection{Obsah trojúhelníka}
Pokud jsou zadány délky stran.
\begin{lstlisting}[language=C++]
double TR(double A,double B,double C){double t=(A+B+C)/2;return sqrt(t*(t-A)*(t-B)*(t-C));}
\end{lstlisting}
\begin{lstlisting}[language=C++]
ld TR(pt&a,pt&b,pt&c){return fabs(a.XP(b)+b.XP(c)+c.XP(a))/2;}
\end{lstlisting}
\subsection{Ohraničení kruhem}
Vrátí, kolik nejvíce bodů lze ohraničit kruhem o poleměru \textsf{r};
\\V parametrech je počet bodů a jejich souřadnice.
\\Složitost $O(N^2log(N))$
\begin{lstlisting}[language=C++]
#define ZERO (1e-13)
#define PW(a) ((a)*(a))
#define MX (4096)
struct ang{
    double v;
    int id;
    bool operator<(const ang&r)const{return v<r.v;}
}a[MX];
int cvr(int *x,int *y,int n,int r){
    double d,A,vd;
    static int v,ct,w,in[MX];
    int o(1);
    F(n){ct=0;
        FF(n)if(j!=i){
                vd=PW(x[j]-x[i])+PW(y[j]-y[i]);
                if(PW(2*r)+ZERO<vd)continue;
                d=sqrt(vd);
                if(x[i]==x[j]){
                    if(y[i]!=y[j])A=y[j]>y[i]?M_PI/2:3*M_PI/2;
                }else if(y[i]==y[j]) A=(x[j]<x[i])*M_PI;
                else A=atan2(y[j]-y[i],x[j]-x[i]);
                vd=acos(d/(2*r));
                a[ct].v=A+vd+ZERO;a[ct].id=j;
                a[++ct].v=A-vd-ZERO;a[ct++].id=j;
            }
        FF(ct){
            while(a[j].v<0)a[j].v+=2*M_PI;
            while(a[j].v>=2*M_PI)a[j].v-=2*M_PI;
        }
        sort(a,a+ct);v=0;
        FF(n)v+=in[j]=PW(x[j]-(x[i]+r))+PW(y[j]-y[i])<=PW(r)+ZERO;
        o=max(v,o);
        FF(ct)w=a[j].id,o=max(in[w]?--v:++v,o),in[w]=1-in[w];
    }
    return o;
}
\end{lstlisting}
Kratší verze \textbf{fungující} pro double $O(N^3)$
\begin{lstlisting}[language=C++]
int nr(pt*p,int N,pt C,double r){
    int S(0);
    F(N)S+=C.dst(p[i])<=sqrt(r*r)+ZERO;
    return S;
}
int cvr(pt*p,int N,double r){
    int o(0);
    pt m,A,B,v;
    F(N){
        o=max(o,nr(p,N,p[i],r));
        FT(i+1,N){
            A=p[i],B=p[k];
            double d(A.dst(B)),w;
            if(d<=r+r+ZERO){
                d=sqrt(r*r-d*d/4+ZERO),v={A.y-B.y,B.x-A.x};
                m=(A+B)*0.5,w=1/sqrt(v.DT(v)),v=v*w*d;
                o=max(o,max(nr(p,N,m+v,r),nr(p,N,m-v,r)));
            }
        }
    }
    return o;
}
\end{lstlisting}
\subsection{Ohraničující koule}
Ze zadaných bodů nalezne nejmenší kouli, která je ohraničuje a vrátí její poloměr.
\begin{lstlisting}[language=C++]
#define ZERO 0.000001
int n,id;
double x[32],y[32],z[32];
double dst(double x1,double y1,double z1,double x2,double y2,double z2){
    return sqrt(pow(x1-x2,2)+pow(y1-y2,2)+pow(z1-z2,2));
}
double bs(void){
    long double r,d(100),mx,tm;
    while(d>ZERO){
        mx=dst(x[n],y[n],z[n],x[id=0],y[0],z[0]);
        for(int i(1);i<n;++i)
            if((tm=dst(x[n],y[n],z[n],x[i],y[i],z[i]))>mx)
                mx=tm,id=i;
        r=mx;
        x[n]+=(x[id]-x[n])/mx*d;
        y[n]+=(y[id]-y[n])/mx*d;
        z[n]+=(z[id]-z[n])/mx*d;
        d*=0.98;
    }
    return r;
}
\end{lstlisting}
\subsection{Ohraničující kruh}
Ze zadaných bodů nalezne nejmenší kruh, který je ohraničuje a vrátí její poloměr.
\begin{lstlisting}[language=C++]
double x[128],y[128];
double dst(double x1,double y1,double x2,double y2){
    return sqrt(pow(x1-x2,2)+pow(y1-y2,2));
}
double bs(void){
	int id;
    if(n<2)return 0;
    long double r(INF),d(100),mx,tm;
    while(d>ZERO){
        mx=dst(x[n],y[n],x[id=0],y[0]);
        for(int i(1);i<n;++i)
            if((tm=dst(x[n],y[n],x[i],y[i]))>mx)
                mx=tm,id=i;
        
        r=mx;
        x[n]+=(x[id]-x[n])/mx*d;
        y[n]+=(y[id]-y[n])/mx*d;
        d*=0.98;
    }
    return r;
}
\end{lstlisting}
\subsection{Pickův teorém - obsah polygonu na mřížce}
Obsah polygonu (nemusí být konvexní, ale musí mít celočíselné koordináty vrcholů) na mřížce lze vypočítat pomocí vzorce $A=i+\dfrac{b}{2}-1$, kde i je počet vrcholů mřížky uvnitř polygonu a b pak počet vrcholů ležících na hranách polygonu.
\begin{lstlisting}[language=C++]
double pick(int i,int b){
    return i+b/2.0-1;
}
\end{lstlisting}
\subsection{Plocha průniků obdélníků}
\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{pic/rect.png}
  \caption[Průnik obdélníků.]{Průnik obdéůníků.}
\end{figure}
Pomocí $ADD$ se přidá nový obdélník.
\\$MX$ musí být nastaveno výše, než li je počet obdélníků (nejméně $2\times$)
\\Složitost $O(Nlog(N))$
\begin{lstlisting}[language=C++]
#define MX 70000
ll V[MX<<2],C[MX<<2],x[MX<<1];
int n,m;
struct nd{
    ll x,X,y,f;
    bool operator<(const nd&r)const{return y<r.y;}
}P[MX];
void pb(int l,int r,int p){
    if(C[p])V[p]=x[r]-x[l-1];
    else V[p]=V[p<<1]+V[p<<1|1];
}
void ud(int L,int R,int K,int l,int r,int p){
    if(L<=l&&r<=R){
        C[p]+=K,pb(l,r,p);
        return;
    }
    int M((l+r)>>1);
    if(L<=M)ud(L,R,K,l,M,p<<1);
    if(M<R)ud(L,R,K,M+1,r,p<<1|1);
    pb(l,r,p);
}
ll ar(){
    sort(P,P+2*n),sort(x,x+m);
    m=unique(x,x+m)-x;
    CL(V,0),CL(C,0);
    ll R=0,l,r;
    F(2*n-1){
        l=lower_bound(x,x+m,P[i].x)-x+1,r=lower_bound(x,x+m,P[i].X)-x;
        if(l<=r)ud(l,r,P[i].f,0,m+10,1);
        R+=(P[i+1].y-P[i].y)*V[1];
    }
    return R;
}
#define cl (m=0)
#define ADD(a,b,A,B) (P[m]={a,A,b,1},P[m|1]={a,A,B,-1},x[m++]=a,x[m++]=A)
\end{lstlisting}
\subsection{Plocha průsečíku kružnice a obdélníka}
\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{pic/circl_reect.png}
  \caption[Průnik obdélníka a kružnice.]{Průnik obdéůníka a kruřnice.}
\end{figure}
\begin{lstlisting}[language=C++]
struct PT{ld x,y;}pt[20];
PT vec(PT a,PT b){return {a.x-b.x,a.y-b.y};}
struct LN{PT s,e;}ln[4];
struct CC{PT c;ld r;}C;
int P;
bool cn[20];
void fd(LN l,int f){
    PT T;
    ld t;
    switch(f){
        case 0:
            if(fabs(C.c.y-l.s.y)>C.r)return;
            t=sqrt(fabs(C.r*C.r-pow(C.c.y-l.s.y,2)));
            T={C.c.x-t,l.s.y};
            if(T.x>l.s.x&&T.x<l.e.x)pt[P++]=T;
            T.x=C.c.x+t;
            if(T.x>l.s.x&&T.x<l.e.x)pt[P++]=T;
            break;
        case 1:
            if(fabs(C.c.x-l.s.x)>C.r)return;
            t=sqrt(fabs(C.r*C.r-pow(C.c.x-l.s.x,2)));
            T={l.s.x,C.c.y+t};
            if(T.y<l.s.y&&T.y>l.e.y)pt[P++]=T;
            T.y=C.c.y-t;
            if(T.y<l.s.y&&T.y>l.e.y)pt[P++]=T;
            break;
        case 2:
            if(fabs(C.c.y-l.s.y)>C.r)return;
            t=sqrt(fabs(C.r*C.r-pow(C.c.y-l.s.y,2)));
            T={C.c.x+t,l.s.y};
            if(T.x<l.s.x&&T.x>l.e.x)pt[P++]=T;
            T.x=C.c.x-t;
            if(T.x<l.s.x&&T.x>l.e.x)pt[P++]=T;
            break;
        case 3:
            if(fabs(C.c.x-l.s.x)>C.r)return;
            t=sqrt(fabs(C.r*C.r-pow(C.c.x-l.s.x,2)));
            T={l.s.x,0};
            if(l.s.y<l.e.y)T.y=C.c.y-t;
            if(T.y>l.s.y&&T.y<l.e.y)pt[P++]=T;
            T.y=C.c.y+t;
            if(T.y>l.s.y&&T.y<l.e.y)pt[P++]=T;
    }
}
void pre(ld lx,ld ly,ld rx,ld ry){
    ln[P=0]={{lx,ry},{rx,ry}},ln[1]={{rx,ry},{rx,ly}};
    ln[2]={{rx,ly},{lx,ly}},ln[3]={{lx,ly},{lx,ry}};
    F(4)pt[P++]=ln[i].s,fd(ln[i],i);
}
#define dst(a,b) sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2))
#define dst2(a,b) pow(a.x-b.x,2)+pow(a.y-b.y,2)
void tst(){F(P)cn[i]=dst(pt[i],C.c)>C.r+ZERO;}
ld Xp(PT a,PT b){return a.x*b.y-a.y*b.x;}
ld Dp(PT a,PT b){return a.x*b.x+a.y*b.y;}
ld tri (PT a,PT b){return Xp(vec(a,C.c),vec(b,C.c))/2;}
ld sec(PT a,PT b){
    ld da=dst2(a,C.c),db=dst2(b,C.c),cj=Xp(vec(a,C.c),vec(b,C.c)),
       dj=Dp(vec(a,C.c),vec(b,C.c)),D=cj/sqrt(da*db),A=asin(D);
    if(dj<-ZERO)A=A>0?M_PI-A:-M_PI-A;
    return A*C.r*C.r/2;
}
ld rci (ld lx,ld ly,ld rx,ld ry,CC&c){
    C=c;
    pre(lx,ly,rx,ry);
    if(C.r<ZERO)return 0;
    tst();
    ld A=0;
    F(P)if(!cn[i]&&!cn[(i+1)%P])A+=tri(pt[i],pt[(i+1)%P]);
        else A+=sec(pt[i],pt[(i+1)%P]);
    return fabs(A);
}
\end{lstlisting}
\subsection{Počet průsečíků úseček}
\begin{center}
Počet průsečíků úseček kolmých na souřadné osy
\end{center}
Vstupem jsou velikosti polí \textsf{X} a \textsf{Y}, které musí být taktéž vyplněné:
\begin{itemize}
\item \textbf{R} - Souřadnice, které se rovnají
\item \textbf{b} - Menší ze souřadnic (počáteční bod)
\item \textbf{e} - Větší ze souřadnic (koncový bod)
\item \textbf{o} - Hodnota nastavená na true
\end{itemize}
Výstupem je počet průsečíků úseček v \textsf{X} s úsečkami \textsf{Y}.
\\Složitost $O(Nlog(N))$
\\Pole jsou v průběhu algoritmu modifikována. Jsou seřazena a sjednotí se kolineární úsečky. Pokud to není žádoucí, je nutné zakomentovat část volající funkci $rlz$.
\begin{lstlisting}[language=C++]
#define MX (1<<17)
struct pt{
    int R,b,e,o;
    bool operator<(const pt&r)const{return R==r.R?b<r.b:R<r.R;}
}X[MX],Y[MX];
int rlz(pt*A,int N){
    int i(0),X(0),j;
    while(i<N){
        j=i+1;
        while(j<N&&A[i].R==A[j].R)
            if(A[j].b<=A[i].e)A[i].e=max(A[i].e,A[j].e),A[j].o=0,++j,X=1;
            else break;
        i=j;
    }
    if(!X)return N;
    j=i=0;
    while(j<N){
        while(j<N&&!A[j].o)++j;
        if(j<N)A[i++]=A[j++];
    }
    return i;
}
int t[MX<<2],S;
void clr(int s){CL(t,0);S=s;}
void inc(int i,int d){
    for(;i<S;i|=i+1)t[i]+=d;
}
int sum(int i){
    int s(0);
    while(~i)s+=t[i],i&=i+1,--i;
    return s;
}
int gt(int l,int r){
    return sum(r)-sum(l-1);
}
struct ev{
    int w,x,l;
    bool operator<(const ev&r)const{return w!=r.w?w<r.w:x<r.x;};
}q[MX<<1];
map<ll,int> T;
int W[MX<<1];
void btr(void){
    T.clear();
    int c(1),d(0);
    F(LX)W[d++]=X[i].R;
    F(LY)W[d++]=Y[i].b,W[d++]=Y[i].e;
    sort(W,W+d);
    F(d)if(!i||W[i]!=W[i-1])T[W[i]]=c++;
    clr(c+1);
}
ll is(int&LX,int&LY){
    ll S(0),H(0),e(0);
    sort(X,X+LX);sort(Y,Y+LY);
    LX=rlz(X,LX),LY=rlz(Y,LY);//OPTIONAL - get collinear together
    btr();
    F(LX)q[H++]={X[i].b,-1,T[X[i].R]},q[H++]={X[i].e,1,T[X[i].R]};
    sort(q,q+H);
    F(LY){
        while(e<H&&(q[e].w<Y[i].R||(q[e].w==Y[i].R&&!~q[e].x)))
            inc(q[e].l,-q[e].x),++e;
        S+=gt(T[Y[i].b],T[Y[i].e]);
    }
    return S;
}
\end{lstlisting}
\subsection{Počet území obsahující bod(y)}
Přímky jsou zadány pomocí přeisu $ax+by+c=0$.
\\Složitost $O(m)$
\begin{lstlisting}[language=C++]
struct rv{
    int a,b,c;
}v[128];
long long X[1<<16],Y[1<<16];
int n,m;
int in(void){
    vector<vector<int> > G;
    G.resize(1);
    for(int i(0);i<m;++i)
        G[0].PB(i);
    for(int i(0),s(G.size());i<n;++i,s=G.size())
        for(int j(0);j<s;++j){
            vector<int> w[2];
            for(int k(0),q(G[j][k]);k<(int)G[j].size();q=G[j][++k])
                w[v[i].a*X[q]+v[i].b*Y[q]+v[i].c<=0].PB(q);
            if(w[0].empty())
                swap(w[0],w[1]);
            G[j]=w[0];
            if(!w[1].empty())
                G.PB(w[1]);
        }
    return G.size();
}
\end{lstlisting}
\subsection{Počet území rozdělených n přímkami}
Přímky jsou zadány pomocí předpisu $ax+by+c=0$.
\\Složitost $O(n^2)$
\begin{lstlisting}[language=C++]
struct rv{
    int a,b,c;
}v[128];
int n;
int reg(void){
    int r(1);
    for(int i(0);i<n;++i,++r)
        for(int j(0);j<i;++j)
            if(v[i].a*v[j].b!=v[i].b*v[j].a)
                ++r;
    return r;
}
\end{lstlisting}
\subsection{Počet těles v prostoru}
Počet rovnoběžníků
\\Složitost $O(N^2log(N^2))$
\begin{lstlisting}[language=C++]
#define MX (1000)
ii R[MX*MX];
ll par(int N,int*x,int*y){
    ll L(0),A(0),c(0);
    F(N)FT(i+1,N)R[L++]={x[i]+x[k],y[i]+y[k]};
    sort(R,R+L);
    F(L-1)if(R[i+1]==R[i])++c;
          else A+=c*(c+1)/2,c=0;
    return A;
}
\end{lstlisting}
\subsection{Pohyb vektorem}
Najde bod na lajně mezi body \textsf{a} a \textsf{b}, který je od \textsf{a} vzdále \textsf{p}-tinu délky mezi \textsf{a} a \textsf{b}.
\begin{lstlisting}[language=C++]
pt mv(pt a,pt b,double p){return a+((b-a)*p);}
\end{lstlisting}
\subsection{Průnik polygonů}
Plocha průniku dvou polygonů.
\\Složitost $O(N*M*(N+M))$ (Worst Case: museli by se protínat všechny stěny obou polygonů)
\begin{lstlisting}[language=C++]
#define MX (128)
struct pt{
    double x,y;
    pt operator-(pt r)const{return {x-r.x,y-r.y};}
    pt operator+(pt r)const{return {x+r.x,y+r.y};}
    pt operator*(double a){return {x*a,y*a};}
    bool operator<(const pt&r)const{return EQ(x,r.x)?y<r.y:x<r.x;}//< by X
    bool operator==(const pt&r)const{return EQ(x,r.x)&&EQ(y,r.y);};
    double dst(pt r={0,0}){return sqrt((x-r.x)*(x-r.x)+(y-r.y)*(y-r.y));}
    double XP(pt b){return x*b.y-y*b.x;}
    double DT(pt&b){return x*b.x+y*b.y;}
    bool gt(){return ~scanf("%lf%lf",&x,&y);}
}d,e;
double XX(pt&a,pt&b,pt&c){return (a.x-c.x)*(b.y-c.y)-(b.x-c.x)*(a.y-c.y);}
bool cp(pt a,pt b){return EQ(a.y,b.y)?a.x<b.x:a.y<b.y;}//< by Y
struct ln{
    pt a,b;
    bool is(ln r){
        pt c=r.a,d=r.b,ab=b-a,cd=d-c,ac=c-a,ad=d-a,ca=a-c,cb=b-c;
        return ab.XP(ac)*ab.XP(ad)<0&&cd.XP(ca)*cd.XP(cb)<0;
    }
    pt gi(ln r){
        pt u=a-r.a,v=b-a,w=r.b-r.a;
        return a+v*(w.XP(u)/v.XP(w));
    }
}U[MX],W[MX],t;
bool cmp(pair<ln,int>a,pair<ln,int>b){return a.aa.a.x+a.aa.b.x<b.aa.a.x+b.aa.b.x;}
double O[MX*MX*2];
pair<ln,int> V[MX*2];
bool SM(double a,double b){return EQ(a,b);}
double ar(int n,pt*A,int m,pt*B){
    double S=0,y,x;
    int L=0,u,v,M=0;
    FT(1,n)U[k-1]={A[k-1],A[k]};
    FT(1,m)W[k-1]={B[k-1],B[k]};
    U[n-1]={A[n-1],*A},W[m-1]={B[m-1],*B};
    F(n)O[L++]=A[i].y;
    F(m)O[L++]=B[i].y;
    F(n)FF(m)if(U[i].is(W[j]))
        O[L++]=U[i].gi(W[j]).y;
    sort(O,O+L),L=unique(O,O+L,SM)-O;
    FT(1,L){
        M=0;
        FF(n){
            y=U[j].a.y,x=U[j].b.y;
            if(y>x)swap(y,x);
            if(y<=O[k-1]+ZERO&&x>=O[k]-ZERO)
                t={{0,O[k-1]},{1,O[k-1]}},d=U[j].gi(t),
                e=U[j].gi({{0,O[k]},{1,O[k]}}),V[M++]={{d,e},0};
        }
        FF(m){
            y=W[j].a.y,x=W[j].b.y;
            if(y>x)swap(y,x);
            if(y<=O[k-1]+ZERO&&x>=O[k]-ZERO)
                d=W[j].gi({{0,O[k-1]},{1,O[k-1]}}),
                e=W[j].gi({{0,O[k]},{1,O[k]}}),V[M++]={{d,e},1};
        }
        sort(V,V+M,cmp);
        u=0,v=0;
        F(M){
            if(u&&v)S+=V[i].aa.a.x-V[i-1].aa.a.x+V[i].aa.b.x-V[i-1].aa.b.x;
            if(V[i].bb)v^=1;
            else u^=1;
        }
    }
    return S;
}
\end{lstlisting}
\subsection{Průsečíky dvou kružnic}
\begin{lstlisting}[language=C++]
int cci(double x0,double y0,double r0,double x1, double y1, double r1,double &xi
       ,double &yi,double &xi2, double &yi2){
    double a,dx(x1-x0),dy(y1-y0),d(hypot(dx,dy)), h, rx, ry,x2,y2;
    if(d>(r0+r1))return 0;//Do not intersect
    if(d<fabs(r0-r1))return 0;//One inside other
    a=((r0*r0)-(r1*r1)+(d*d))/(2*d) ;
    x2=x0+(dx*a/d),y2=y0+(dy*a/d);
    h=sqrt((r0*r0)-(a*a));
    rx=-dy*(h/d),ry=dx*(h/d);
    xi=x2+rx,xi2=x2-rx;
    yi=y2+ry,yi2=y2-ry;
    return 1;
}
\end{lstlisting}
Zjištění průsečíků kružnic \textsf{A} a \textsf{B}.
\\Průsečíky budou uloženy v \textsf{U} a \textsf{V}
\\Pokud jsou kružnice stejné, návratovou hodnotou bude \textbf{-1}
\\Jina je návratovou hodnotou počet průsečíků (0 až 2)
\begin{lstlisting}[language=C++]
int cci(cl&A,cl&B,pt&U,pt&V){
    double d(A.p.dst(B.p)),t;
    if(EQ(d,0)&&EQ(A.r,B.r))
        return EQ(A.r,0)?(U=A.p),1:-1;
    if(A.r+B.r+ZERO<d||A.r+d+ZERO<B.r||B.r+d+ZERO<A.r)return 0;
    pt v=B.p-A.p;
    if(EQ(d,A.r+B.r)||EQ(A.r,d+B.r)||EQ(B.r,A.r+d)){
        if(EQ(d,A.r+B.r))U={A.p.x+v.x*A.r/d,A.p.y+v.y*A.r/d};
        else if(A.r<B.r)U={A.p.x-v.x*A.r/(B.r-A.r),A.p.y-v.y*A.r/(B.r-A.r)};
        else U={B.p.x+v.x*B.r/(A.r-B.r),B.p.y+v.y*B.r/(A.r-B.r)};
        return 1;
    }
    t=acos((A.r*A.r+d*d-B.r*B.r)/2/A.r/d);
    U={A.p.x+(v.x*cos(t)-v.y*sin(t))*A.r/d,A.p.y+(v.x*sin(t)+v.y*cos(t))*A.r/d};
    return V={A.p.x+(v.x*cos(-t)-v.y*sin(-t))*A.r/d,
    		A.p.y+(v.x*sin(-t)+v.y*cos(-t))*A.r/d},2;
}
\end{lstlisting}
\subsection{Průsečík dvou přímek}
$(P_x,P_y)=(\dfrac{(x_1y_2-y_1x_2)(x_3-x_4)-(x_1-x_2)(x_3y_4-y_3x_4)}{(x_1-x_2)(y_3-y_4)-(y_1-y_2)(x_3-x_4)},
\\\dfrac{(x_1y_2-y_1x_2)(y_3-y_4)-(y_1-y_2)(x_3y_4-y_3x_4)}{(x_1-x_2)(y_3-y_4)-(y_1-y_2)(x_3-x_4)})$
\vspace{3mm}
\begin{lstlisting}[language=C++]
double llX(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){
    return ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
}
double llY(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){
    return ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
pt XY(ln a,ln b){
    return {((a.a.x*a.b.y-a.a.y*a.b.x)*(b.a.x-b.b.x)-(a.a.x-a.b.x)
    *(b.a.x*b.b.y-b.a.y*b.b.x))/((a.a.x-a.b.x)*(b.a.y-b.b.y)-(a.a.y-a.b.y)
    *(b.a.x-b.b.x)),((a.a.x*a.b.y-a.a.y*a.b.x)*(b.a.y-b.b.y)-(a.a.y-a.b.y)
    *(b.a.x*b.b.y-b.a.y*b.b.x))/((a.a.x-a.b.x)*(b.a.y-b.b.y)-(a.a.y-a.b.y)*(b.a.x-b.b.x))};
}
\end{lstlisting}
\subsection{Průsečík dvou úseček [zjištění T/F]}
\begin{lstlisting}[language=C++]
int side(int x1,int y1,int x2,int y2,int x3,int y3){
    int t((y2-y1)*(x3-x2)-(x2-x1)*(y3-y2));
    return t?t>0?1:-1:0;
}
inline bool isOn(int x1,int y1,int x2,int y2,int x3,int y3){
    return x2<=max(x1,x3)&&x2>=min(x1,x3)&&y2<=max(y1,y3)&&y2>=min(y1,y3);
}
bool inter(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){
    int a(side(x1,y1,x2,y2,x3,y3)),b(side(x1,y1,x2,y2,x4,y4)),
        c(side(x3,y3,x4,y4,x1,y1)),d(side(x3,y3,x4,y4,x2,y2));
    return (a!=b&&c!=d)||(!a&&isOn(x1,y1,x3,y3,x2,y2))||(!b&&isOn(x1,y1,x4,y4,x2,y2))
            ||(!c&&isOn(x3,y3,x1,y1,x4,y4))||(!d&&isOn(x3,y3,x2,y2,x4,y4));
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
int sd(pt&a,pt&b,pt&c){int t;return (t=((b-a).y*(c-b).x-(b-a).x*(c-b).y))?t<0?-1:1:0;}
bool io(pt&a,pt&b,pt&c){return b.x<=max(a.x,c.x)&&b.x>=min(a.x,c.x)&&b.y<=max(a.y,c.y)&&b.y>=min(a.y,c.y);}
bool is(pt&A,pt&B,pt&C,pt&D){
    int a(sd(A,B,C)),b(sd(A,B,D)),c(sd(C,D,A)),d(sd(C,D,B));
    return (a!=b&&c!=d)||(!a&&io(A,C,B))||(!b&&io(A,D,B))||(!c&&io(C,A,D))||(!d&&io(C,B,D));
}
\end{lstlisting}
Pokud nám nevadí, že mají stejný úhel, pak zůstane pouze první podmínka u returnu.
\begin{lstlisting}[language=C++]
int sd(pt&a,pt&b,pt&c){int t;return (t=((b-a).y*(c-b).x-(b-a).x*(c-b).y))?t<0?-1:1:0;}
bool io(pt&a,pt&b,pt&c){return b.x<=max(a.x,c.x)&&b.x>=min(a.x,c.x)&&b.y<=max(a.y,c.y)&&b.y>=min(a.y,c.y);}
bool is(ln&U,ln&V){
    int a(sd(U.a,U.b,V.a)),b(sd(U.a,U.b,V.b)),c(sd(V.a,V.b,U.a)),d(sd(V.a,V.b,U.b));
    return (a!=b&&c!=d)||(!a&&io(U.a,V.a,U.b))||(!b&&io(U.a,V.b,U.b))
    					||(!c&&io(V.a,U.a,V.b))||(!d&&io(V.a,U.b,V.b));
}
\end{lstlisting}
\subsection{Průsečíky úsečky a kružnice}
Zjištění [True/False]
\begin{lstlisting}[language=C++]
bool is(cl&c,ln&l){
    pt h({l.a.y-l.b.y,l.b.x-l.a.x}),t(h+c.p);
    return XX(l.a,c.p,t)*XX(l.b,c.p,t)<ZERO&&l.dst(c.p)<=c.r;
}
\end{lstlisting}
Nalezení průsečíků - přepsat a otestovat. [by songman]
\begin{lstlisting}[language=C++]
bool circlelineinter(point o, point b, point v, int r){
    o-=v;b-=v;
    point d=b-o;
    double dr2 = d.x*d.x+d.y*d.y;
    double cross = o.x*b.y-o.y*b.x;
    double disc = r*r*dr2-cross*cross;

    // disc<0 => no intersection; disc==0 => one intersection; disc > 0 => two intersections
    if(disc<0)return false;

    point i1{(cross*d.y + ((d.y<0)?-1:1)*d.x*sqrt(disc))/dr2,(-cross*d.x + abs(d.y)*sqrt(disc))/dr2};
    point i2{(cross*d.y - ((d.y<0)?-1:1)*d.x*sqrt(disc))/dr2,(-cross*d.x - abs(d.y)*sqrt(disc))/dr2};

    return true;
}
\end{lstlisting}
Nalezení průsečíků kružnice a úsečky - otestovat. [by peta]
\\Návratová hodnota je počet průsečíků nalezeno
\\Pokud se lajna jen dotýká, takne navrácena "0".
\\Průsečíky budou v \textsf{a}/\textsf{A}
\begin{lstlisting}[language=C++]
#define BT(A,B,C) (A<min(B,C)-ZERO||A>max(B,C)+ZERO)
#define nn(A) BT(A.x,o.x,b.x)||BT(a.y,o.y,b.y)
int cli(pt o,pt b,double r){
    pt d=b-o;
    double D=d.x*d.x+d.y*d.y,X=o.XP(b),O=r*r*D-X*X,u=abs(d.y)*sqrt(O),v=d.y/abs(d.y)*d.x*sqrt(O);
    if(O<ZERO)return 0;
    pt a={X*d.y+v,-X*d.x+u},A={X*d.y-v,-X*d.x-u};
    a=a*(1./D),A=A*(1./D);
    int I=2;
    if(nn(a))--I,a=A;
    if(nn(A))--I,A=a;
    return I;
}
\end{lstlisting}
\subsection{Převod přímky [Bod-Úhel] na [Bod-Bod]}
Z úhlu a bodu je získán druhý bod.
\begin{lstlisting}[language=C++]
#define RAD(D) (((D)*M_PI)/180)
void sec(double x,double y,int d,double &X,double &Y){
    if(d==90||d==270)
        X=x,Y=y+1;
    else X=x+1,Y=y-tan(RAD(d))*x,Y=tan(RAD(d))*X+Y;
}
\end{lstlisting}

\subsection{Převod přímky v obecném tvaru na [Bod-Bod]}
\begin{lstlisting}[language=C++]
assert(!EQ(a,0)||!EQ(b,0));//RE!!
if(a&&b)  e[i]={i+1,0,c*1./b,(c-(c+1)*b)/a,c+1.,0},e[i].ag();
else if(a)e[i]={i+1,c*1./a,0,c*1./a,1,0},e[i].ag();
else      e[i]={i+1,0,c*1./b,1,c*1./b,0},e[i].ag();

\end{lstlisting}
\subsection{Rozdělení polygonu lajnou}

\begin{lstlisting}[language=C++]
int side(double x1,double y1,double x2,double y2,double x3,double y3){
    double t((y2-y1)*(x3-x2)-(x2-x1)*(y3-y2));
    return EQ(t,0)?0:t>0?1:-1;
}
pt XY(ln a,ln b){
    return {((a.a.x*a.b.y-a.a.y*a.b.x)*(b.a.x-b.b.x)-(a.a.x-a.b.x)
    *(b.a.x*b.b.y-b.a.y*b.b.x))/((a.a.x-a.b.x)*(b.a.y-b.b.y)-(a.a.y-a.b.y)
    *(b.a.x-b.b.x)),((a.a.x*a.b.y-a.a.y*a.b.x)*(b.a.y-b.b.y)-(a.a.y-a.b.y)
    *(b.a.x*b.b.y-b.a.y*b.b.x))/((a.a.x-a.b.x)*(b.a.y-b.b.y)-(a.a.y-a.b.y)*(b.a.x-b.b.x))};
}
int sct(pt a,pt b,int N,pt*p,pt*A,int&U,pt*B,int&V){
    static int H[MX];
    int Z[3]={};
    F(N)++Z[1+(H[i]=side(a.x,a.y,b.x,b.y,p[i].x,p[i].y))];
    if(!*Z)return 1;
    if(!Z[2])return -1;
    U=V=0;
    F(N){
        if(H[i]&&H[(i-1+N)%N]&&H[i]^H[(i-1+N)%N])A[U++]=B[V++]=XY({a,b},{p[i],p[(i-1+N)%N]});
        if(!H[i])A[U++]=B[V++]=p[i];
        else if(~H[i])B[V++]=p[i];
        else A[U++]=p[i];
    }
    return 0;
}
\end{lstlisting}
\subsection{Rozhodnutí, zda-li jde polygon po/proti směru hodinových ručiček}
\begin{lstlisting}[language=C++]
bool cw(pt*p,int N){
    double S=0;
    p[N]=*p;
    F(N)S+=(-(p[i].x+p[i+1].x))*(p[i+1].y-p[i].y);
    return S>0;
}
\end{lstlisting}
\subsection{Strana bodu vůči přímce}
Kde $x3$ a $y3$ je hledaný bod.
\\Návratová hodnota $\in$ \{-1,0,1\}
\begin{lstlisting}[language=C++]
int sd(int x1,int y1,int x2,int y2,int x3,int y3){
    int tm((y2-y1)*(x3-x2)-(x2-x1)*(y3-y2));
    return tm?tm>0?1:-1:0;
}
\end{lstlisting}
Zjistí, jestli je bod (3) na úsečce [\textbf{3D}].
\begin{lstlisting}[language=C++]
bool ol(int x1,int y1,int z1,int x2,int y2,int z2,int x3,int y3,int z3){
    int dx(x3-x1),dy(y3-y1),dz(z3-z1),AX(x2-x1),AY(y2-y1),AZ(z2-z1);
	return dx*AY==dy*AX&&dz*AY==dy*AZ&&dx*AZ==dz*AX;
}
\end{lstlisting}
\subsection{Střed konvexního polygonu}
\begin{lstlisting}[language=C++]
double are(pt*p,int n){
    double A(0);
    F(n)A+=p[i].XP(p[i+1]);
    return fabs(A/2);
}
pt ctr(pt*p,int N){
    double A(are(p,N)*6);
    pt r={0,0};
    F(N)r.x+=(p[i]+p[i+1]).x*p[i].XP(p[i+1]),
        r.y+=(p[i]+p[i+1]).y*p[i].XP(p[i+1]);
    return {r.x/A,r.y/A};
}
\end{lstlisting}
\subsection{Stupně na radiány}
\begin{lstlisting}[language=C++]
#define RAD(D) (((D)*M_PI)/180)
\end{lstlisting}
\subsection{Úhel, který svírají dvě přímky}
\begin{lstlisting}[language=C++]
#define ZERO (1e-13)
#define EQ(A,B) (A+ZERO>B&&A-ZERO<B)
double cang(double xA,double yA,double xB,double yB,double xC,double yC,double xD,double yD){
    double x1(xA-xB),y1(yA-yB),x2(xC-xD),y2(yC-yD),a1,a2;
    if(!EQ(x1,0.0))a1=atan(y1/x1);
    else a1=M_PI/2;
    if(!EQ(x2,0.0))a2=atan(y2/x2);
    else a2=M_PI/2;
//    return fabs(a2-a1);//RADIANS
    return fabs(a2-a1)*180/M_PI;//DEGREES
}
\end{lstlisting}
Obdobně pro polohu přímky vůči ose $x$.
\begin{lstlisting}[language=C++]
double cang(double xA,double yA,double xB,double yB){
    return fabs(atan(0)-(EQ(xA-xB,0.0)?M_PI/2:atan((yA-yB)/(xA-xB))));
}
\end{lstlisting}
\begin{center}
3D
\end{center}
Parametry zde představují normalizované vektory (tedy jakkdyby vycházející z \textbf{\{0,0,0\}})
\begin{lstlisting}[language=C++]
double cang(double x,double y,double z,double X,double Y,double Z){
    double d=(X*x+Y*y+Z*z),L(X*X+Y*Y+Z*Z),l(x*x+y*y+z*z);
    return acos(d/sqrt(L*l));
}
\end{lstlisting}
\subsection{Úhel, který svírají hodinové ručičky}
Atribut hh obsahuje hodiny a mm pak minuty.
\begin{lstlisting}[language=C++]
double gang(int hh,int mm){
    hh%=12;
    double h(30.0*hh+(30.0*mm/60.0)),m(6.0*mm),ang(h-m);
    if(ang<0)
        ang=-ang;
    if(ang>180)
       ang=360.0-ang;
    return ang;
}
\end{lstlisting}
\subsection{Úhly trojúhelníka - SSS}
Parametrem jsou délky tří strana výstupem pak úhly stran jim protilehlé.
\begin{lstlisting}[language=C++]
double oa(double b,double l,double s){
    double o(s*sin(b*M_PI/180)/l);
    return asin(o)*180/M_PI;
}
double ba(double l,double s,double d){
    double o(pow(s,2)+pow(d,2)-pow(l,2));
    o=fabs(o/(2*s*d));
    return acos(o)*180.0/M_PI;
}
void sss(double a,double b,double c,double &A,double &B,double &C){
    if(a>b&&a>c){
        A=ba(a,b,c),B=oa(A,a,b),C=oa(A,a,c);
        if(A+B+C<180)
            A=180-A;
    }else if(b>c&&b>a){
        B=ba(b,a,c),A=oa(B,b,a),C=oa(B,b,c);
        if(A+B+C<180)
            B=180-B;
    }else{
        C=ba(c,a,b),A=oa(C,c,b),B=oa(C,c,b);
        if(A+B+C<180)
            C=180-C;
    }
}
\end{lstlisting}
\subsection{Výška dvou do sebe daných misek}
Jsou do sebe dány 2 misky [skleničky] ($\\_/$), kde \textsf{r} je polomněr dole, \textsf{R} je poloměr nahoře a \textsf{h} je výška.
\\Návratovu hodnotou je jejich výška (dohromady).
\\Note: Misky se v sobě nějakým způsobem zaklíní, buďto dnem, nebo vrškem (nebo vůbec).
\begin{lstlisting}[language=C++]
double dh(double ri,double RI,double hi,double rj,double RJ,double hj) {
    return ri>RJ?hj:RI<=rj?0:max(ri>rj?(ri-rj)*hj/(RJ-rj):0
       ,RI<RJ?(RI-rj)*hj/(RJ-rj)-hi:RI>ri?hj-(RJ-ri)*hi/(RI-ri):0);
}
\end{lstlisting}
\subsection{Výška z bodů na přímce a úhlů}
Jsou tři body na přímce, které jsou od sebe vzdáleny \textsf{D}. Dále jsou dány úhly, pod kterým tyto body vidí nějaké těleso. Funkce vrátí výšku tělesa.
\begin{lstlisting}[language=C++]
#define RAD(D) (((D)*M_PI)/180)
double ght(double a,double b,double c,double d){
    a=tan(RAD(a)),b=tan(RAD(b)),c=tan(RAD(c));
    return d*sqrt(2.0/(1/a/a+1/c/c-2/b/b));
}
\end{lstlisting}
\subsection{Vzdálenost bodu od oblouku}
Funkce $arc$ vrátí vzdálenost bodu \textsf{p} od oblouku, kde krajní body jsou \textsf{a} a \textsf{b} a prochází skrz \textsf{c}.
\begin{lstlisting}[language=C++]
pt wx(pt a,pt b,pt c){
    double A=b.x-a.x,b1=b.y-a.y,c1=(A*A+b1*b1)/2,
    B=c.x-a.x,b2=c.y-a.y,c2=(B*B+b2*b2)/2,d=A*b2-B*b1;
    return {a.x+(c1*b2-c2*b1)/d,a.y+(A*c2-B*c1)/d};
}
double arc(pt&a,pt&b,pt&c,pt&p){
    double x,y,z,A,B,C,D;
    pt I=wx(a,b,c);
    x=max(I.dst(a)-I.dst(p),I.dst(p)-I.dst(a));
    y=(p.dst(a)),z=(p.dst(c));
    A=atan2(a.y-I.y,a.x-I.x),B=atan2(b.y-I.y,b.x-I.x);
    C=atan2(c.y-I.y,c.x-I.x),D=atan2(p.y-I.y,p.x-I.x);
    if(A<C)return (A<=B&&C>=B)==(A<=D&&C>=D)?x:min(y,z);
    return (C<=B&&A>=B)==(C<=D&&A>=D)?x:min(y,z);
}
\end{lstlisting}
\subsection{Vzdálenost bodu od přímky}
Vrátí vzdálenost bodu $x0$,$y0$ od přímky definované body.
\begin{lstlisting}[language=C++]
double lpd(double x1,double y1,double x2,double y2,double x0,double y0){
    return fabs((y2-y1)*x0-(x2-x1)*y0+x2*y1-y2*x1)/sqrt(pow(y2-y1,2)+pow(x2-x1,2));
}
\end{lstlisting}
Vrátí vzdálenost bodu \textsf{p} od bodů \textsf{a} a \textsf{b}. V Bodu \textsf{c} bude bod na přímce, který je nejbližší bodu \textsf{p};
\begin{lstlisting}[language=C++]
double dst(double AX,double AY,double BX,double BY){
    return sqrt(pow(AX-BX,2)+pow(AY-BY,2));
}
typedef pair<double,double> dd;
ii toVec(ii a, ii b) {return {b.x - a.x, b.y - a.y};}
dd scale(ii v, double s) {return {v.x*s,v.y*s}; }
dd translate(ii p, dd v) {return {p.x + v.x , p.y + v.y}; }
double dot(ii a, ii b) { return (a.x * b.x + a.y * b.y); }
double norm_sq(ii v) { return v.x * v.x + v.y * v.y; }
double distToLine(ii p, ii a, ii b, dd &c) {
    ii ap = toVec(a, p), ab = toVec(a, b);
    double u = dot(ap, ab) / norm_sq(ab);
    c = translate(a, scale(ab, u));
    return dst(p.x, p.y, c.x, c.y);
}
\end{lstlisting}
\subsection{Vzdálenost bodu od úsečky}
Vrátí vzdálenost bodu $X$,$Y$ od přímky definované body.
\begin{lstlisting}[language=C++]
ld pds(ld x1, ld y1, ld x2, ld y2,ld X,ld Y){
    ld dx=x2-x1,dY=y2-y1;
    if(!dx&&!dY){
        dx=X-x1,dY=Y-y1;
        return sqrt(dx*dx+dY*dY);
    }
    ld t=((X-x1)*dx+(Y-y1)*dY)/(dx*dx+dY*dY);
    if(t<0)dx=X-x1,dY=Y-y1;
    else if(t>1)dx=X-x2,dY=Y-y2;
    else dx=X-(x1+t*dx),dY=Y-(y1+t*dY);
    return sqrt(dx*dx+dY*dY);
}
\end{lstlisting}
V \textsf{R} bude uložen nejbližší bod na úsečce.
\begin{lstlisting}[language=C++]
double dts(ln&l,pt&p,pt&R){
    pt A(p-l.a),B(l.b-l.a);
    double d(A.DT(B)/B.DT(B));
    if(d<0)return R=l.a,l.a.dst(p);//if not - to line
    if(d>1)return R=l.b,l.b.dst(p);//if not - to line
    return R=l.a+(B*d),R.dst(p);
}
\end{lstlisting}
\subsection{Vzdálenost dvou bodů}
\begin{center}
2D
\end{center}
\begin{lstlisting}[language=C++]
#define dst(AX,AY,BX,BY) sqrt(pow((AX)-(BX),2)+pow((AY)-(BY),2))
\end{lstlisting}
\begin{center}
3D
\end{center}
\begin{lstlisting}[language=C++]
double dst(double x1,double y1,double z1,double x2,double y2,double z2){
    return sqrt(pow(x1-x2,2)+pow(y1-y2,2)+pow(z1-z2,2));
}
\end{lstlisting}
\begin{center}
Celá čísla (vzdálenost na druhou - aby se nemuselo mocnit!)
\end{center}
\begin{lstlisting}[language=C++]
#define dd(AX,AY,BX,BY) ((AX-BX)*(AX-BX)+(BY-AY)*(BY-AY))
\end{lstlisting}
\subsection{Vzdálenost dvou bodů na kouli}
V proměnné \textsf{R} je poloměr koule.
\\$0.5$ na konci funkce je pro zaokrouhlení \textit{int}.
\begin{lstlisting}[language=C++]
struct ct{ld la,lo;};
#define RAD(D) (((D)*M_PI)/180)
int km(const ct &a,const ct &b){
    static int R(6378);
    long double wa(RAD(a.la)),wb(RAD(b.la)),Aw(RAD(b.la-a.la)),AA(RAD(b.lo-a.lo))
               ,h(sin(Aw/2)*sin(Aw/2)+cos(wa)*cos(wb)*sin(AA/2)*sin(AA/2)),
               c(2*atan2(sqrt(h),sqrt(1-h)));
    return R*c+0.5;
}
\end{lstlisting}
Pro porovnání, na nespecifikovaně velké kouly. Prvně se musí latituda i longtituda normalizovat. (po normalizaci a vynásobením poloměrem dostaneme opravdovou vzdálenost)
\begin{lstlisting}[language=C++]
struct ct{ld la,lo;};
double km(ct&a,ct&b){return acos(cos(a.la)*cos(b.la)*cos(a.lo-b.lo)+sin(a.la)*sin(b.la));}
void nr(double&p){p*=M_PI/180;}
\end{lstlisting}
Vzdálenost na kouli skrz kouli (ne po povrchu)
\begin{lstlisting}[language=C++]
double dst(double x1,double y1,double z1,double x2,double y2,double z2){
    return sqrt(pow(x1-x2,2)+pow(y1-y2,2)+pow(z1-z2,2));
}
double ds(ct A,ct B){
    A.la=RAD(A.la),A.lo=RAD(A.lo),B.la=RAD(B.la),B.lo=RAD(B.lo);
    return dst(R*cos(A.la)*cos(A.lo),R*cos(A.la)*sin(A.lo),R*sin(A.la)
        ,R*cos(B.la)*cos(B.lo),R*cos(B.la)*sin(B.lo),R*sin(B.la));
}
\end{lstlisting}
\subsection{Vzdálenost úseček [3D]}
Vrátí druhou mocninu vzdálenosti dvou úseček ve 3D. Vzdálenost je vrácena jako zlomek (takže celá čísla).
\begin{lstlisting}[language=C++]
struct pt{
    int x,y,z;
    bool operator==(pt r){return x==r.x&&y==r.y&&z==r.z;}
    pt operator-(pt u){return {x-u.x,y-u.y,z-u.z};}
    void gt(){scanf("%d%d%d",&x,&y,&z);}
};
ll DP(pt a,pt b){return a.x*b.x+a.y*b.y+a.z*b.z;}
pt XP(pt a,pt b){return {a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x};}
fr PTS (pt p,pt a,pt b){
    if(a==b)return DP(p-a,p-a);
    pt V=b-a,W=p-a,U=p-b;
    if(DP(V,W)<0)return DP(W,W);
    if(DP(V,U)>0)return DP(U,U);
    return fr(DP(XP(V,W),XP(V,W)),DP(V,V));
}
bool L2L(pt P,pt u,pt p,pt v,fr&s){
    ll b=DP(u,u)*DP(v,v)-DP(u,v)*DP(u,v);
    if(!b)return 0;
    return s=fr(DP(u,v)*DP(v,P-p)-DP(v,v)*DP(u,P-p),b),1;
}
fr dst(pt a,pt b,pt c,pt d){
    fr s,t,S;
    if(L2L(a,b-a,c,d-c,s)&&L2L(c,d-c,a,b-a,t)&&s.u>0&&s.u<s.l&&t.u>0&&t.u<t.l){
        pt u=b-a,v=d-c;
        fr x=fr(a.x)+s*u.x,y=fr(a.y)+s*u.y,z=fr(a.z)+s*u.z;
        fr X=fr(c.x)+t*v.x,Y=fr(c.y)+t*v.y,Z=fr(c.z)+t*v.z;
        return (X-x)*(X-x)+(Y-y)*(Y-y)+(Z-z)*(Z-z);
    }
    return min(PTS(a,c,d),min(PTS(b,c,d),min(PTS(c,a,b),PTS(d,a,b))));
}
\end{lstlisting}
\newpage\section{Geometrie - struktury}
\subsection{Bod}
Struktura bod, která podporuje několik základních operací (pro geometrické funkce)
\begin{lstlisting}[language=C++]
struct pt{
    double x,y;
    pt operator-(pt r){return {x-r.x,y-r.y};}
    pt operator+(pt r){return {x+r.x,y+r.y};}
    pt operator*(double a){return {x*a,y*a};}
    bool operator<(const pt&r)const{return EQ(x,r.x)?y<r.y:x<r.x;}//< by X
    bool operator==(const pt&r)const{return EQ(x,r.x)&&EQ(y,r.y);};
    double dst(pt r={0,0}){return sqrt((x-r.x)*(x-r.x)+(y-r.y)*(y-r.y));}
    double XP(pt b){return x*b.y-y*b.x;}
    double DT(pt&b){return x*b.x+y*b.y;}
    bool gt(){return ~scanf("%lf%lf",&x,&y);}
    void prt(){printf("%.3lf %.3lf\n",x,y);}
};
double XX(pt&a,pt&b,pt&c){return (a.x-c.x)*(b.y-c.y)-(b.x-c.x)*(a.y-c.y);}
bool cp(pt a,pt b){return EQ(a.y,b.y)?a.x<b.x:a.y<b.y;}//< by Y
\end{lstlisting}
\subsection{Kružnice}
\begin{lstlisting}[language=C++]
struct cl{
    pt p;
    double r;
    bool gt(){return p.gt()&&~scanf("%lf",&r);}
    double AR(){return M_PI*r*r;}
    double CC(){return 2*M_PI*r;}
    bool in(pt&o){return o.dst(p)<r;}
    bool operator==(const cl&h)const{return EQ(r,h.r)&&p==h.p;}
};
\end{lstlisting}
\subsection{Obdélník}
\begin{lstlisting}[language=C++]
struct rc{
    double x,y,X,Y;
    bool gt(){return ~scanf("%lf%lf%lf%lf",&x,&y,&X,&Y);}
    bool in(pt&p){return !(p.x<=x||p.x>=X||p.y<=y||p.y>=Y);}
    void nr(){if(x>X)swap(x,X);if(y>Y)swap(y,Y);}//normalize x<X,y<Y
    rc ol(rc&r){
        rc p{max(x,r.x),max(y,r.y),min(X,r.X),min(Y,r.Y)},q{INF,INF,INF,INF};
        return p.x>=p.X||p.y>=p.Y?q:p;
    }
    double AR(){return (X-x)*(Y-y);}
    double AR(rc&r){return max(0.,min(X,r.X)-max(x,r.x))*max(0.,min(Y,r.Y)-max(y,r.y));}
};
\end{lstlisting}
\subsection{Úsečka}
Struktura bod, která podporuje několik základních operací (pro geometrické funkce)
\begin{lstlisting}[language=C++]
struct ln{
    pt a,b;
    void gt(){a.gt(),b.gt();}
    double dst(){return a.dst(b);}
    double dst(pt&r){return fabs(XX(r,a,b)/dst());}
};
\end{lstlisting}
\newpage\section{Grafy}
\subsection{All-Pair Unewighted Graph}
V grafu \textsf{G} jsou jedničky na místech, kde jsou hrany, jinak je tam cokoli jiného.
\\Dále je nutné mít velikost grafu v \textsf{N}
\\Složitost $O(\frac{N^2}{64}+64N^2)$
\\Výsledek bude taktéž uložen v \textsf{G}
\begin{lstlisting}[language=C++]
#define LG (11)
#define MX (1<<LG)
int N,G[MX][MX],qp[MX],q[MX];
ll g[MX][MX>>6],Q[MX>>6];
void bfs(int f,int*cn){
    int b(-1),e(1);
    CL(Q,0);
    cn[*q=f]=0;
    Q[f>>6]|=1ull<<(f&63);
    while(++b<e){
        int a(q[b]),p(qp[b]+1);
        F((N>>6)+1)if((g[a][i]|Q[i])!=Q[i])FF(64)if((g[a][i]>>j)&(!((Q[i]>>j)&1)))
            Q[i]|=1ull<<j,cn[q[e]=(i<<6)+j]=qp[e]=p,++e;
    }
}
void p2p(){
    F(N)FF(N)G[i][j]=i==j?0:G[i][j]==1;
    CL(g,0);
    F(N)FF(N)g[i][j>>6]|=(1ull*G[i][j])<<(j&63);
    CL(G,-1);
    F(N)bfs(i,G[i]);
}
\end{lstlisting}
\subsection{Artikulace grafu}
Nalezení kritických uzlů.
\\Kritické uzly budou označeny v \textsf{A}.
\\Indexace od 1
\\Složitost $O(N)$
\begin{lstlisting}[language=C++]
#define AC (g[u][i])
void dfs(int u){
    cn[u]=1,h++,e[u]=d[u]=h;
    F((ll)g[u].size())
        if(!cn[AC])
        	dfs(AC),D+=u==r,A[r]=D>=2,e[u]=min(e[u],e[AC]),A[u]|=e[AC]>=d[u]&&u!=r;
        else e[u]=min(e[u],d[AC]);
}
#define CLR F(n+1)g[i].clear(),e[i]=d[i]=cn[i]=A[i]=0;h=D=0;
#define CAL (dfs(r=1))
\end{lstlisting}
\subsection{Barvení grafu}
\begin{center}
Obarvení dvěma barvami
\end{center}
Pokud lze, funkce $mc$ vrátí true.
\\Funkce cc vrátí četnost obou partit.
\begin{lstlisting}[language=C++]
#define MX (200)
vi g[MX];
int cn[MX];
bool cc(int n,int x,int &w,int &b){
    if(~cn[n])return cn[n]==x;
    cn[n]=x,++w;
    for(int i:g[n])if(!cc(i,!x,b,w))return 0;
    return 1;
}
bool mc(int N,int&S){
    int a,b;
    S=0,CL(cn,-1);
    F(N)if(!~cn[i]){
        if(!cc(i,0,a=0,b=0))return 0;
        else S+=a&&b?min(a,b):max(a,b);//Change if necessary
    }
    return 1;
}
#define CLR for(auto&h:g)h.clear();
#define ADD(A,B) (g[A].PB(B),g[B].PB(A))
\end{lstlisting}
\begin{center}
Obarvení třemi barvami
\end{center}
\begin{lstlisting}[language=C++]
bool bt(int n,int c){
    cn[n]=1;
    for(auto i(g[n].begin());i!=g[n].end();++i)
        if(r[*i]==c)
            return 0;
    r[n]=c;
    for(auto i(g[n].begin());i!=g[n].end();++i)
        if(r[*i]==-1&&!bt(*i,(c+1)%3)&&!bt(*i,(c+2)%3)){
            r[n]=-1;
            return 0;
        }
    r[n]=-1;
    return 1;
}
\end{lstlisting}
\begin{center}
Maximální počet obarvení jednou barvou
\end{center}
Uzly té barvy nesmí být vedle sebe (ostatní uzly žádné podmínky nemají, jde pouze o jednu barvu).
\\Nalezne maximální subset, který tak může být obarven, a uloží ho do \textsf{O} (subset bude o velikost \textsf{L}).
\\Složitost je exponencielní, ale není to děláno úplně hloupě.
\begin{lstlisting}[language=C++]
#define MX (100)
#define CLR c=L=0,CL(C,0);for(auto&h:g)h.clear();
vi g[MX];
int L,O[MX],H[MX],C[MX],c,N;
void col(int u=0){
    if(N-u+c<=L)return;
    if(u==N)return L=c,(void)memcpy(O,H,4*c);
    int X(1);
    for(auto h:g[u])X&=C[h]!=1;
    if(X)H[c++]=u,C[u]=1,col(u+1),--c,C[u]=0;
    col(u+1);
}
\end{lstlisting}
Funkce \textsf{CC} obarví graf (o velikosti \textsf{V}) \textsf{m} a výsledek uloží v \textsf{C}.
\\Pokud neni algoritmus úspěšný, vrátí se $false$
\\Funkce je expoenncielní, ale funguje relativně dobře i pro středně malé grafy.
\begin{lstlisting}[language=C++]
#define MX (101)
#define CLR for(auto&h:g)h.clear();
vi g[MX];
bool ok(int v,int*C,int c,int V){
    for(auto&h:g[v])if(c==C[h])return 0;
    return 1;
}
bool col(int m,int*C,int v,int V){
    if(v==V)return 1;
    FT(1,m+1)if(ok(v,C,k,V)){
        C[v]=k;
        if(col(m,C,v+1,V))return 1;
        C[v]=0;
    }
    return 0;
}
bool CC(int m,int V,int*C){
    F(V)C[i]=0;
    return col(m,C,0,V);
}
\end{lstlisting}
\subsection{Bellma Ford}
Nalezení záporných cyklů.
\\Vrátí true, pokud je nalezen záporný cyklus
\\V poli \textsf{A} bude \textsc{L} uzlů, ze kterých se dá dostat do záporného cyklu.
\\Pole \textsf{R} je reverzní graf.
\\Složitost $O(VE)$.
\begin{lstlisting}[language=C++]
#define MX (101)
#define ME (1<<14)
struct eg{int u,v,w;}g[ME];
int d[MX],A[MX],L,m;
vi R[MX];
bool cn[MX];
void dfs(int u){
    if(cn[u]++)return;
    A[L++]=u;
    F((ll)R[u].size())dfs(R[u][i]);
}
bool bf(int n,int m){
    int u,v,X(0);
    F(n-1)F(m)
        if(d[u=g[i].u]+g[i].w<d[v=g[i].v])
            d[v]=d[u]+g[i].w;
    F(m)if(d[u=g[i].u]+g[i].w<d[v=g[i].v])
        X=1,d[v]=d[u]+g[i].w,dfs(u);
    return X;
}
void clr(int n=MX){
    CL(cn,L=m=0);
    F(n)d[i]=INF,R[i].clear();
}
\end{lstlisting}
\subsection{BFS}
Hledání nejkratších vzdáleností z uzlu \textsf{f} - všechny ceny cest jsou 1.
\\Složitost $O(|E|)$
\\Vzdálenosti budou uloženy v \textsf{cn} (-1 pokud cesta neexistuje)
\begin{lstlisting}[language=C++]
#define MX (1<<14)
int cn[MX],q[MX],qp[MX];
vi g[MX];
void bfs(int f){
    int b(qp[0]=0),e(1);
    CL(cn,-1),q[cn[f]=0]=f;
    while(b<e){
        int a(q[b]),w(qp[b++]);
        for(int i:g[a])
            if(!~cn[i])
                qp[e]=cn[i]=w+1,q[e++]=i;
    }
}
#define ADD(A,B) (g[A].PB(B),g[B].PB(A))
\end{lstlisting}
\subsection{Bulharský algoritmus}
Hledání nejlevnějšího přiřazení práce.
\\Parametry jsou \textsf{N} (počet partity lidí) a \textsf{M} (počet partity prací).
\\Dále je zde matice \textsf{g}, ve které je cena práce pro člověka (pokud neexistuje přidělení, pak se zadá nekonečno).
\\Výstupem je maximální cena přidělení (každý člověk dostane právě 1 práci).
\\Pokud budeme chtít minimum, pak se matice invertuje a vrátí se záporný výsledek.
\begin{lstlisting}[language=C++]
#define MX (355)
int g[MX][MX];
int KM(int N, int M){
    static int p,t,q[MX],P[MX],mx[MX],my[MX],lx[MX],ly[MX];
    int r(0);
    F(N)lx[i]=*max_element(g[i],g[i]+M);
    CL(ly,0),CL(mx,-1),CL(my,-1);
    F(N){
        CL(P,-1);
        q[0]=i,t=1,p=-1;
        while(++p<t)FF(M)if(lx[q[p]]+ly[j]==g[q[p]][j]&&!~P[j]){
            if(P[j]=q[p],!~my[j]){
                int y,yy(j);
                do y=yy,yy=mx[P[y]],mx[P[y]]=y,my[y]=P[y];while(~yy);
                t=-1;
                break;
            }else q[t++]=my[j];
        }
        if(!~mx[i]){
            r=INF;
            FF(t)F(M)if(!~P[i])r=min(r,lx[q[j]]+ly[i]-g[q[j]][i]);
            F(t)lx[q[i]]-=r;
            F(M)if(~P[i])ly[i]+=r;
            --i;
        }
    }
    r=0;
    F(N)r+=g[i][mx[i]];
    return r;
}
\end{lstlisting}
\subsection{Centroidová dekompozice}
Funkce $cdc$ zavoláfuknci $foo$ právě $N$-krát (s každým nodem jako kořenem podstromu). Je zaručeno, že součet velikostí podstromů je nejvýšen $O(Nlog(N))$ (a tedy pokud bude lineární složitost $foo$ [s velikostí podstromu {ne stromu!}]), pak bude i algoritmus $O(Nlog(N))$
\\Graf by měl být po zavolání v pořádku (ale nutno otestovat!!).
\begin{lstlisting}[language=C++]
#define MX (100666)
vii g[MX];
void foo(int r){
    //TODO
}
int W[MX];
int dfs(int u,int p){
    W[u]=1;
    for(auto&h:g[u])if(h.aa^p)W[u]+=dfs(h.aa,u);
    return W[u];
}
int rot(int u,int S){
    for(auto&h:g[u])if(W[h.aa]>S-W[h.aa]&&W[h.aa]<W[u])return rot(h.aa,S);
    return u;
}
void cdc(int r=0){
    int S=dfs(r,-1),R=rot(r,S),a;
    foo(R);
    for(auto&h:g[R]){
        for(auto&w:g[h.aa])if(w.aa==R)a=w.bb,w=g[h.aa].back();
        g[h.aa].pop_back();
        cdc(h.aa);
        g[h.aa].PB({a,R});
    }
}
#define ADD(A,B,C) (g[A].PB({B,C}),g[B].PB({A,C}))
\end{lstlisting}
\subsection{Cesta na stromě}
GCD cesty po stromě.
\\$ini$ - inicializuje strom
\\$nn$ - přidá node $u$ s hodnotou $a$
\\$add$ - přidý hranu mezi uzly $a$ a $b$
\\$rs$ - zmení hodnotu node $u$ na $b$
\\$gpt$ - vrátí gcd cesty mezi 2 nody.
\begin{lstlisting}[language=C++]
#define MX (1<<17)
struct gt{
    int N,d;
    struct nd{
        static nd *O;
        nd *C[2],*h;
        int r,v,S,g;//g for gcd!
        void cl(){*C=C[1]=h=0,r=v=0,g=1,S=1;}
        bool rt(){return *h->C!=this&&h->C[1]!=this;}
        void dw(){if(r)C[0]->r^=1,C[1]->r^= 1,swap(C[0],C[1]),r^=1;}
        void up(){if(this!=O){g=this->v,S=1;F(2)if(C[i]!=O)g=__gcd(C[i]->g,g),S+=C[i]->S;}}
    }G[MX],*A[MX],O,*h,*y,*z;
    void ini(){N=0,nd::O=O.h=*O.C=O.C[1]=&O,O.S=0;}
    void rt(nd *x){
        h=x->h,d=h->C[1]==x,x->C[d^1]->h=h,
        h->C[d]=x->C[d^1],x->C[d^1]=h;
        if(!h->rt())h->h->C[h->h->C[1]==h]=x;
        x->h=h->h,h->h=x,h->up(),x->up();
    }
    void RT(nd *x){if(!x->rt())RT(x->h);x->dw();}
    void sy(nd *x){
        RT(x);
        while(!x->rt()){
            y=x->h,z=y->h;
            if(!y->rt())rt((*y->C==x)^(*z->C==y)?x:y);
            rt(x);
        }
        x->up();
    }
    nd*fd(nd*u){
        nd *v=&O;
        while(u!=&O)sy(u),u->C[1]=v,v=u,v->up(),u=u->h;
        return v;
    }
    void rx(nd *u){fd(u)->r^= 1,sy(u);}
    int gpt(int u,int v){return rx(A[u]),fd(A[v]),sy(A[v]),A[v]->g;}
    void rs(int u,int a){rx(A[u]),A[u]->v=a;}
    void add(int a,int b){rx(A[a]),A[a]->h=A[b];}
    void nn(int u,int a){A[u]=&G[N++],A[u]->cl(),A[u]->v=a,A[u]->h=*A[u]->C=A[u]->C[1]=&O;}
}T;
gt::nd *gt::nd::O;
\end{lstlisting}
\subsection{Cykly délky 3}
Algoritmus hledá cykly délky 3 v grafu \textsf{g}.
\\Ty pak budou uloženy v \textsf{T} a jejich počet bude návratovou hodnotou funkce.
\\Je nutno importovat BitSet
\\$MX$ je velikost grafu a $MC$ je maximum cyklů (nutno odhadnout nebo je zadáno).
\\Složitost $O(N^2T+\dfrac{N^3}{64})$ - Konstanta je dobrá - jedná se o horní trojúhelník.
\begin{lstlisting}[language=C++]
#define MX 3333
#define MC 256
bs B[MX],t;
struct tr{int a,b,c;}T[MC];
vi g[MX];
int fcl(int N){
    int L(0),a;
    F(N)B[i].clr();
    F(N)for(auto&h:g[i])B[i].ad(h);
    F(N)for(auto&h:g[i])if(i<h){
        t=B[i],t&=B[h],a=h;
        while(~(a=t.xt(a)))T[L++]={i,h,a};
    }
    return L;
}
\end{lstlisting}
Pokud bychom chtěli pouze počet
\begin{lstlisting}[language=C++]
#define MX 3000
bs B[MX],t;
vi g[MX];
int fcl(int N){
    int L(0);
    F(N)B[i].clr();
    F(N)for(auto&h:g[i])B[i].ad(h);
    F(N)for(auto&h:g[i])if(i<h)
        t=B[i],t&=B[h],L+=t.bt();
    return L;
}
\end{lstlisting}
\subsection{Dijkstra}
Nalezne nejkratší cestu z uzlů \textsf{f} do ostatních uzlů. V \textsf{g} jsou uloženi sousedi a v \textsf{v} pak ceny.
\\Po ukončení algoritmu budou v \textsf{cn} uloženy nejkratší cesty do uzlu s indexem \textsf{i} (-1 pokud tam cesta z uzlu \textsf{f} nevede).
\\Složitost algoritmu je $O(Elog(E))$, kde \textsf{E} je počet hran - pro libovolný graf nejhůře tedy $O(n^2log(n^2))$ (tedy pro úplný graf) - kde \textsf{n} je počet uzlů.
\begin{lstlisting}[language=C++]
#define MX 128
int cn[MX];
struct eg{
    eg(int V,int T):v(V),t(T){}
    int v,t;
    bool operator<(const eg&r)const{return v>r.v;}
};
vi g[MX],v[MX];
void dj(int f){
    priority_queue<eg> q;
    q.push(eg(0,f));
    CL(cn,-1);
    while(!q.empty()){
        int a(q.top().t),w(q.top().v);
        cn[a]=w;
        F((int)g[a].size())q.push(eg(w+v[a][i],g[a][i]));
        while(!q.empty()&&~cn[q.top().t])
            q.pop();
    }
}
#define ADD(A,B,V) (g[A].PB(B),g[B].PB(A),v[A].PB(V),v[B].PB(V))
#define CLR F(MX)g[i].clear(),v[i].clear();
\end{lstlisting}
Verze se setem. Složitost $O(Elog(N))$.
\begin{lstlisting}[language=C++]
#define MX (1<<14)
#define TP (*q.begin())
ll cn[MX];
vector<pll> g[MX];
void dj(int f){
    CL(cn,-1);cn[f]=0;
    set<pll> q={{0,f}};
    while(!q.empty()){
        ll u(TP.bb),v(TP.aa);
        q.erase(TP);
        for(auto&h:g[u])
            if(!~cn[h.bb])q.insert({cn[h.bb]=h.aa+v,h.bb});
            else if(cn[h.bb]>h.aa+v)q.erase({cn[h.bb],h.bb}),q.insert({cn[h.bb]=h.aa+v,h.bb});
    }
}
#define ADD(A,B,V) (g[A].PB({V,B}))
#define CLR for(auto&h:g)h.clear();
\end{lstlisting}
Obdobně se seznamem sousedů (clear nutno použít předem). Nejrychlejší verze.
\begin{lstlisting}[language=C++]
#define MX (20000)
#define EG (100000)
#define TP (*q.begin())
int cn[MX],e[MX],g[EG],p[EG],V[EG],O;//ll
void dj(int f){
    CL(cn,-1),cn[f]=0;
    set<ii> q={{0,f}};//pll
    while(!q.empty()){
        int u(TP.bb),v(TP.aa);//ll
        q.erase(TP);
        for(int d(e[u]);~d;d=p[d])
            if(!~cn[g[d]])q.insert({cn[g[d]]=V[d]+v,g[d]});
            else if(cn[g[d]]>V[d]+v)q.erase({cn[g[d]],g[d]}),q.insert({cn[g[d]]=V[d]+v,g[d]});
    }
}
#define ADD(A,B,W) (V[O]=W,p[O]=e[A],g[O]=B,e[A]=O++)
#define CLR (CL(e,-1),O=0)
\end{lstlisting}
\subsection{Dinic}
Hledaní maximálního toku.
\\\textsf{SZ} - počet vrcholů.
\\\textsf{ME} - počet hran.
\\Inicializace pomocí ini - Počet nodů, src, destination.
\\Přidání hrany pomocí ade - počáteční hrana, koncová hrana, kapacita, kapacita zpátky
\\Složitost $O(V^2E)$.
\begin{lstlisting}[language=C++]
#define SZ 512
#define ME (1<<14)
struct Dinic{
    int n,m,h[SZ],l[SZ],s,t,w[SZ];
    struct eg{
        int v,c,f,x;
    }e[ME];
    bool bfs(){
        static int q[SZ];
        F(n)l[i]=-1;/*CL(l,-1)*/
        int B(l[s]=0),E(1);
        q[0]=s;
        while(B<E)for(int k(q[B++]),i(h[k]);~i;i=e[i].x)
            if(e[i].f<e[i].c&&!~l[e[i].v])
                l[e[i].v]=l[k]+1,q[E++]=e[i].v;
        return ~l[t];
    }
    int dfs(int u,int f) {
        if(u==t)return f;
        int mf;
        for(int& i(w[u]);~i;i=e[i].x)
            if(e[i].f<e[i].c&&l[u]+1==l[e[i].v])
                if((mf=dfs(e[i].v,min(f,e[i].c-e[i].f)))>0)
                    return e[i].f+=mf,e[i^1].f-=mf,mf;
        return 0;
    }
    void ini(int N,int f,int d){n=N;s=f;t=d;m=0;F(n)h[i]=-1;}
    void ade(int u,int v,int c=1,int rc=0){
        e[m]=eg{v,c,0,h[u]};
        h[u]=m++;
        e[m]=eg{u,rc,0,h[v]};
        h[v]=m++;
    }
    int mf(){
        int a(0),d;
        while(bfs()){
            memcpy(w,h,sizeof(int)*n);
            do a+=d=dfs(s,INF); while(d);
        }
        return a;
    }
}H;
\end{lstlisting}
\subsection{Dominance stromu}
Vrátí maximální dominanci stromu. (indexace od 0)
\\Složitost $O(n)$.
\begin{lstlisting}[language=C++]
#define MX (1<<14)
vector<int> g[MX];
int N,a,b,dp[MX][3];
int leaf(void){
    F(N)if(g[i].size()!=1)return i;
    return 1;
}
int dyn(int u,int w,int P){
    int &v(dp[u][w+2]),V,S(0);
    if(~v)return v;
    v=(1<<30);
    if(!w||(!~w&&g[u].size()!=1)){
        V=0;
        for(int i:g[u])if(i!=P)V+=dyn(i,w-1,u);
        v=min(v,V);
    }
    if(w>-2){
        for(int i:g[u])if(i!=P)S+=dyn(i,-1,u);
        for(int i:g[u])if(i!=P)v=min(v,S-dyn(i,-1,u)+dyn(i,-2,u));
    }
    V=1;
    for(int i:g[u])if(i!=P)V+=dyn(i,0,u);
    v=min(v,V);
    return v;
}
int dom(void){
    if(N<=2)return 1;
    CL(dp,-1);
    return dyn(leaf(),-1,-1);
}
\end{lstlisting}
\subsection{Eulerův tah}
\begin{lstlisting}[language=C++]
vector<int> f[128];
int b,v(0);
void eul(int nd){
    while(!f[nd].empty())
        b=f[nd].back(),f[nd].pop_back(),eul(b);
    v=printf("%s%d",v?" ":"",nd);
}
\end{lstlisting}
\subsection{Floyd-Warshall}
\begin{lstlisting}[language=C++]
F(N)FF(N)g[i][j]=i^j?INF-1:0;//init
FT(0,N)F(N)FF(N)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);//FW
\end{lstlisting}
Floyd-Warshall s rekonstrukcí cesty.
\\$ini$ nainicializuje pole pro FW algoritmus.
\\$go$ provede FW algoritmus
\\$pth$ rekonstruuje cestu z \textsf{a} do \textsf{b}, a uloží ji do \textsf{O}. Návratová hodnota je počet nodes na cestě. (v \textsf{O} bude chybět poslední node (tedy \textsc{b})).
\\Složitost FW je normálně $O(N^3)$. Funkce $pth$ má pak složitost ekvivalentní délce cesty.
\\\textbf{Testováno na doublech! Případně předělat!}
\begin{lstlisting}[language=C++]
#define MX (201)
struct st{int a,b,c;}P[MX][MX];
double g[MX][MX];
void ini(int N){F(N)FF(N)g[i][j]=i^j?INF-1:0,P[i][j]={-1,-1,-1};}
void go(int N){
    FT(0,N)F(N)FF(N)if(g[i][k]+g[k][j]<g[i][j])
        g[i][j]=g[i][k]+g[k][j],P[i][j]={i,k,j};
}
int pth(int a,int b,int*O){
    if(!~P[a][b].a)return *O=a,1;
    int L=pth(P[a][b].a,P[a][b].b,O);
    return L+pth(P[a][b].b,P[a][b].c,O+L);
}
\end{lstlisting}
\subsection{Ford-Fulkerson}
Otestovat - mohlo by být rychlejší
\begin{lstlisting}[language=C++]
#define SZ 2048
int pr[SZ],pp[SZ],q[SZ],N;
bool cn[SZ];
vector<int> g[SZ],v[SZ];
bool bfs(int f, int t){
    memset(cn,0,sizeof(cn));
    int b(0),e(1);
    q[0]=f,cn[f]=1;
    while (b<e)
        for(int i(0),a(q[b++]);i<(int)g[a].size();++i)
            if(!cn[g[a][i]])
                cn[g[a][i]]=1,pr[g[a][i]]=a,pp[g[a][i]]=i,q[e++]=g[a][i];
    return cn[t];
}
int ff(int f,int t){
    int mf(0);
    while (bfs(f,t)&&++mf)
        for(int i(t);i!=f;i=pr[i]){
            if(!--v[pr[i]][pp[i]])g[pr[i]][pp[i]]=g[pr[i]].back(),g[pr[i]].pop_back(),
                    v[pr[i]][pp[i]]=v[pr[i]].back(),v[pr[i]].pop_back();
            g[i].push_back(pr[i]),v[i].push_back(1);
        }
    for(auto &w:g)w.clear();
    for(auto &w:v)w.clear();
    return mf;
}
\end{lstlisting}
Určitě je v pořádku, ale funguje pouze pro všechny hrany rovny 1.
\begin{lstlisting}[language=C++]
#define SZ 2048
int pr[SZ],pp[SZ],q[SZ];
bool cn[SZ];
vector<int> g[SZ];
bool bfs(int f, int t){
    memset(cn,0,sizeof(cn));
    int b(0),e(1);
    q[0]=f,cn[f]=1;
    while (b<e)
        for(int i(0),a(q[b++]);i<(int)g[a].size();++i)
            if(!cn[g[a][i]])
                cn[g[a][i]]=1,pr[g[a][i]]=a,pp[g[a][i]]=i,q[e++]=g[a][i];
    return cn[t];
}
int ff(int f,int t){
    int mf(0);
    while (bfs(f,t)&&++mf)
        for(int i(t);i!=f;i=pr[i])
            g[pr[i]][pp[i]]=g[pr[i]].back(),g[pr[i]].pop_back(),g[i].push_back(pr[i]);
    for(auto &w:g)w.clear();
    return mf;
}
\end{lstlisting}
Otestovat - mohlo by být rychlejší (hrany > 1)
\begin{lstlisting}[language=C++]
#define IMAX 1<<30
#define MX (1<<20)
#define ND g[a][i].first
#define VL g[a][i].second
#define PR make_pair
typedef pair<int,int> pii;
typedef unsigned int ui;
vector<pii> g[MX];
int pr[MX],pv[MX],q[MX],H;
bool cn[MX];
bool bfs(int f, int t){
    F(H)cn[i]=0;
    int b(0),e(1);
    q[0]=f;cn[f]=1;
    while(b<e&&!cn[t])
        for(int i(0),a(q[b++]);i<(int)g[a].size();++i)
            if(!cn[ND]&&VL>0)
                cn[ND]=1,pr[ND]=a,pv[ND]=i,q[e++]=ND;
    return cn[t];
}
int ff(int f,int t){
    int mf(0);
    while(bfs(f,t)){
        int pf(IMAX);
        for(int i(t);i!=f;i=pr[i])
            pf=min(pf,g[pr[i]][pv[i]].second);
        for(int i(t);i!=f;i=pr[i]){
            g[pr[i]][pv[i]].second-=pf,g[i].push_back(PR(pr[i],pf));
            if(!g[pr[i]][pv[i]].second)g[pr[i]][pv[i]]=g[pr[i]].back(),g[pr[i]].pop_back();//TRY!
        }
        mf+=pf;
    }
    return mf;
}
\end{lstlisting}
\subsection{Hopcroft–Karp algorithm}
Nalezne maximální párování.
\\Inicializace pomocí $ini$ - argumentem je maximální velikost jedné z partit
\\Funkce $add$ přidá hranu mezi 2 partitami
\\Metoda $mm$ pak nalezne maximální párování.
\\Složitost $O(E\sqrt{V})$
\\PS: MV musí být více jak dvojnásobek maximální partity (musí se do ní vlézt obě!)
\begin{lstlisting}[language=C++]
#define MV (200*200+2)
#define ME (MV*8)
struct HK{
    int C[MV],d[MV],q[MV],E[ME],X[ME],g[MV],n,m,x,f,t;//f==from | t==to
    void giv(int u,int e){X[m]=g[u],g[u]=m,E[m++]=e;}
    void ini(int X){x=X,n=2*x+2,f=0,t=2*x+1,m=0,CL(g,-1);}
    void add(int a,int b){giv(1+a,x+1+b);}
    bool bfs(){
        int b(0),l(0),v,p;
        F(x)if(C[i+1])d[i+1]=INF;
        else d[i+1]=0,q[l++]=i+1;
        *d=INF;
        while(b<l)for(int i(g[v=q[b++]]);~i;i=X[i])
            if(d[p=C[E[i]]]==INF)d[p]=d[v]+1,q[l++]=p;
        return *d!=INF;
    }
    bool dfs(int u){
        if(!u)return 1;
        for(int i(g[u]);~i;i=X[i]){
            int &e(E[i]),p(C[e]);
            if(d[p]==d[u]+1&&dfs(p))return C[e]=u,C[u]=e,1;
        }
        return d[u]=INF,0;
    }
    int mm(){
        int m(0);
        CL(C,0);
        while(bfs())F(x)if(!C[i+1]&&dfs(i+1))++m;
        return m;
    }
}g;
\end{lstlisting}
\subsection{Isomorfismus stromů}
Zjištění, zda-li jsou dva stromy automorfní.
\\Vstupem jsou klasicky dvě pole vektorů reprezentující strom, a \textsf{N} (velikost)
\\Složitost $O(Nlog(N))$
\\Řešení využívá hashování, takže případně upravit \textsf{a} či \textsf{b} v $dfs$
\begin{lstlisting}[language=C++]
#define MX (10009)
int dfs(int u,int p,vi*g){
    int a=10000141,b=1234577,S=0;
    vi Z;
    for(auto&h:g[u])if(h^p)Z.PB(dfs(h,u,g));
    sort(Z.begin(),Z.end());
    for(auto&h:Z)S*=a,S+=h,a*=b;
    return S*a+1;
}
int D[MX],T[MX],q[MX];
void hsh(vi*g,int N,int&X,int&Y) {
    int u,I=0,b=-1,e=0;
    CL(D,0),CL(T,0);
    F(N)if((D[i]=g[i].size())==1u)q[e++]=i;
    while(++b<e){
        T[I++]=u=q[b];
        for(auto&h:g[u])if(--D[h]==1)q[e++]=h;
    }
    X=dfs(T[I-1],-1,g),Y=dfs(T[I-2],-1,g);
}
bool same(vi*g,vi*G,int N){
    int a,b,c,d;
    if(N==1)return 1;
    hsh(g,N,a,b),hsh(G,N,c,d);
    return a==c||a==d||b==c||b==d;
}
\end{lstlisting}
\subsection{Jarník-Prim}
Nalezení minimální kostry grafu.
\\Algoritmus implementován na \textit{doublech}, vycházející z matice sousednosti \textsf{g}.
\\Složitost $O(N^2log(N^2))$, kde $N$ je počet uzlů.
\begin{lstlisting}[language=C++]
#define MX 128
struct nd{
    nd(int a,double w):t(a),w(w){};
    int t;
    double w;
    bool operator<(const nd&r)const{return w>r.w;}
};
int cn[MX],N,m;
double g[MX][MX];
double spt(void){
    double S(0);
    memset(cn,0,sizeof(cn));
    cn[0]=1;
    priority_queue<nd> q;
    for(int i(1);i<N;++i)
        q.push(nd(i,g[0][i]));
    while(!q.empty()){
        S+=q.top().w;
        int a(q.top().t);
        cn[a]=1;
        F(N)q.push(nd(i,g[a][i]));
        while(!q.empty()&&cn[q.top().t])
            q.pop();
    }
    return S;
}
\end{lstlisting}
\subsection{Johnsonův Algoritmus}
Algoritmus na získání všech nejkratších cest ze všech uzlů do všech.
\\Uzly jsou číslovány od 1
\\Přídání hrany pomocí $ADE$
\\Výsledný graf bude uložen v \textsf{G}.
\begin{lstlisting}[language=C++]
struct eg{
    ll t,c;
};
int N;
#define PR(A,X) (X?A.second:A.first)
#define CLR for(auto &v:g)v.clear();
#define ADE(A,B,C) (g[A].PB({B,C}))
#define MX (128)
vector<eg> g[MX];
ll M[MX][MX],*f,G[MX][MX];
bool bf(int s) {
    F(N+3)FF(N+1)M[i][j]=INF;
    M[0][s]=0;
    FT(1,N+3)F(N+1){
        M[k][i]=min(M[k][i],M[k-1][i]);
        for(auto&e:g[i])M[k][e.t]=min(M[k][e.t],M[k-1][i]+e.c);
    }
    f=M[N+1];f[N+1]=0;
    FF(N+1)if(M[N+2][j]!=M[N+1][j])return 0;
    return 1;
}
void dj(int s,ll *H) {
    F(N+1)H[i]=INF;
    set<pll> q={{0,s}};
    while(!q.empty()){
        pll p(*q.begin());
        q.erase(q.begin());
        ll d(PR(p,0)),n(PR(p,1));
        H[n]=d;
        for(auto e:g[n])if(H[n]+e.c<H[e.t]){
                if(H[e.t]!=INF)q.erase(q.find({H[e.t], e.t}));
                q.insert({H[n]+e.c, e.t});
                H[e.t]=H[n]+e.c;
        }
    }
}
bool js(void){
    FT(1,N+1)g[0].PB({k,0});
    if(!bf(0))return 0;
    FT(1,N+1)for(auto&e:g[k])e.c=e.c+f[k]-f[e.t];
    FT(1,N+1)dj(k,G[k]);
    FT(1,N+1)FOR(v,1,N+1)if(G[k][v]!=INF)G[k][v]+=f[v]-f[k];
  return 1;
}
\end{lstlisting}
\subsection{Kontrola grafu}
Zkontroluje, zda-li by šlo zkonstruovat graf o \textsf{N} ulzech, kde každý z uzlů má $A_i$ sousedů.
\\Složitost $O(N^2)$ (mělo by to jít i líp)
\begin{lstlisting}[language=C++]
#define MX (1024)
int N,A[MX],d,p,n;
bool ok(){
    if(!N)return 1;
    if(accumulate(A,A+N,0)&1)return 0;
    sort(A,A+N),reverse(A,A+N);
    if(*A>=N)return 0;
    F(N){
        p=i*(i-1),n=0;
        FT(i,N)n+=min(i,A[k]);
        if(accumulate(A,A+i,0)>p+n)return 0;
    }
    return 1;
}
\end{lstlisting}
\subsection{Kruskalův algoritmus [minimální kostra]}
Složitost $O(Elog(E))$, kde $E$ je počet hran.
\\Návratová hodnota je délka stromu.
\\Parametr \textit{s} obsahuje počet uzlů (lze díky němu tedy například zjistit, zda-li je graf spojitý).
\begin{center}
Další verze
\end{center}
\begin{lstlisting}[language=C++]
#define MX (400)
struct nd{
   int a,b,w,is;
   bool operator<(const nd&r)const{return w<r.w;}
}g[MX*MX];
int C[MX],R[MX],W;
int geco(int a){return C[a]=(a==C[a]?a:geco(C[a]));}
bool con(int a,int b){
    if(geco(a)==geco(b))return 0;
    if(R[C[a]]>R[C[b]])C[C[b]]=C[a];
    else R[C[b]]+=R[C[a]]==R[C[b]],C[C[a]]=C[b];
    return --W,1;
}
#define CLR (iota(C,C+N,0),CL(R,0),W=N)
int spa(int M,int N){
    int S(0);
    sort(g,g+M),CLR;
    F(M&&W-1)if(con(g[i].a,g[i].b))S+=g[i].w,g[i].is=1;
    return S;
}
\end{lstlisting}
\subsection{LCA}
\textsf{LS} je velikost logaritmu většího, než-li největší číslo, \textsf{D} je hloubka a \textsf{P} jsou rodiče uzlu (1,2,4,8,...). \textsf{N} je pak počet uzlů.
\\Zavoláním funkce \textit{st} se inicializují hodnoty. Parametrem je kořen stromu.
\\Indexace je od 1 do \textsf{N}.
\\Složitost $O(Nlog(N))$
\\Funkce \textit{lca} vrátí \textit{LCA} uzlů \textsf{a} a \textsf{b}.
\begin{lstlisting}[language=C++]
#define LS 17
#define MX (1<<LS)
vi g[MX];
int D[MX],P[MX][LS+1];
void vnd(int u,int p,int d){
    *P[u]=p,D[u]=d++;
    for(int i:g[u])if(i^p)vnd(i,u,d);
}
void ini(int N,int r=0){
    vnd(r,r,0);
    F(LS)FF(N)P[j+1][i+1]=P[P[j+1][i]][i];
}
int lca(int a,int b){
    if(D[a]>D[b])swap(a,b);
    int d=D[b]-D[a],s=0;
    while(d)b=d&1?P[b][s]:b,d>>=1,++s;
    for(int i(LS-1);~i;--i)
        if(P[a][i]^P[b][i])
            a=P[a][i],b=P[b][i];
    return a^b?*P[a]:a;
}
\end{lstlisting}
Jedná li se o strom zakořeněný, mohou přijít vhod i následující funkčnosti.
\\ADD přidává syna \textsf{B} do rodiče \textsf{A}.
\\\textit{root} pak nalezne kořen.
\\Nutné vždy vynulovat pole \textsf{r}
\begin{lstlisting}[language=C++]
#define ADD(A,B) (g[A].push_back(B),++r[B])
int r[MX];
int root(void){
    F(N)if(!r[i+1])return i+1;
    return 666;
}
\end{lstlisting}
Další LCA využívající $HLD$. Implementace je poněkud delší. Výhodou je však fakt, že paměťová složitost je lineární. Taktéž i čas inicializace.
\begin{lstlisting}[language=C++]
#define MX 1024
vi g[MX];
int D[MX],P[MX],R,T[MX],C[MX],O,F[MX];
int dfs(int u,int d,int p){
    int w,S(1),b=-1;
    D[u]=d,P[u]=p,F[u]=-1;
    for(auto&h:g[u])if(h^p){
        S+=w=dfs(h,d+1,u);
        if(w>b)b=w,F[u]=h;
    }
    return S;
}
void hld(int u,int B,int c){
    for(auto&h:g[u])if(h^P[u]){
        if(h^F[u])hld(h,0,O++);
        else hld(h,B+1,c);
    }
    if(!B)T[c]=u;
    C[u]=c;
}
void ini(int r=0){dfs(R=r,0,r),O=1,hld(R,0,0);}
void clr(){F(MX)g[i].clear();}
int lca(int a,int b){
    if(C[a]==C[b])return D[a]<D[b]?a:b;
    return D[T[C[a]]]<D[T[C[b]]]?lca(P[T[C[b]]],a):lca(P[T[C[a]]],b);
}
\end{lstlisting}
Modifikace tak, že lca hledá nejlevnější nejdražší cestu, přes kterou je ve stromě nutno projít.
\begin{lstlisting}[language=C++]
#define LS 13
#define MX (1<<LS)
vii g[MX];
int D[MX],P[MX][LS+1],V[MX][LS+1];
void vnd(int u,int p,int d,int w){
    *P[u]=p,*V[u]=w,D[u]=d++;
    for(auto&h:g[u])if(h.aa^p)vnd(h.aa,u,d,h.bb);
}
void st(int N,int r=0){
    vnd(r,r,0,0);
    F(LS)FF(N)P[j+1][i+1]=P[P[j+1][i]][i],
              V[j+1][i+1]=max(V[P[j+1][i]][i],V[j+1][i]);
}
int lca(int a,int b){
    if(D[a]>D[b])swap(a,b);
    int d=D[b]-D[a],s=0,X=-INF;
    while(d)X=max(X,d&1?V[b][s]:0),b=d&1?P[b][s]:b,d>>=1,++s;
    for(int i(LS-1);~i;--i)
        if(P[a][i]^P[b][i])
            X=max(X,max(V[a][i],V[b][i])),a=P[a][i],b=P[b][i];
    return a^b?max(X,max(*V[a],*V[b])):X;
}
#define ADD(A,B,C) g[A].PB({B,C}),g[B].PB({A,C})
#define CCL for(auto&h:g)h.clear();
\end{lstlisting}
Obdobně jako nahoře - jen minimum místo maxima
\begin{lstlisting}[language=C++]
#define LS 15
#define MX (1<<LS)
vi g[MX],v[MX];
int D[MX],P[MX][LS+1],V[MX][LS+1],N;
void vnd(int u,int p,int d,int w){
    P[u][0]=p,*V[u]=w,D[u]=d++;
    F(ll(g[u].size()))if(g[u][i]!=p)vnd(g[u][i],u,d,v[u][i]);
}
void st(int r=1){
    vnd(r,r,0,0);
    F(LS)FF(N)P[j+1][i+1]=P[P[j+1][i]][i],
              V[j+1][i+1]=min(V[P[j+1][i]][i],V[j+1][i]);
}
int lca(int a,int b){
    if(D[a]>D[b])a^=b,b^=a,a^=b;
    int d(D[b]-D[a]),s(0),X(INF);
    while(d)X=min(X,d&1?V[b][s]:INF),b=d&1?P[b][s]:b,d>>=1,++s;
    for(int i(LS-1);~i;--i)
        if(P[a][i]!=P[b][i])
            X=min(X,min(V[a][i],V[b][i])),a=P[a][i],b=P[b][i];
    return a==b?X:min(X,min(V[a][0],V[b][0]));
}
\end{lstlisting}
Modifikace tak, že lca hledá cenu cesty, přes kterou je ve stromě nutno projít.
\begin{lstlisting}[language=C++]
#define LS 17
#define MX (1<<LS)
vi g[MX],v[MX];
int D[MX],P[MX][LS+1],N;
ll V[MX][LS+1];
void vnd(int u,int p,int d,int w){
    P[u][0]=p,*V[u]=w,D[u]=d++;
    F(ll(g[u].size()))if(g[u][i]!=p)vnd(g[u][i],u,d,v[u][i]);
}
void st(int r=1){
    vnd(r,r,0,0);
    F(LS)FF(N)P[j+1][i+1]=P[P[j+1][i]][i],
              V[j+1][i+1]=V[P[j+1][i]][i]+V[j+1][i];
}
ll lca(int a,int b){
    if(D[a]>D[b])a^=b,b^=a,a^=b;
    int d(D[b]-D[a]),s(0);
    ll X(0);
    while(d)X+=d&1?V[b][s]:0,b=d&1?P[b][s]:b,d>>=1,++s;
    for(int i(LS-1);~i;--i)
        if(P[a][i]!=P[b][i])
            X+=V[a][i]+V[b][i],a=P[a][i],b=P[b][i];
    return a==b?X:X+V[a][0]+V[b][0];
}
\end{lstlisting}
LCA se složitostí $O(Nlog(N))$ / $O(1)$
\\Ještě otestovat! (chefTree)
\begin{lstlisting}[language=C++]
#define LG (18)
#define MX (1<<(LG+1))
vi g[MX];
int R[(MX)][LG],d[MX],E[MX],D[MX],f[MX],C,cn[MX],a[MX],dp[MX],X[MX];
void CLR(int n){
    F(n)g[i].clear(),cn[i]=D[i]=f[i]=X[i]=0,dp[i]=INF;
    F(n<<1)E[i]=d[i]=0;
    C=0;
}
void dfs(int u,int p){
    f[u]=C,E[C++]=u;
    if(!~p)D[u]=0,X[u]=a[u];
    else D[u]=D[p]+1;X[u]=a[u]^X[p];//OPERATION
    for(auto&h:g[u])if(h^p)dfs(h,u),E[C++]=u;
}
void fd(){
    F(C)d[i]=D[E[i]],d[C]=INF;//INF
    FF(LG)F(C){
        R[i][j]=C;
        if(i+(1<<j)-1<C){
            if(!j)R[i][j] = i;
            else if(d[R[i][j-1]]<d[R[i+(1<<(j-1))][j-1]])R[i][j]=R[i][j-1];
            else R[i][j]=R[i+(1<<(j-1))][j-1];
        }
    }
}
int rmq(int l, int r){
    int k=31-__builtin_clz(r-l);
    return d[R[l][k]]<d[R[r-(1<<k)+1][k]]?R[l][k]:R[r-(1<<k)+1][k];
}
int lca(int u,int v){return E[rmq(min(f[u],f[v]),max(f[u],f[v]))];}
int dfs2(int u,int p){
    for(auto&h:g[u])if(h^p)dp[u]=max(dp[u],dfs2(h,u));
    return dp[u];
}
#define ADD(A,B) (g[A].PB(B),g[B].PB(A))
#define CAL(R) dfs(R,-1),fd()

\end{lstlisting}
\subsection{Link-Cut Tree}
Strom, který funguje jako Union Find s removem.
\\Inicializace jako $lc tr(N);$, kde \textsf{N} je počet uzlů.
\begin{itemize}
\item $con(a,b)$ - Zjistí, zdali jsou hrany \textsf{a}/\textsf{b} spojené (né nutně přímo).
\item $lnk(a,b)$ - Spojí hrany \textsf{a}/\textsf{b}.
\item $cut(a,b)$ - Rozbojí hrany \textsf{a}/\textsf{b}.
\end{itemize}
Složitost operací je $O(log(N))$
\begin{lstlisting}[language=C++]
struct nd{
    typedef nd nt;
    nd():P(0),pp(0),f(0){*C=C[1]=0;fix();}
    nt*P,*C[2],*pp;
    int f;
    void fix(){
        if(*C)C[0]->P=this;
        if(C[1])C[1]->P=this;
    }
    void psh(){
        if(!f)return;
        f=0,swap(*C,C[1]);
        if(*C)C[0]->f^=1;
        if(C[1])C[1]->f^=1;
    }
    int up(){return !P?-1:!(P->C[0]==this);}
    void zig(int c){
        nt*X=C[c];
        if((X->P=P))P->C[up()]=X;
        C[c]=X->C[1-c],X->C[1-c]=this;
        fix();X->fix();
        if(P)P->fix();
        swap(pp,X->pp);
    }
    void zA(int c){
        nt*X=C[c],*Y=X->C[c];
        if((Y->P=P))P->C[up()]=Y;
        C[c]=X->C[1-c],X->C[c]=Y->C[1-c],Y->C[1-c]=X;
        X->C[1-c]=this,fix(),X->fix(),Y->fix();
        if(P)P->fix();
        swap(pp,Y->pp);
    }
    void zB(int c){
        nt*X=C[c],*Y=X->C[1-c];
        if((Y->P=P))P->C[up()]=Y;
        C[c]= Y->C[1-c],X->C[1-c]=Y->C[c],Y->C[1-c]=this;
        Y->C[c]=X,fix(),X->fix(),Y->fix();
        if(P)P->fix();
        swap(pp,Y->pp);
    }
    nt*splay(){
        for(psh();P;){
            if(P->P) P->P->psh();
            P->psh(),psh();
            int c1=up(),c2=P->up();
            if(!~c2) P->zig(c1);
            else if(c1==c2)P->P->zA(c1);
            else P->P->zB(c2);
        }
        return this;
    }
    nt*lst(){return psh(),C[1]?C[1]->lst():splay();}
    nt*fst(){return psh(),*C?C[0]->fst():splay();}
};
struct lc{
    typedef nd nt;
    lc(int N):cd(N){}
    void lnk(int u, int v){if(con(u,v))return;rt(v),cd[v].pp=&cd[u];}
    void cut(int u,int v){
    	if(!con(u,v))return;
        rt(u),cd[v].splay();
        if(cd[v].pp)cd[v].pp=0;
        else cd[v].C[0]->P=cd[v].C[0]=0,cd[v].fix();
    }
    bool con(int u,int v){
        nt*nu=acc(u)->fst(),*nv=acc(v)->fst();
        return nu == nv;
    }
    void rt(int u){
        acc(u),cd[u].splay();
        if(*cd[u].C)
            cd[u].C[0]->P=0,cd[u].C[0]->f^=1,cd[u].C[0]->pp=&cd[u],
            cd[u].C[0]=0,cd[u].fix();
    }
    nd*acc(int u){
        nt*x,*pp;
        for(x=cd[u].splay();x->pp;x=pp){
            pp=x->pp->splay(),x->pp=0;
            if(pp->C[1])pp->C[1]->P=0,pp->C[1]->pp=pp;
            pp->C[1]=x,pp->fix();
        }
        return x;
    }
    vector<nt> cd;
};
\end{lstlisting}
\subsection{Maximální párování}
Funkce $mm$ přijímá zdroj a spotřebič.
\\V \textsf{g} je uložen graf klasicky.
\begin{lstlisting}[language=C++]
#define MX (1<<14)
vi g[MX];
int q[MX],cn[MX],L;
bool ap(int f,int t){
    if(cn[f]++)return 0;
    q[L++]=f;
    if(f==t)return 1;
    F((ll)g[f].size())if(ap(g[f][i],t))
        return g[g[f][i]].PB(f),g[f][i]=g[f].back(),g[f].pop_back(),1;
    return 0;
}
void clr(void){
    F(L)cn[q[i]]=0;
    L=0;
}
int mm(int f,int t){
    int r(L=0);
    while(ap(f,t))++r,clr();
    clr();
    return r;
}
\end{lstlisting}
\subsection{Maximální tok}
Funkce $mm$ přijímá zdroj a spotřebič.
\\V \textsf{g} je uložen graf klasicky. v \textsf{G} je pak matice grafu. Celé lze vybudovat pomocí $ade$.
\\Pro každý testcase se čistí pomocí $cl$.
\begin{lstlisting}[language=C++]
#define MX (1024)
int G[MX][MX],cn[MX];
vi g[MX];
void ade(int f,int t,int v){
	if(!v)return;
    if(!G[f][t])g[f].PB(t);
    G[f][t]+=v;
}
#define cl CL(G,0);for(auto &v:g)v.clear();
int ap(int f,int t,int v){
    if(f==t)return v;
    if(cn[f]++)return 0;
    int h,r(v),T;
    F((ll)g[f].size()&&r)
        if(T=g[f][i],(h=ap(T,t,min(r,G[f][T])))){
            r-=h;
            if(!G[T][f])g[T].PB(f);
            G[T][f]+=h;
            if(!(G[f][T]-=h))g[f][i]=g[f].back(),g[f].pop_back(),--i;
        }
    return v-r;
}
int mf(int f,int t){
    int S(0),h;
    while(CL(cn,0),(h=ap(f,t,INF)))
        S+=h;
    return S;
}
\end{lstlisting}
Vytištění minimálního řezu (hran).
\begin{lstlisting}[language=C++]
unordered_set<int> S;
void dfs(int u){
    if(S.count(u))return;
    S.insert(u);
    for(auto h:g[u])if(G[u][h])dfs(h);
}
void prt(){
    S.clear(),dfs(0);
    for(auto&h:S)for(auto&t:g[h])if(!S.count(t)&&G[h][t]<=0)printf("%d %d\n",h+1,t+1);
}
\end{lstlisting}
\subsection{Min-cost Max-flow}
Maximální tok, kde každý hrana má zároveň cenu, která je maximalizována.
\\Návratová hodnota je maximální tok a minimální cena.
\\Ade přidává v pořadí z, do, kapacita, cena
\begin{lstlisting}[language=C++]
#define MX 256
#define ME (1<<15)
int V,E,p[MX],l[MX];
ll C[ME],W[ME],T[ME],n[ME],d[MX],P[MX];
#define CLR(N) (CL(l,-1),E=0,V=N)
#define TP (*Q.begin())
void ade(int u,int v,ll S,ll c){
	T[E]=v,C[E]=S,W[E]=c,n[E]=l[u],l[u]=E++,
	T[E]=u,C[E]=0,W[E]=-c,n[E]=l[v],l[v]=E++;
}
set<pll> Q;
pll mf(int s,int t){
    ll v(0),c(0);
    CL(P,0);
    while(666){
        CL(p,-1);
        fill(d,d+V,INF);
        Q.insert({d[s]=p[s]=0,s});
        while(!Q.empty()){
            ll a(TP.bb),w;
            Q.erase(TP);
            for(int e=l[a];~e;e=n[e])
                if(C[e]>0&&(w=d[a]+W[e]+P[a]-P[T[e]])<d[T[e]])
                    Q.erase({d[T[e]],T[e]}),d[T[e]]=w,p[T[e]]=e,Q.insert({w,T[e]});
        }
        if(!~p[t])return {v,c};
        ll f(INF);
        for(int i(t);i!=s;i=T[p[i]^1])f=min(f,C[p[i]]);
        for(int i(t);i!=s;i=T[p[i]^1])C[p[i]]-=f,C[p[i]^1]+=f;
        v+=f,c+=f*(d[t]-P[s]+P[t]);
        F(V)if(~p[i])P[i]+=d[i];
    }
}
\end{lstlisting}
Todle funguje s doubleama.
\\$mc$ nalezne nejlevnější cestu (při nejdražším toku) - argumenty jsou velikost $N$ a matice $N \times N$ (obou partit)
\\V \textsf{s} pak budou uloženy první partity k druhým paritám
\begin{lstlisting}[language=C++]
struct KM{
    typedef double tp;
    tp X[MX],Y[MX],S[MX],R;
    int x[MX],y[MX],s[MX],f[MX],n,O;
    void aug(int v){
        s[v]=y[v];
        if(x[s[v]]^-2)aug(x[s[v]]);
    }
    bool find(int v,tp w[][MX]) {
        F(n)if(!~y[i]){
            if(S[i]>X[v]+Y[i]-w[v][i]+ZERO)
                S[i]=X[v]+Y[i]-w[v][i],f[i]=v;
            if(fabs(X[v]+Y[i]-w[v][i])<=ZERO){
                y[i]=v;
                if(!~s[i])return aug(i),1;
                if(!~x[s[i]]){
                    x[s[i]]=i;
                    if(find(s[i],w))return 1;
                }
            }
        }
        return 0;
    }
    tp mc(int N,tp w[][MX]){
        n=N,CL(s,-1),CL(Y,0),R=0;
        F(n)X[i]=*max_element(w[i],w[i]+n);
        F(n){
            FF(n)x[j]=y[j]=-1,S[j]=INF;
            x[i]=-2,O=0;
            if(!find(i,w))while(!O){
                tp m=INF;
                FF(n)if(!~y[j])m=min(m,S[j]);
                FF(n){
                    if(~x[j])X[j]-=m;
                    if(~y[j])Y[j]+=m;
                    else S[j]-=m;
                }
                FF(n&&!O)if(!~y[j]&&!S[j]){
                    y[j]=f[j];
                    if(!~s[j])aug(j),O=1;
                    else x[s[j]]=j,O|=find(s[j],w);
                }
            }
        }
        F(n)R+=w[s[i]][i];
        return R;
    }
}G;
\end{lstlisting}
Další verze
\begin{lstlisting}[language=C++]
#define MX (20001)
#define ME (200000)
ll d[MX],C[ME],W[ME];
int V,E,l[MX],w[MX],X[ME],f[ME],g[ME]; 
struct cmpf{bool operator()(int a,int b){return d[a]^d[b]?d[a]<d[b]:a<b;}};
set<int,cmpf> S;
void ini(int n){V=n,E=0,fill(l,l+V,-1);}
void edge(int x,int y,ll c,ll w){
    f[E]=x,g[E]=y,C[E]=c,W[E]=+w,X[E]=l[x],l[x]=E++;
    f[E]=y,g[E]=x,C[E]=0,W[E]=-w,X[E]=l[y],l[y]=E++;
}
pll run(int F, int T) {
    ll S=0,O=0,Z;
    while(666){
        fill(d,d+V,1e18),d[F]=Z=0;
        while(!Z){
            Z=1;
            F(V)for(int e=l[i];~e;e=X[e])if(C[e]&&d[i]+W[e]<d[g[e]])
                d[g[e]]=d[i]+W[e],w[g[e]]=e,Z=0;
        }
        if(d[T]>=1e17/2)break;
        ll H=C[w[T]];
        for(int i=T;i^F;i=f[w[i]])H=min(H,C[w[i]]);
        for(int i=T;i^F;i=f[w[i]])
            C[w[i]]-=H,C[w[i]^1]+=H,S+=W[w[i]]*H;
        O+=H;
    }
    return {S,O};
}
\end{lstlisting}
\subsection{Minimální kostra directed grafu}
Zústanou nejlevnější cesty z rootu (\textsf{r}) do všech nodes (indexace od 0).
\\Dále je zde \textsf{N} (počet uzlů) a \textsf{L} (počet hran). [$MX$ / $ME$]
\\Složitost $N*L$
\\Hrany jsou uloženy v \textsf{E}.
\begin{lstlisting}[language=C++]
#define ME (1<<14)
#define MX (1001)
struct eg{int x,y,w;}E[ME];
ll dmst(int N,int L,int r){
    static int c[MX],b[MX],l[MX],o[MX],K,x;
    ll S=0;
    while(666){
        fill(c,c+N,INF),K=0;
        F(L)if(E[i].x^E[i].y&&E[i].w<c[E[i].y])
            c[E[i].y]=E[i].w,b[E[i].y]=E[i].x;
        c[r]=0;
        F(N)if(c[i]==INF) return -1;//NO WAY!
        F(N)S+=c[i];
        fill(l,l+N,-1),fill(o,o+N,-1);
        F(N){
            x=i;
            for(;x^r&&!~o[x];x=b[x])o[x]=i;
            if(x^r&&o[x]==i){
                while(!~l[x])l[x]=K,x=b[x];
                ++K;
            }
        }
        if(!K)return S;
        F(N)if(!~l[i])l[i]=K++;
        F(L){
            eg &e=E[i];
            if(l[e.x]^l[e.y])e.w-=c[e.y];
            e.x=l[e.x],e.y=l[e.y];
        }
        r=l[r],N=K;
    }
}
\end{lstlisting}
\subsection{MO na stromě}
Struktura přijme strom (po hranách) a jednotlivé query, které zpracuje a vypočítá ($offline$)
\begin{itemize}
\item \textbf{CLR}: Pročistí strom - OTESTOVAT!
\item \textbf{ADD}: Přidá hranu do stromu
\item \textbf{QY}: Přidá query ke zpracování
\item \textbf{GO}: Vypočítá jednotilivé query - složitost $O((N+Q)\sqrt{N})$
\end{itemize}
Dále je zde několik dalších funkcí, které se musí dopsat dle funkcionality.
\begin{itemize}
\item \textbf{add}: Query je provedeno na prvku s indexem \textsf{w} 
\item \textbf{add}: Query nebude provedeno na prvku s indexem \textsf{w}
\item \textbf{st}: Inicializace
\item \textbf{ans}: Vrátí výsledek, pokud je query provedeno nad zadaným intervalem.
\end{itemize}
Jakékoli další globální pole, které je při výpočtu využito, a další pomocné proměnné musí být též dopsány!
\begin{lstlisting}[language=C++]
#define LS 18
#define MX (1<<LS)
#define SQ (222)
struct MO{
    int b,e,a,i;
    bool operator<(const MO&r)const{return b/SQ^r.b/SQ?b/SQ<r.b/SQ:e<r.e;}
};
struct MOT{
    vi g[MX];
    ii Q[MX];
    MO T[MX];
    int C[MX],D[MX],P[MX][LS+1],L,l,S[MX],E[MX],A[MX<<1],a,b,e;
    void vnd(int u,int p,int d,int&l){
        *P[u]=p,D[u]=d++,A[l]=u,S[u]=l++;
        for(int i:g[u])if(i^p)vnd(i,u,d,l);
        A[l]=u,E[u]=l++;
    }
    int lca(int a,int b){
        if(D[a]>D[b])swap(a,b);
        int d=D[b]-D[a],s=0;
        while(d)b=d&1?P[b][s]:b,d>>=1,++s;
        for(int i(LS-1);~i;--i)
            if(P[a][i]^P[b][i])
                a=P[a][i],b=P[b][i];
        return a^b?*P[a]:a;
    }
    void CLR(){for(auto&h:g)h.clear();L=0;}//clr not tested
    void ADD(int a,int b){g[a].PB(b),g[b].PB(a);}
    void QY(int b,int e){Q[L++]={b,e};}
    void GO(int*O){
        vnd(0,-1,0,l=0),CL(C,0),st();
        F(LS)FF(l/2)P[j+1][i+1]=P[P[j+1][i]][i];
        F(L)if(S[Q[i].aa]>S[Q[i].bb])swap(Q[i].aa,Q[i].bb);
        F(L)if((a=lca(Q[i].aa,Q[i].bb))^Q[i].aa)T[i]={E[Q[i].aa],S[Q[i].bb],S[a],i};
            else T[i]={S[Q[i].aa],S[Q[i].bb],-1,i};
        sort(T,T+L),b=T[0].b-1,e=T[0].b-1;
        F(L){
            while(b>=T[i].b)pt(b--,1);
            while(e<T[i].e)pt(++e,1);
            while(b+1<T[i].b)pt(++b,-1);
            while(e>T[i].e)pt(e--,-1);
            if(~T[i].a)pt(T[i].a,1);
            O[T[i].i]=ans();
            if(~T[i].a)pt(T[i].a,-1);
        }
    }
    void pt(int u,int d){
        if((C[A[u]]+=d)^1)del(A[u]);
        else add(A[u]);
    }
    //MO
	//TODO
    void add(int w){
        //TODO
    }
    void del(int w){
        //TODO
    }
    int ans(){
        //TODO
    }
    void st(){
        //TODO
    }
}T;
\end{lstlisting}
\subsection{Mosty v grafu}
Výsledné mosty budou uloženy ve vektoru "B" (nemusí být uspořádány).
\\Vycleanovat \textbf{cn}
\begin{lstlisting}[language=C++]
#define MX (1<<14)
vii B;
vi G[MX];
int f[MX],t[MX],cn[MX],Z,N;
void add(int a,int b){
    if(a>b)return add(b,a);
    B.PB({a,b});
}
void dfs(int u,int p){
    cn[u]=1,t[u]=f[u]=++Z;
    for(auto&h:G[u])if(h^p){
        if(cn[h])f[u]=min(f[u],t[h]);
        else{
            dfs(h,u),f[u]=min(f[u],f[h]);
            if(f[h]>t[u])add(u,h);
        }
    }
}
#define CCL (CL(cn,Z=0));for(auto&h:G)h.clear();
\end{lstlisting}
Tento gadget z toho vytvoří \textsf{mostový} strom.
\begin{lstlisting}[language=C++]
int K,cl[MX];
vi g[MX],H[MX];
void dfs2(int u,int c){
    H[c].PB(u);
    for(auto i:G[u])if(!cl[i]++){
        if(B.count(minmax(u,i)))
            g[c].PB(++K),g[K].PB(c),dfs2(i,K);
        else dfs2(i,c);
    }
}
#define CAL (dfs(0,-1),*cl=1,dfs2(0,0))
#define CR CCL;for(auto&h:g)h.clear();CL(cl,K=0);B.clear();
\end{lstlisting}
\subsection{Nalezení nejmenší generující podmnožiny}
V množině $g[i]$ jsou uloženy prvky, na kterých je $i$ závislé a v $w[i]$ prvky, které jsou na něm závislé.
\\Po průběhu funkce budou všechny prvky generující množiny splňovat "$!w[i].empty()$" 
\begin{lstlisting}[language=C++]
void dl(void){
    int b(0),e(0),a;
    for(int i(0);i<n;++i)
        if(w[i].empty())
            q[e++]=i;
    while(b<e){
        a=q[b++];
        for(auto i(g[a].begin());i!=g[a].end();++i){
            w[*i].erase(a);
            if(w[*i].empty())
                q[e++]=*i;
        }
    }
}
\end{lstlisting}
\subsection{Nejkratší cesty}
Algoritmus nalezne cenu dvou nejkratších cest (tak aby byla jejich cena v součtu co nejmenší).
\\Indexování od 1
\\Počáteční node je vždy 1 a koncový vždy \textsf{N}
\\Složitost $O(|E|)$, kde \textsf{E} je počet hran.
\begin{lstlisting}[language=C++]
#define MX (2048)
int N,L,l[MX],p[MX],S[MX*MX],D[MX*MX],V[MX*MX],cn[MX*MX];
int ap(void){
    int a,b,c,d;
    F(N+1)l[i]=INF-1;
    l[1]=0;
    F(N+1)FF(L){
        if(cn[j])a=D[j],b=S[j],c=-V[j];
        else a=S[j],b=D[j],c=V[j];
        if((d=l[a]+c)<l[b])
            l[b]=d,p[b]=j;
    }
    return l[N];
}
void sc(void){
    F(L)D[i]+=N;
    FT(1,N+1)S[L]=k+N,D[L]=k,V[L++]=0;
    N<<=1;
}
int tpp(void){
    sc();//comment if just edge-disjoint
    F(L)cn[i]=0;
    int a=ap(),i(N);
    while(i!=1)cn[p[i]]=1,i=S[p[i]];
    return a+ap();
}
#define ade(A,B,C) (S[L]=A,D[L]=B,V[L++]=C)
\end{lstlisting}
Algoritmus pro nalezení cený druhé nejkratší cesty (její ceny - hledá se první, která má cenu jinou, než-li cesta nejkratší [pokud by nevadila stejná, zakomentovat první řádek v $ad$])
\\Složitost $O(V*log(E))$, kde \textsf{E} je počet hran a \textsf{V} počet vrcholů.
\begin{lstlisting}[language=C++]
#define MX (5000)
int cn[2][MX];
struct eg{
    eg(int V,int T):v(V),t(T){}
    int v,t;
    bool operator<(const eg&r)const{return v>r.v;}
};
vector<int> g[MX],v[MX];
bool ad(int u,int v){
    if(cn[0][u]==v)return 0;
    if(!~cn[0][u]||cn[0][u]>v)return cn[1][u]=cn[0][u],cn[0][u]=v,1;
    if(!~cn[1][u]||cn[1][u]>v)return cn[1][u]=v,1;
    return 0;
}
int dj(int f,int t){
    priority_queue<eg> q;
    q.push(eg(0,f)),CL(cn,-1);
    while(!q.empty()){
        int a(q.top().t),w(q.top().v);
        q.pop();
        if(!ad(a,w))continue;
        for(int i(0);i<(int)g[a].size();++i)
            q.push(eg(w+v[a][i],g[a][i]));
    }
    return cn[1][t];
}
#define ADD(A,B,V) (g[A].push_back(B),g[B].push_back(A),v[A].push_back(V),v[B].push_back(V))
\end{lstlisting}
Nalezení až \textsf{K} nejkratších cest z bodu \textsf{f}. 
\\Ceny cest do každého $node$ budou uloženy v \textsf{u}.
\\Cokoli se může opakovat
\\Složitost $O(EKlog(EK))$
\begin{lstlisting}[language=C++]
#define MX (101)
vii g[MX];
priority_queue<ii> q;
void dj(int f,vi*o,int K){
    q.push({0,f});
    while(!q.empty()){
        int u=q.top().bb,p=q.top().aa;
        q.pop(),o[u].PB(-p);
        for(auto&h:g[u])q.push({p-h.bb,h.aa});
        while(!q.empty()&&int(o[q.top().bb].size())==K)q.pop();
    }
}
\end{lstlisting}
Vytvoření sítě nejkratších cest z bodu \textsf{u}.
\\Původní graf je uložen v \textbf{G} [dá se stavět pomocí $ADD$].
\\Nový graf bude v \textbf{g}
\begin{lstlisting}[language=C++]
struct pr{
    int f,t,w,p;
    bool operator<(const pr&r)const{return w>r.w;}
};
int cn[MX];
priority_queue<pr> Q;
vii g[MX],G[MX];
void dj(int u){
    Q.push({-1,u,0,0});
    while(!Q.empty()){
        int u=Q.top().t,v=Q.top().w,p=Q.top().f,o=Q.top().p;
        Q.pop();
        if(!~cn[u]){
            cn[u]=v;
            if(~p)g[u].PB({p,o});
        }else{
            if(cn[u]==v)g[u].PB({p,o});
            continue;
        }
        for(auto&h:G[u])Q.push({u,h.aa,h.bb+v,h.bb});
    }
}
#define ADD(A,B,C) (G[A].PB({B,C}))
#define CLR F(MX)g[i].clear(),G[i].clear();CL(cn,-1);
\end{lstlisting}
\subsection{Odstraňování (sjednocování) komponent}
Funkce $con$ sjednotí dvě komponenty do jedné. Komponenty jsou identifikovány podle dvou jejích prvků.
\\Funce $geco$ zjistí komponentu prvku (nicméně pokud by se hned neupdatovalo[$C[a]=geco(a)$], může dojít až k linearitě této funkce).
\\Před spuštěním je nutné přiřadit všem komponentám hodnotu ($C[i]==i$).
\begin{lstlisting}[language=C++]
iota(C,C+N,0);//#include <numeric>
\end{lstlisting}
\begin{lstlisting}[language=C++]
int C[MX];
int geco(int a){
    return C[a]=(a==C[a]?a:geco(C[a]));
}
bool con(int a,int b){
    if(geco(a)==geco(b))return 0;
    return C[C[b]]=C[a],1;
}
\end{lstlisting}

\subsection{Ohodnocení stromu}
Každý uzel má nějaké ohodnocení (\textsf{P}) a seznam sousedů (\textsf{g}). 
\\Ve vektoru \textsf{v} bude pak uložena hodnota podstromu.
\\V \textsf{M} je celkové ohodnocení stromu a v \textsf{X} pak největší ohodnocení některého ze sousedů (celé větve).
\\Složitost $O(n)$
\begin{lstlisting}[language=C++]
#define PB(A,B) (g[A].push_back(B),v[A].push_back(0))
typedef long long ll;
ll P[MX],M[MX],X[MX];
vector<ll> g[MX],v[MX];
ll gt(ll u,ll p){
    ll S(0);
    F((ll)g[u].size())if(g[u][i]!=p)S+=v[u][i]=gt(g[u][i],u);
    return S+P[u];
}
void up(ll u,ll p,ll S){
    X[u]=S;
    ll SS(S+P[u]);
    F((ll)g[u].size())SS+=v[u][i];
    F((ll)g[u].size())
        if(g[u][i]==p)v[u][i]=S;
        else up(g[u][i],u,SS-v[u][i]),X[u]=max(X[u],v[u][i]);
    M[u]=SS;
}
\end{lstlisting}
Je nutné vybrat kořen (zde 1). Dále funkce přijímá rodiče (případně jeho hodnotu) - zde to musí být nulové vůči univerzu.
\begin{lstlisting}[language=C++]
PB(a,b),PB(b,a);
gt(1,-1);
up(1,-1,0);
\end{lstlisting}
\subsection{Orientace grafu [maximální]}
Ve struktuře \textsf{eg} jsou: 
\\\textsf{f} - z kterého uzlu.
\\\textsf{t} - do kterého uzlu.
\\\textsf{x} - platnost hrany.
\\\textsf{b} - zda-li byla hrana zorientována.
\\\textsf{p} - zda-li byla hrana zorientována původně.
\\Ve vektoru \textsf{g} jsou uloženy indexy do pole hran. Pokud tedy hledáme souseda, tak místo klasického $g[i]$ je nyní třeba $e[g[i]].t$
\\Složitost $O(E)$, kde $E$ je počet hran.
\begin{lstlisting}[language=C++]
#define MX 2048
#define EG (1<<22)
struct eg{  
    int f,t,x,b,p;
    void set(int F,int T,int X){
        f=F,t=T,x=X,b=0,p=X==2;
    }
}e[EG];  
int l[MX],d[MX],cn[MX],c;
vector<int> g[MX];
void dfs(int u,int r){
    int v;
    cn[u]=d[u]=l[u]=++c;  
    for(int i:g[u])  
        if((v=e[i].t)!=r){
            if(!d[v])
                dfs(v,u),l[u]=min(l[u],l[v]),e[i].b=e[i^1].b=l[v]>d[u];
            else if(cn[v]) 
                l[u]=min(l[u],d[v]);  
        }  
}  
void DFS(int u,int r){
    int v;
    cn[u]=d[u]=l[u]=++c;  
    for(int i:g[u])
        if((v=e[i].t)!=r&&e[i].x){
            e[i].x=1,e[i^1].x=0;  
            if(!d[v]){  
               DFS(v,u);  
               l[u]=min(l[u],l[v]);  
               if(l[v]>d[u])  
                   e[i].x=0,e[i^1].x=1;  
            }
            else if(cn[v])
                l[u]=min(l[u],d[v]);
        }
}
void tj(void){  
    memset(d,c=0,sizeof(d));  
    memset(cn,0,sizeof(cn));
    dfs(1,-1);
    memset(d,c=0,sizeof(d));  
    memset(cn,0,sizeof(cn));
    DFS(1,-1);
}
\end{lstlisting}
\begin{center}
Jak s grafem zacházet.
\end{center}
\begin{lstlisting}[language=C++]
int n,m,L;  
#define add(U,V,F) (g[U].push_back(L),e[L++].set(U,V,F))
L=0;
while(m--&&scanf("%d%d%d",&a,&b,&c))
  if(c==2)
    add(a,b,c),add(b,a,c);  
  else
    add(a,b,c),add(b,a,0);  

\end{lstlisting}
\subsection{Perfektní ohodnocené párování}
\textsf{g} je bipartitní graf, kde na $x$ souřadnici je jedna partita a na $y$ druhá.
\\Funkce $bm$ vrátí minimální hodnotu úplného párování (tedy nejlevnější spárování).
\\Algoritmus funguje pro $N\times N$ uzly - pro různé hodnoty by bylo třeba ho upravit.
\begin{lstlisting}[language=C++]
#define MX 128
int g[MX][MX],lx[MX],ly[MX],p[MX],n; 
bool sx[MX],sy[MX];
bool ap(int k){
    sx[k]=1; 
    F(n)if(!sy[i]&&(lx[k]+ly[i]==g[k][i]))
        if(sy[i]=1,!~p[i]||ap(p[i]))
            return p[i]=k,1;
    return 0; 
} 
int bm(void){ 
    F(n)FF(n)g[i][j]=-g[i][j];//if minimal! - inversion
    int d,S(0);
    CL(ly,0),CL(p,-1),CL(lx,-1);
    F(n)FF(n)if(lx[i]<g[i][j])lx[i]=g[i][j];
    FT(0,n)while(CL(sx,0),CL(sy,0),!ap(k)){
        d=INF-1;
        F(n)if(sx[i])FF(n)if(!sy[j])d=min(d,lx[i]+ly[j]-g[i][j]); 
        F(n){if(sx[i])lx[i]-=d;if(sy[i])ly[i]+=d;}
    }
    F(n)S+=g[p[i]][i]; 
//    return S;//maximal 
    return -S;// minimal
}
\end{lstlisting}
Perfektní párování, za předpokladu, že budeme hledat minimální maximální cenu použité hrany.
\\Funkci $mm$ lze nalézt v kapitole \textit{Maximální párování}
\\Složitost $H*log(INF)$, kde $H$ je složitost párování.
\\Funkce přijímá velikost obou partit \textsf{n} a matici \textsf{f}, která je stejná jako matice \textsf{g} u výše popsaného algoritmu.
\begin{lstlisting}[language=C++]
int mmn(int n,int f[MX][MX]){
    int B(0),E(INF),M;
    while(B+1<E){
        M=(B+E+1)>>1;
        F(MX)g[i].clear();
        F(n)g[MX-2].PB(i),g[i+n].PB(MX-1);
        F(n)FF(n)if(f[i][j]<=M)g[i].PB(j+n);
        if(mm(MX-2,MX-1)<n)B=M+1;
        else E=M;
    }
    M=B;
    F(MX)g[i].clear();
    F(n)g[MX-2].PB(i),g[i+n].PB(MX-1);
    F(n)FF(n)if(f[i][j]<=M)g[i].PB(j+n);
    return B+(mm(MX-2,MX-1)!=n);
}
\end{lstlisting}
\subsection{Planarita Grafu}
Funkce ověří, zda-li je graf (zadaný maticí \textbf{g}) planární. 
\\KK ověřuje K33/K5
\begin{lstlisting}[language=C++]
#define MX (20)
bool KK(int u,int*S,int d,int T){
    int t=0,z=0;
    F(u)if(S[i]==d)++t;
        else if(S[i])return 0;
        else ++z;
    return t==T&&t+z==u;
}
bool pln(int g[MX][MX],int N){
    static int S[MX],C;
    vii v;
    do{
        C=0;
        F(N){
            v.clear();
            FF(N&&v.size()<3u)if(g[i][j]&&i^j)v.PB({i,j});
            if(v.size()==1u)g[i][v[0].bb]=g[v[0].bb][i]=0;
            else if(v.size()==2u)
                g[i][v[0].bb]= g[v[0].bb][i]=g[i][v[1].bb]=g[v[1].bb][i]=0,
                g[v[0].bb][v[1].bb]=g[v[1].bb][v[0].bb]=1,C++;
        }
    }while(C);
    CL(S,0);
    F(N)FT(i+1,N)if(g[i][k])++S[k],++S[i];
    return !(KK(N,S,3,6)||KK(N,S,4,5));
}
\end{lstlisting}
\subsection{Počet Cest}
Nechť v matici \textsf{g} je graf (jedničky poud existuje hrana). Výstupem bude (opět v matici \textsf{g}) počet cest,které vedou u uzlu $i$ do uzlu $j$.
\\Pokud existuje nekonečno cest (díky cyklu), v matici bude uloženo $-1$
\\Složitost $O(N^3)$ (pozor na přetečení pro matice větší než 30!)
\begin{lstlisting}[language=C++]
void np(int N,int g[][MX]){
    FT(0,N)F(N)FF(N)g[i][j]+=g[i][k]*g[k][j];
    FT(0,N)if(g[k][k])F(N)FF(N)if(g[i][k]&g[k][j])g[i][j]=-1;
}
\end{lstlisting}
Minimální počet cest, který je potřebný k projití všech uzlů grafu (graf je uni-directional)
\\$ME$ je třeba přestřelit
\begin{lstlisting}[language=C++]
#define MX 1001
#define ME 22000
struct eg{int f,t,x;}E[ME];
int H[MX],C,O[MX],L,w[MX],D[MX],K,Q[MX],b,e,M[MX];
bool cn[MX],P[MX],U[MX];
vi S,T[MX],G[MX];
#define CLR C=0,CL(H,-1);
void ade(int u,int v){E[C]={u,v,H[u]},H[u]=C++;}
void tj(int u,int f){
    int v;
    w[u]=D[u]=++K,S.PB(u),P[u]=1;
    for(int i=H[u];~i;i=E[i].x){
        v=E[i].t;
        if(!D[v])tj(v,u),w[u]=min(w[u],w[v]);
        else if(P[v])w[u]=min(w[u],D[v]);
    }
    if(w[u]==D[u]){
        ++L;
        do v=S.back(),S.pop_back(),P[v]=0,O[v]=L;while(u^v);
    }
}
void MM(int l,int r){
    CL(w,K=L=0),CL(D,0),CL(O,0),CL(P,0);
    FT(l,r+1)if(!D[k])tj(k,-1);
}
void bfs(int u){
    CL(cn,0),e=cn[u]=1,*Q=u,b=-1;
    while(++b<e)
        for(auto&v:T[Q[b]])if(!cn[v]++)
            Q[e++]=v,ade(u,v);
}
void SO(){
    for(auto&h:G)h.clear();
    F(C)if(O[E[i].f]^O[E[i].t])
        G[O[E[i].f]].PB(O[E[i].t]);
}
int dfs(int u){
    for(auto&v:G[u])if(!U[v]++&&(!~M[v]||dfs(M[v])))
        return M[v]=u,1;
    return 0;
}
int sl(int N){
    int r=0;
    FT(1,N+1)bfs(k);
    MM(1,N),SO(),CL(M,-1);
    FT(1,L+1)CL(U,0),r+=dfs(k);
    return L-r;
}
#define INI for(auto&h:T)h.clear();CLR;
#define ADD(A,B) T[A].PB(B)
\end{lstlisting}
\subsection{Počet uzlů, do kterých se vstoupí právě po K tazích}
Nechť začínáme v uzlu $u$, otázkou je, v kolika/jakých uzlech budu po právě $K$ krocích (pokud jsou hrany obousměrné, pak algoritmus nemá příliž smysl).
\\$MM$ je počet uzlů
\\$LG$ je logaritmus počtu kroků (raději přestřelit trochu)
\\$SQ$ je velikost bitsetu (typicky $\dfrac{MM}{64}+1$)
\\Funkce $pre$ je předpočet. Vstupem je počet $node$ a matice sousednosti.
\\Funkce $gt$ naleznevýsledek z node $u$ po $K$ krocích, a výsledky budou uloženy v bitsetu $o$.
\\Složitost $pre$ je  $O(LG*N^3/64)$ (rychlejší pro řidké grafy)
\\Složitost $gt$ je $O(N*log(K))$ (rychlejší pro řidké grafy).
\begin{lstlisting}[language=C++]
#define MM 500
#define LG 35
#define SQ (8)
struct bs{
    ll A[SQ];
    void clr(){CL(A,0);}
    void tr(int H){F(H>>6)A[i]=-1;FT(H-(H&63),H)ad(k);}
    bool is(bs&r){F(SQ)if(A[i]&r.A[i])return 1;return 0;}
    void operator|=(bs&r){F(SQ)A[i]|=r.A[i];}
    void operator&=(bs&r){F(SQ)A[i]&=r.A[i];}
    void operator^=(bs&r){F(SQ)A[i]^=r.A[i];}
    void ad(int u){A[u>>6]|=1ull<<(u&63);}
    void cg(int u){A[u>>6]^=1ull<<(u&63);} 
    bool ct(int v){return (A[v>>6]>>(v&63))&1;}
    int bt(){int l(0);F(SQ)l+=__builtin_popcountll(A[i]);return l;}
    bool dna(bs&r,int W=SQ){F(W)if(A[i]&r.A[i])return 1;return 0;}
    int xt(int u){
        while(++u&63)if((A[u>>6]>>(u&63))&1)return u;
        while(u<SQ<<6&&!A[u>>6])++u;
        if(u==SQ<<6)return -1;
        while(!ct(u))++u;
        return u;
    }
}G[LG][MM],t;
void pre(int N,bs*g){
    F(N)G[0][i]=g[i];
    FT(1,LG)F(N){
        G[k][i].clr();
        int v=-1;
        while(~(v=G[k-1][i].xt(v)))G[k][i]|=G[k-1][v];
    }
}
void gt(int u,ll K,bs&o){
    o.clr(),o.ad(u),u=0;
    while(K){
        if(K&1){
            t.clr();
            int v=-1;
            while(~(v=o.xt(v)))t|=G[u][v];
            o=t;
        }
        ++u,K>>=1;
    }
}
\end{lstlisting}
\subsection{Průměr stromu}
Spočte délku nejdelší možné cesty v grafu
\\Složitost $O(N)$
\begin{lstlisting}[language=C++]
#define MX 10001
int D[MX];
vi g[MX];
void dfs(int u,int p=-1){for(auto&h:g[u])if(h^p)D[h]=D[u]+1,dfs(h,u);}
int dm(int N) {
    dfs(*D=0);
    int p=max_element(D,D+N)-D;
    D[p]=0,dfs(p);
    return *max_element(D,D+N);
}
#define CLR for(auto&h:g)h.clear();
\end{lstlisting}
\subsection{Silně Spojité Komponenty}
Redukce silně spojitých komponent do jedné.
\\Hrany komponent budou v \textsf{G} a zpětné hrany v \textsf{R}.
\\Redukce proběhne pomocí funkce $ini$. Návratovou hodnotou je počet nových komponent a vstupní hodnotou je původní počet uzlů.
\\Složitost $O(N)$ (konstanta je poměrně větší)
\begin{lstlisting}[language=C++]
#define MX (100005)
vi g[MX],G[MX],e[MX],R[MX];
int cn[MX],C[MX],I[MX],H[MX],L;
void CLR(int N=MX){L=0;F(N)g[i].clear(),e[i].clear(),G[i].clear(),R[i].clear(),cn[i]=I[i]=0;}
void dfs1(int x){
    cn[x]=1;
    for(auto h:g[x])if(!cn[h])dfs1(h);
    H[L++]=x;
}
void dfs2(int x,int c){
    cn[x]=0,C[x]=c;
    for(auto h:e[x])if(cn[h])dfs2(h,c);
}
#define ADD(A,B) (g[A].PB(B),e[B].PB(A))
int ini(int N){
    F(N)if(!cn[i])dfs1(i);
    int I(0);
    for(int i(L-1);~i;--i)if(cn[H[i]])dfs2(H[i],++I);
    F(N)for(auto&h:g[i])if(C[i]!=C[h])G[C[i]-1].PB(C[h]-1),R[C[h]-1].PB(C[i]-1);
    //F(I)sort(G[i].begin(),G[i].end()),G[i].resize(unique(G[i].begin(),G[i].end())-G[i].begin());
    return I;
}
\end{lstlisting}
\subsection{SPFA}
Funkce na hledání nejkratší cesty z uzlu $s$.
\\Výstupní délky budou uloženy v $d$.
\\Detecke záporného cyklu pomocí "počtu navštívení". (Vrátí false pokud nalezne záporný cyklus).
\\Složitost $O(N^3)$
\begin{lstlisting}[language=C++]
#define MX (333)
ll G[MX][MX],d[MX],cn[MX];
int SPFA (int N,int s){
    static int Q[MX*MX];
    F(N)if(G[i][i]<0)return 0;
    ll b(-1),e(1),P;
    CL(Q,0);CL(cn,0);
    F(N)d[i]=INF;
    d[*Q=s]=0; 
    cn[s]=1; 
    while(++b<e){
        P=Q[b]; 
        F(N)if(d[P]+G[P][i]<d[i]){ 
            d[i]=d[P]+G[P][i];
            if(!cn[i]){ 
                cn[Q[e++]=i]=1; 
                if(e==MX*MX)return 0;
            } 
        } 
        cn[P]=0;
    } 
    return  1 ; 
}
\end{lstlisting}
Funkce $spfa$ prohledává graf z uzlu - návratovou hodnotou je nejvetší hodnota, kterou lze dosáhnout z bodu \textsf{f}. Pokud je zde kladný cyklus, návratová hodnota bude \textsf{-1}.
\\Složitost $O(N^3)$ 
\begin{lstlisting}[language=C++]
#define MX (101)
#define EG (10001)
int p[EG],e[MX],g[EG],O,cn[MX],V[EG],q[MX*MX],qp[MX*MX],T[MX],W[MX];
int spfa(int f,int N){
    int b=-1,E=1,a,P,X=0;
    fill(W,W+N,-INF),CL(T,0),W[*q=f]=0;
    while(++b<E){
        a=q[b],X=max(X,P=qp[b]);
        if(W[a]>P)continue;
        for(int d(e[a]);~d;d=p[d])if(W[g[d]]<P+V[d]){
            if(++T[g[d]]>N)return -1;
            q[E]=g[d],W[g[d]]=qp[E++]=P+V[d];
        }
    }
    return X;
}
#define ADD(A,B,C) (p[O]=e[A],g[O]=B,V[O]=C,e[A]=O++)
#define CLR (CL(e,-1),O=0,CL(cn,0))
\end{lstlisting}
\subsection{Stabilní párování}
Funkce přijme matici \textsf{g} ($[2*MX][MX]$). Dále musí být v \textsf{N} počet prvků obou partit.
\\Matice \textsc{g} je vyplněna vzestupně, podle preferencí $k$-tého člena (první partita je značena $0-N-1$ a druhá $N-2N-1$).
\\Výstupem funkce je pole \textsf{W}, ve kterém je párování (pár pro $k$-tý člen). Výstup je optimálním stabilním párováním pro první partitu (seřazený dle druhé partity).
\\Složitost $O(N^2)$
\begin{lstlisting}[language=C++]
#define MX (32)
int N,W[MX];
bool pf(int g[][MX],int w,int m,int m1){
    F(N)if(g[w][i]==m1)return 1;
        else if(g[w][i]==m)return 0;
    return 0;//FAIL
}
void stp(int g[][MX]){
    static bool f[MX];
    CL(W,-1),CL(f,0);
    int S(N);
    while(S){
        int m(0),w,m1;
        while(m<N&&f[m])++m;
        F(N&&!f[m])if(!~W[(w=g[m][i])-N])
                W[w-N]=m,f[m]=S--;
            else if(!pf(g, w, m, m1=W[w-N]))
                W[w-N]=m,f[m]=1,f[m1]=0;
    }
}
\end{lstlisting}
\begin{center}
Příklad uložení do matice \textsf{g}
\end{center}
\begin{lstlisting}[language=C++]
int g[2*MX][MX]=
       {{7, 5, 6, 4},
        {5, 4, 6, 7},
        {4, 5, 6, 7},
        {4, 5, 6, 7},
        {0, 1, 2, 3},
        {0, 1, 2, 3},
        {0, 1, 2, 3},
        {0, 1, 2, 3},
    };
\end{lstlisting}
\subsection{Stoer Wagner}
Minimální globální řez grafem.
\\Vstupními parametrem je velikost grafu.
\\Výstupem je velikost minimálního řezu grafem (tedy minimální váha hran, taková, že po jejich rozpojení zbydou z grafu dvě poloviny).
\\Složitost $O(n^3)$
\begin{lstlisting}[language=C++]
#define MX (512)
ll g[MX][MX];
ll sw(ll n){
    static bool a[MX];
    static ll v[MX],w[MX],B,p;
    iota(v,v+n,0);
    B=1LL<<60;
    while(n>1){
        a[*v]=1;
        FT(1,n)a[v[k]]=0,w[k]=g[p=*v][v[k]];
        FT(1,n){
            int zj=-1;
            FT(1,n)if(!a[v[k]]&&(!~zj||w[k]>w[zj]))zj=k;
            a[v[zj]]=1;
            if(k==n-1){
                B=min(B,w[zj]);
                F(n)g[v[i]][p]=g[p][v[i]]+=g[v[zj]][v[i]];
                v[zj]=v[--n];
                break;
            }
            p=v[zj];
            FT(1,n)if(!a[v[k]])w[k]+=g[v[zj]][v[k]];
        }
    }
    return B;
}	
\end{lstlisting}
\subsection{Střed stromu}
Algoritmus nalezne střed stromu uloženého v \textsf{g}.
\\Vstupními parametry jsou velikost grafu a kořen.
\\Výstupem je pak pár středu (či středů). Pokud je střed jeden, pak je druhý člen páru "-1".
\\Složitost $O(n)$
\begin{lstlisting}[language=C++]
#define MX (100009)
vi g[MX];
void dw(int u,int p,int d,int *D){
    D[u]=d;
    for(auto i:g[u])if(i^p)dw(i,u,d+1,D);
}
ii ctr(int N,int l=0){
    static int D[MX],U[MX],d;
    ii B;
    dw(l,-1,0,D),dw(max_element(D,D+N)-D,-1,0,D);
    dw(l=max_element(D,D+N)-D,-1,0,U),d=D[l]>>1;
    F(N)if(D[i]==U[i]&&D[i]==d)return {i,-1};
    F(N)if(D[i]==d&&U[i]==d+1)B.bb=i;
        else if(D[i]==d+1&&U[i]==d)B.aa=i;
    return B;
}
\end{lstlisting}
Nalezení největší vzdálenosti mezi uzly (v \textsf{g} jsou cílový uzel a cena).
\\Výsledek bude uložen v \textsf{R}
\begin{lstlisting}[language=C++]
vii g[MX];
int R;
int dfs(int u,int p){
    int A(0),B(0),a;
    for(auto&h:g[u])if(h.aa!=p){
        a=dfs(h.aa,u)+h.bb;
        if(a>A)B=A,A=a;
        else if(a>B)B=a;
    }
    R=max(A+B,R);
    return A;
}
\end{lstlisting}
Obdobně v neohodnoceném grafu.
\begin{lstlisting}[language=C++]
#define MX (1<<17)
vi g[MX];
int R;
int dfs(int u,int p){
    int A(0),B(0),a;
    for(auto&h:g[u])if(h^p){
        a=dfs(h,u)+1;
        if(a>A)B=A,A=a;
        else if(a>B)B=a;
    }
    R=max(A+B,R);
    return A;
}
\end{lstlisting}
\subsection{Tarjan}
Máme strom (\textsf{g} obsahuje hrany a \textsf{gv} jejich váhy) a dále máme \textit{query} dotazů na vzdálenosti dvou uzlů (uloženo v \textsf{q} - v \textsf{qn} je pak jejich pořadí).
\\Po proběhnutí algoritmu budou v \textsf{A} uloženy vzdálenosti z uzlů.
\\Složitost $O(n+m)$ (počet uzlů nebo \textit{query}).
\begin{lstlisting}[language=C++]
vector<int> g[1<<17],q[1<<17],qn[1<<17];
vector<long long> gv[1<<17];
int n,pr[1<<17],cn[1<<17];
long long d[1<<17],A[1<<17];
int gt(int nd){
    return ~pr[nd]?pr[nd]=gt(pr[nd]):nd;
}
void tj(int nd){
    cn[nd]=1;
    for(int i(0);i<(int)q[nd].size();++i)
        if(cn[q[nd][i]])
            A[qn[nd][i]]=d[nd]+d[q[nd][i]]-2*d[gt(q[nd][i])];
    for(int i(0);i<(int)g[nd].size();++i)
        if(!cn[g[nd][i]])
            d[g[nd][i]]=d[nd]+gv[nd][i],tj(g[nd][i]),pr[g[nd][i]]=nd;
}
memset(pr,-1,n<<2);
memset(cn,0,n<<2);
\end{lstlisting}
\subsection{Topologické seřazení}
Nechť v \textsf{g} je uložen \texttt{DAG}, pak po provedení $ts$ bude v \textsf{T} topologicky seřazený graf.
\\$dfs$ lze pak znovu použít jako obarvovací funkce
\\Složitost $O(N)$
\begin{lstlisting}[language=C++]
#define MX (1<<14)
vi g[MX];
int T[MX],L,cn[MX],S;
void dfs(int u,bool x=0){
    if(cn[u]++)return;
    F((ll)g[u].size())dfs(g[u][i],x);
    if(x)T[L++]=u;
}
#define ts(N) F(N)if(!cn[i])dfs(i,1);F(N>>1)swap(T[i],T[N-i-1]);
#define CLR F(N)g[i].clear();L=0;CL(cn,0);
\end{lstlisting}
\subsection{Traveling Salesman Problem [TSP]}
Mějme \textsf{N} uzlů a chceme je všechny spojit do okruhu (tedy cyklus přes všechny uzly) - jaká bude jeho nejmenší možná délka?
\\V poli \textsf{g} je matice grafu.
\\Složitost $O(n^22^n)$
\begin{lstlisting}[language=C++]
int dp[1<<17][16],N,g[16][16];
int TSP(void){
    int p,a(INF);
    CL(dp,-1);
    dp[1][0]=0;
    F(1<<N)FF(N)if(~dp[i][j])FT(1,N)
        if(!(i&(1<<k))){
            p=(i|(1<<k));
            if(!~dp[p][k])dp[p][k]=dp[i][j]+g[j][k];
            dp[p][k]=min(dp[p][k],dp[i][j]+g[j][k]);
        }
    for(int i(1);i<N;++i) 
        if(~dp[(1<<N)-1][i]) 
            a=min(a,dp[(1<<N)-1][i]+g[i][0]);
    return a==INF?0:a;
}
\end{lstlisting}
Pokud se jedná o $tsp$ na rovině, kde žádné dva body nemají stejné \textsf{x}, bude vypadat $tsp$ následovně.
\\V \textsf{a} jsou uloženy koordináty bodů, které chceme navštívit.
\begin{lstlisting}[language=C++]
#define MX 128
int N;
struct pt{
    int x,y;
    bool operator<(const pt&r)const{return x<r.x;}
}a[MX];
double dst(double AX,double AY,double BX,double BY){
    return sqrt(pow(AX-BX,2)+pow(AY-BY,2));
}
double tsp(void){
    static double g[MX][MX],dp[MX][MX];
    //sort(a,a+N);
    F(N)FT(i,N)g[i][k]=g[k][i]=dst(a[i].x,a[i].y,a[k].x,a[k].y),dp[i][k]=dp[k][i]=1<<30;
    dp[0][0]=0;
    F(N)FF(i)dp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+g[i][j]),
             dp[i][j]=min(dp[i][j],dp[i-1][j]+g[i-1][i]);
    return dp[N-1][N-2]+g[N-1][N-2];
}
\end{lstlisting}
\subsection{Tree Recovery}
Nechť v \textsf{A} je pre-order a v \textsf{B} je in-order, pak návratovou hodnotou bude post-order.
\begin{lstlisting}[language=C++]
string A,B;
string rec(int b,int e,int u,int v){
    string r;
    int l(B.find(A[b])),h(-1);
    if(l^u){
        h=b;
        while(h<=e&&(int)B.find(A[h+1])<l)++h;
        if(h^b)r+=rec(b+1,h,u,l-1);
    }
    if(l^v){
        if(~h)r+=rec(h+1,e,l+1,v);
        else r+=rec(b+1,e,l+1,v);
    }
    r+=A[b];
    return r;
}
\end{lstlisting}
Nalezení post-order z pre-order. Do \textsf{CAL} se hodí počet nodes, preorder a výsledné pole.
\\Složitost $O(Nlog^2(N))$
\begin{lstlisting}[language=C++]
#define LG (14)
#define MX (1<<LG)
int T[MX][LG+1],w;
void ST(int*A,int n){
    F(n)*T[i]=A[i];
    for(int j=1,k=2;k<=n;++j,k<<=1)
        F(n+1-k)T[i][j]=max(T[i][j-1],T[i+(k>>1)][j-1]);
}
void PO(int i,int n,int*A,int&l,int*o){
    int k,t,s=i,c=-1;
    if(i>n)return;
    while(666){
        for(k=1,t=2;s+t<=n;++k,t<<=1)
            if(T[s][k]>*T[s]){c=1;break;}
        if(*T[s]>*T[i]){c=0;break;}
        if(!~c&&s>n)break;
        s+=t>>1,c=-1;
    }
    if(~c)PO(i+1,s-1,A,l,o),PO(s,n,A,l,o);
    else PO(i+1,n,A,l,o);
    o[l++]=A[i];
}
#define PP(N,A,O) ST(A,N),PO(0,N-1,A,w,o)
\end{lstlisting}
\subsection{Union Find}
\begin{lstlisting}[language=C++]
int C[MX],R[MX],W;
int geco(int a){return C[a]=(a==C[a]?a:geco(C[a]));}
bool con(int a,int b){
    if(geco(a)==geco(b))return 0;
    if(R[C[a]]>R[C[b]])C[C[b]]=C[a];
    else R[C[b]]+=R[C[a]]==R[C[b]],C[C[a]]=C[b];
    return --W,1;
}
#define CLR (iota(C,C+N,0),CL(R,0),W=N)
\end{lstlisting}
Struktura která podporuje dva typy query: Nastavit přátele a nastavit nepřátele.
\\Funguje to obdobně jako komponenty - je to tranzitivní: Nepřítel nepřítele je přítel / Přítel přítele je přítel / Nepřítel přítele je nepřítel.
\\$setFr$ nastaví přítele
\\$setEn$ nastaví nepřítele
\begin{lstlisting}[language=C++]
#define MX (1<<14)
#define CK g[k]
#define CC g[l]
#define TS MX-1
int g[MX],E[MX],N[MX],cn[MX],r;
vi e[MX];
void ae(int k,int l){e[k].PB(l),e[l].PB(k);}
void cl(int u,int f,int t,int a){
    if(cn[u]==r)return;
    cn[u]=r;
    if(g[u]==f)g[u]=t;
    else g[u]=a;
    for(auto&i:e[u])cl(i,f,t,a);
}
bool setFr(int k,int l){
    if(N[CK]<N[CC])return setFr(l,k);
    if(CK==E[CC])return 0;
    if(g[k]!=g[l]){
        if(E[CK]==TS)E[CK]=E[CC],E[E[CK]]=CK;
        N[CK]+=N[CC],++r,cl(l,CC,CK,E[CK]);
    }
    ae(k,l);
    return 1;
}
bool setEn(int k,int l){
    if(N[CK]<N[CC])return setEn(l,k);
    if(CK==CC)return 0;
    if(CK!=E[CC]){
        N[CK]+=N[CC],++r;
        cl(l,CC,E[CK]==TS?CC:E[CK],CK);
        if(E[CK]==TS)E[CK]=CC,E[CC]=CK;
    }
    ae(k,l);
    return 1;
}
void clr(int n=MX){
    iota(g,g+n,0),fill(N,N+n,1),fill(E,E+n,TS);
    F(n)e[i].clear();
}
\end{lstlisting}
\subsection{Velikost největší komponenty}
Zapsáno v \textsf{C} notaci
\begin{lstlisting}[language=C++]
#define MX (30000)
#define EG (500000*2)
int p[EG],e[MX],g[EG],O,cn[MX];
int dfs(int u){
    if(cn[u]++)return 0;
    int S(1);
    for(int d(e[u]);~d;d=p[d])S+=dfs(g[d]);
    return S;
}
#define ADD(A,B) (p[O]=e[A],g[O]=B,e[A]=O++)
#define CLR (CL(e,-1),O=0,CL(cn,0))
//B=0;F(N)B=max(B,dfs(i));
\end{lstlisting}
\newpage\section{Kombinatorika a Pravděpodobnost (Matematika)}

\subsection{Domino na šachovnici}
Počet možností vyskládání domina na a*b šachovnici.
\\Využívá vzorce: $\prod_{j=1}^a\prod_{i=1}^b(4*cos^2(\dfrac{j\pi}{a+1})+4*cos^2(\dfrac{i\pi}{b+1}))^{0.25}$
\\Jedná se o aproximaci - je vhodné přičíst 0.5
\begin{lstlisting}[language=C++]
double til(int a,int b){
    if(a&1&&b&1)return 0;
    long double tt(1);
    F(a)FF(b)tt*=pow((4*pow(cos(M_PI*(j+1)/(b+1)),2)+4*pow(cos(M_PI*(i+1)/(a+1)),2)),0.25);
    return tt;
}
\end{lstlisting}
\subsection{Hod mincí}
Kolikrát v $n$ počtu hodů mincí padne $r$ hlav za sebou?
\begin{lstlisting}[language=C++]
BigInteger [][][]dp=new BigInteger[128][128][128];
public BigInteger dyn(int n, int r) {
    if(n<0||r<0)
        return BigInteger.ZERO;
    if(dp[s][n][r]!=null)
        return dp[s][n][r];
    if(r==0)
        return dp[s][n][r]=new BigInteger("2").pow(n);
    return dp[s][n][r]=dyn(n-1,s).add(dyn(n-1,r-1));
}
\end{lstlisting}
\subsection{Josefův problém (a jeho variace)}
Josefův problém s proměnnou rovnu \textit{i}-tému prvočíslu.
\\V \textsf{P} jsou uložena prvočísla.
\\Používá se postup odzadu, kdy se rekonstruuje od posledních 2 přeživších.
\\Složitost $O(n)$
\begin{lstlisting}[language=C++]
int S(0),a(n-2),m(2);
while(m<=n)
    S=((S+P[a--])%m++);
return S+1;
\end{lstlisting}
Klasický Josef (případně přičíst +1).
\\Složitost $O(n)$
\begin{lstlisting}[language=C++]
int jp(int N,int K){
    int r(0);
    F(N)r=(r+K)%(i+1);
    return r;
}
\end{lstlisting}
Josef, při kterém se vždy přite $K$ a poté odečtě $K$
\\Složitost $O(nlog(N))$
\begin{lstlisting}[language=C++]
#define MX (1<<22)
int S,P,T[MX],D;
void ini(int u,int b,int e){
    T[u]=e-b+1;
    if(b^e)ini(u<<1,b,(b+e)>>1),ini(u<<1|1,(b+e)/2+1,e);
}
int gt(int u,int b,int e,int k){
    --T[u];
    if(b==e)return b;
    if(k<=T[u<<1])return gt(u<<1,b,(b+e)>>1,k);
    return gt(u<<1|1,(b+e)/2+1,e,k-T[u<<1]);
}
int js(int N,int K){
    ini(1,1,N),D=K;
    F(N){
        P=gt(1,1,N,K);
        if(i+1==N)return P;
        S=T[1],D=-D,K=(D>0?K-2+D:K+S+D+1)%S;
        K+=S,K%=S,K=K?K:S;
    }
    assert(0);
}
\end{lstlisting}
\subsection{Kombinační číslo}
Funkce $pre$ udělá $O(MXlog(MX))$ předpočet. Poté se zavoláním funkce $C$ vypočte kombinační číslo v $O(1)$.
\begin{lstlisting}[language=C++]
#define MX (1<<19)
#define MOD (1000000007)
ll pw(ll n,ll k){
    ll r(1);
    while(k){
        if(k&1)r*=n,r%=MOD;
        n*=n,n%=MOD;
        k>>=1;
    }
    return r;
}
ll inv(ll a){return pw(a,MOD-2);}
ll f[MX]={1},I[MX]={1};
void pre(){FT(1,MX)I[k]=inv(f[k]=f[k-1]*k%MOD);}
ll C(int N,int K){return N<K?0:f[N]*I[K]%MOD*I[N-K]%MOD;}
\end{lstlisting}
\subsection{Možnosti kombinace čísla z intervalů}
Vrátí počet možností, kterými lze nakombinovat číslo \textsf{N} z \textsf{K} intervalů, které mají spodní hranici \textsf{b} a horní \textsf{e}. (modulo $MOD$)
\\Předem je nutn zavolat $ini()$
\\Složitost $O(2^KK)$
\begin{lstlisting}[language=C++]
#define MOD (100000007)
#define MX (1000001)
ll f[MX]={1};
void ini(){FT(1,MX)f[k]=k*f[k-1],f[k]%=MOD;}
ll gcdE(ll a,ll m,ll &x,ll &y){
    if(!a)return x=0,y=1,m;
    ll u,v,g(gcdE(m%a,a,u,v));
    return x=v-(m/a)*u,y=u,g;
}
ll inv(ll a,ll m=MOD){
    ll x,y,g(gcdE(a,m,x,y));
    return g==1?(x%m+m)%m:-1;
}
ll cc(ll n,ll r){
    return (f[n]*inv((f[r]*f[n-r])%MOD))%MOD;
}
int ps(int N,int K,int*b,int*e){
    ll S(0),E(0),A(0),u,c,P;
    F(K)S+=b[i],E+=e[i];
    if(S>N||E<N)return 0;
    F(1<<K){
        u=c=0;
        FF(K)if((i&1<<j))++c,u+=e[j]-b[j]+1;
        P=N-S-u+K-1;
        if(P>=K-1)A+=cc(P,K-1)*(c&1?-1:1),A+=MOD,A%=MOD;
    }
    return A;
}
\end{lstlisting}
\subsection{Možnosti platby}
V \textsc{mn} jsou \textsc{b} (hodnota bankovky) a \textsc{c} počet bankovek. V al je pak počet těchto skupin.
\\Sort nezajišťuje správnost ale rychlost
\\Na konci budou v dp(da) true, pokud lze toto číslo vytvořit a cp(ca) nejmenší počet použitých transakcí. V m(ma) pak nejvyšší dosažená hodnota.
\\memset(ca,63,1<<23) - nastaví do intu \textbf{1061109567}
\begin{lstlisting}[language=C++]
struct mn{
    int b,c;
    bool operator<(const mn&r)const{return b<r.b;}
}a[512];
int da[1<<21],ca[1<<21],al,ma;
void fill(mn *a,int l,int *dp,int &m,int *cp){
    for(int j(0);j<l;++j)
        for(int k(0);k<a[j].c;++k)
            for(int i(m);~i;--i)
                if(dp[i])
                    dp[i+a[j].b]=1,cp[i+a[j].b]=min(cp[i+a[j].b],1+cp[i])
                    ,m=max(m,i+a[j].b);
}
sort(a,a+al);
memset(da,0,1<<23);
memset(ca,63,1<<23);
ca[0]=0,da[0]=1;
fill(a,al,da,ma,ca);
\end{lstlisting}
O něco rychlejší verze na vygenerování T/F (dosažitelné/nedosažitelné) pro všechny prvky až do hodnoty \textsf{X}.
\begin{lstlisting}[language=C++]
struct mn{
    int b,c;
    bool operator<(const mn&r)const{return b*c<r.b*r.c;}
}a[512];
#define MX (1<<17)
void fill(mn *a,int l,int *dp,int &m,int X){
    static int W[MX];
    for(int i(0);i<=X;++i)
        dp[i]=0,W[i]=-1;
    dp[0]=1;
    for(int j(m=0);j<l;++j)
        for(int i(m);~i;--i)
            for(int k(0),b(a[j].b);k<a[j].c&&i+b<=X&&W[i+b]!=j;++k,b+=a[j].b)
                if(dp[i])
                    dp[i+b]=1,m=max(m,i+b),W[i+b]=j;
}
\end{lstlisting}
Vygenerování minimálního počtu mincí potřebných k zaplacení částky (počty mincí jsou neomezeny).
\\MX je maximální počet, který nás zajímá
\\Složitost $O(MX*l)$, kde $l$ je počet mincí.
\begin{lstlisting}[language=C++]
#define MX 2001
void fill(int *b,int l,int *dp){
    for(int j(1);j<MX;++j)
        dp[j]=1<<28;
    for(int i(dp[0]=0);i<l;++i)
        for(int j(b[i]);j<MX;++j)
            dp[j]=min(dp[j],dp[j-b[i]]+1);
}
\end{lstlisting}
Pokud může protistrana vracet, pak za to přibude i:
\\Pozor - pokud využíváme i tuto funkcionalitu, nemusí být \textsf{MX} rovno maximální cenně (může být i několikanásobně vyšší)
\begin{lstlisting}[language=C++]
for(int i(0);i<l;++i)
    for(int j(MX-1-b[i]);j;--j)
        dp[j]=min(dp[j],dp[j+b[i]]+1);
\end{lstlisting}
Vygenerování nejmenšího počtu platidel (i s počty platidel)
\\Složitost $O(nk)$.
\\V t[n] je na první pozici uložen počet platidel;
\\V polích \textsf{p} a \textsf{P} jsou uloženy informace o rodičích (rodič a index platidla), takže lze lehce dohledat, jak byla částka zaplacena.
\begin{lstlisting}[language=C++]
typedef long long ll;
ll t[MX],d[MX],p[MX],P[MX];
void ct(int n,int k){
    memset(t,-1,sizeof(t));t[0]=0;p[0]=-1;
    F(k)FT(d[i],n+1)
        if(~t[k-d[i]]&&(!~t[k]||t[k]>1+t[k-d[i]]))t[k]=1+t[k-d[i]],p[k]=k-d[i],P[k]=i;
}
\end{lstlisting}
Tato funkce (s kooperací s funkcí předchozí) nalezce platidla použitá k zaplacení částky (v poly \textsf{C} je uložen počet použitých platidel - indexy stejné, jako v poli \textsf{d}).
\\Funkce vrátí $false$, pokud nelze částku uhradit.
\begin{lstlisting}[language=C++]
bool gt(int k,int n,ll *C){
    F(k)C[i]=0;
    if(!~t[n])return 0;
    while(~p[n])++C[P[n]],n=p[n];
    return 1;
}

\end{lstlisting}
\begin{center}
Počet možností zaplacení
\end{center}
Vstupem je \textsf{k} (počet různých hodnot platidel - uloženy v \textsf{d} a \textsf{n} (počet peněz který chceme zaplatit).
\\Návratovou hodnotou je pak počet možností, kterým se dá zaplatit \textsf{n} peněz (nezáleží na pořadí).
\\Složitost $O(nk)$.
\begin{lstlisting}[language=C++]
#define MX (1<<13)
ll t[MX],d[MX];
ll ct(int n,int k){
    CL(t,0),*t=1;
    F(k)for(int j(d[i]);j<=n;++j)
        t[j]+=t[j-d[i]];
    return t[n];
}
\end{lstlisting}
Obdobně, pokud máme jedno platidlo, tak \textsf{L} platidel (o velikostech \textsf{c}) a každým můžeme zaplatit jen jednou (a zajímají nás hodnoty do \textsf{X}), pak budou v $dp$ 1 tam, kde to lze nakombinovat.
\\Složitost $O(XL)$.
\begin{lstlisting}[language=C++]
#define MX (1024)
int dp[MX];
void ps(int*c,int L,int X){
    CL(dp,0),*dp=1;
    F(L)for(int j(X);j>=c[i];--j)dp[j]|=dp[j-c[i]];
}
\end{lstlisting}
\subsection{Narozeninový paradox}
Aproximace (velmi přesná) počtu lidí, které je potřeba, aby byla šance $\geq 0.5$.
\begin{lstlisting}[language=C++]
ld pba(int N){
    ld L(log(2));
    return sqrt(2*N*L)+(3-2*L)/6.+(9-4*L*L)/(72.*sqrt(2*N*L))-(2*L*L)/(135.*N);
}
\end{lstlisting}
\subsection{Parita kombinačních čísel}
Pokud je $k==0$, je parita rovna 1 (i bez modula by byl výsledek 1).
\\Pokud je $k$ liché, ale $n$ nikoliv, pak je parita 0 (čitatel kombinačního čísla bude vynásoben nejméně jednou dvojkou navíc, která se nemá jak zkrátit).
\\Jinak je výsledek stejný, jako ${n/2\choose k/2}$ (resp. ${\lfloor n/2\rfloor}$, což v programu nehraje roli).
\begin{lstlisting}[language=C++]
int bp(int n,int k){
      if(!k)
          return 1;
      return (!(n&1)&k&1)?0:bp(n>>1,k>>1); 
}
\end{lstlisting}
\subsection{Parita Stirlingových čísel druhého řádu}
bp(n,k) viz "Parita kombinačních čísel"
\\$S_2(n,k)={z\choose w}\ mod\ 2$, kde $z=n-{\lceil\dfrac{k+1}{2}\rceil}$, $w={\lfloor\dfrac{k-1}{2}\rfloor}$
\\Obecný předpis pro Stirlingova čísla druhého řádu je:
\\S(0, 0) = 1; 
\\S(n, 0) = 0 for n > 0; 
\\S(0, m) = 0 for m > 0;
\\S(n, m) = m S(n - 1, m) + S(n - 1, m - 1), for n, m > 0.
\vspace{2mm}
\begin{lstlisting}[language=C++]
int S(int n,int k){
    if(!n||!k)
        return k||n?0:1;
    return bp(n-((k+2)>>1),(k-1)>>1);
}
\end{lstlisting}
\subsection{Partition Function}
V poli \textsf{PN} jsou generalizovaná pentagonální čísla.
\\Prvních několik Partition Numbers jsou 1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56, 77, 101, 135, 176, 231, 297, 385, 490, 627, 792, 1002, 1255, 1575, 1958, 2436, 3010, 3718, 4565, 5604
\\V poli \textsf{PN} musí být uloženo Pentagonální číslo vyšší, než-li nejvyšší chtěné Partition Number (tedy například pokud chceme Partition Number 120, je nutné mít v \textsf{PN} uložena čísla do 126)
\\Čísla reprezentují, kolika způsoby lze dělit věc z $n$ stejných částí.
\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{pic/part.png}
  \caption[Rozdělení na n částí.]{Rozdělení na n částí (n == 4).}
\end{figure}
\begin{lstlisting}[language=C++]
typedef long long ll;
ll dp[128]={1,1,2,3},PN[]={1,2,5,7,12,15,22,26,35,40,51,57,70,77,92,100,117,126};
ll rc(ll u){
    if(dp[u])return dp[u];
    for(int i(0);PN[i]<=u;++i)
        dp[u]+=(i>>1)&1?-rc(u-PN[i]):rc(u-PN[i]);
    return dp[u];
}
\end{lstlisting}
\subsection{Pascalův trojúhelník}
\begin{lstlisting}[language=C++]
#define MX (1001)
ll pt[MX][MX];
void PT(){
    F(MX){
        pt[i][0]=pt[i][i]=1;
        FT(1,i)pt[i][k]=pt[i-1][k]+pt[i-1][k-1];
    }
}
\end{lstlisting}
${N\choose 2}={N\choose N-2}=t$, kde \textsf{t} je parametr funkce.
\begin{lstlisting}[language=C++]
ll sq(ll t){
    ll k(sqrt(t*8+1)),kk(k*k);
    if(kk!=(t*8+1))return 0;
    return (1+k)/2;
}
\end{lstlisting}
Generování výsledků Pascalova trohjúhelníka (kromě nad 1 a nad 2 - ty lze snadno dopočítat).
\\Trojúhelník samotný se nezaznamenává.
\\V \textsf{MX} je maximální hodnota - při výpočtu se hodnoty větší jak tato nahrazují '-1' a díky tomu lze velmi zrychlit výpočet (počítá se jen dokud nejsou čísla větší než 'MX') - složitost vede na $O(n^2)$, nicméně vzhledem k omezení maxima je mnohem příznivější!
\begin{lstlisting}[language=C++]
ll pA[SZ],pB[SZ];
map<int,set<pair<ll,ll > > > g;
void fill_pt(void){
    for(int i(0),L;i<SZ;++i){
        pA[0]=pA[i]=1;
        for(ll k(1);k<i;++k){
            if(!~pB[k])pA[k]=-1,L=k,k=i;
            else{
                pA[k]=pB[k-1]+pB[k];
                if(pA[k]>MX)pA[k]=-1,L=k,k=i;
                else g[pA[k]].insert(make_pair(i,k)),g[pA[k]].insert
                                                  (make_pair(i,i-k));
            }
        }
        FF(L&&j<=i)pB[j]=pA[j];
        if(!~pB[3])break;
    }
}
\end{lstlisting}
\subsection{Permutace}
Počet různých permutací znamének $=$ a $<$ mezi jednotlivými prvky.
\begin{lstlisting}[language=C++]
int cn[12],dp[12]={0,1},f[12]={1};
void rc(int c){
    int F(f[c+1]),t(2),r(2);
    if(c>=12)
        return;
    for(int i(0);i<c-1;++i)
        if(cn[i]){
            if(cn[i+1])
                t*=++r;
            else
                F/=t,t=2,r=2;
        }
    if(cn[c-1])
        F/=t,t=2,r=2;
    dp[c+1]+=F;
    cn[c]=0,rc(c+1);
    cn[c]=1,rc(c+1);
}
for(int i(1);i<12;++i)
    f[i]=i*f[i-1];
rc(1);cn[0]=1;rc(1);
\end{lstlisting}
Pokud je zadaná $K$-tá permutace, pak je nalezena první a je uložena v \textsf{r} (prvky se neopakují).
\begin{lstlisting}[language=C++]
#define MX (21)
ll f[MX]={1};
void pre(){FT(1,MX)f[k]=f[k-1]*k;}
int I[MX];
void fst(char*s,char*r,ll k){
    int L=strlen(s),p;
    r[L]=0,iota(I,I+L,0);
    F(L)p=k/f[L-i-1],swap(I[i],I[i+p]),
        sort(I+i+1,I+L),k%=f[L-i-1];
    F(L)r[I[i]]=s[i];
}
\end{lstlisting}
\subsection{Počet spojení na mřížce}
Počet spojení na mřížce $N\times M$ takových, že je spojen každý bod s každým, pokud toto spojední nevede přes jiný bod.
\begin{lstlisting}[language=C++]
#define MX (305)
ll f[MX][MX],dp[MX][MX];
void dyn(void){
    F(MX)if(i)FT(1,MX)f[i][k]=f[i][k-1]+f[i-1][k]-f[i-1][k-1]+(gcd(i,k)==1),
            dp[i][k]=dp[i-1][k]+dp[i][k-1]-dp[i-1][k-1]+f[i][k]-f[i/2][k/2];
}
#define GT(N,M) (dp[N-1][M-1]<<1)
\end{lstlisting}
\subsection{Pravděpodobnosti}
\textbf{Hod mincí}
\\Pravděpodobnost, že po hodu \textsf{N} mincema bude alespoň \textsf{K} hlava (pravděpodobnost jedné mince je \textsf{p})
\\Složitost $O(Hloh(H))$, kde $H=N-K$
\\Vychází ze vzorce, kde ${N\choose K}*p^K*(1-p)^{N-K}$ je pravděpodobnost, že padne právě $K$ hlav z $N$ hodů.
\begin{lstlisting}[language=C++]
ld pw(ld n,ll k){
    ld r(1);
    while(k){
        if(k&1)r*=n;
        n*=n,k>>=1;
    }
    return r;
}
ld al(int N,int K,ld p){
    if(N<K)return 0;
    ld S(0);
    FT(K,N+1)S+=pt[N][k]*pw(p,k)*pw(1-p,N-k);
    return S;
}
\end{lstlisting}
\textbf{Hod kostkou}
\\F: Počet stěn na kostce
\\N: Počet hodů kostkou
\\S: Číslo, které očekáváme, že padne
\begin{lstlisting}[language=C++]
int F,N,S;
BigDecimal dp[][];
public BigDecimal dyn(int t,int s){
    if(t<0||s<0)
    return BigDecimal.ZERO;
    if(dp[t][s]!=null)
        return dp[t][s];
    if(t==0||s==0)
        return dp[t][s]=t==s?BigDecimal.ONE:BigDecimal.ZERO;
    BigDecimal r=BigDecimal.ZERO;
    for(int i=1;i<=F;++i)
        r=r.add(dyn(t-1,s-i));
    return dp[t][s]=r;
} 
public void run(){
    dp=new BigDecimal[N+1][S+1];
    System.out.println(dyn(N,S)+"/"+new BigDecimal(F).pow(N));
}
\end{lstlisting}
\textbf{Pravděpodobnost barevnosti}
Mějme \textsl{C} barev - jaká je pravděpodobnost, že po \textsl{N} taženích bude na stole \textsl{M} barev, pokud při tažení (stejné rozložení) mi barva přibude, pokud na stole ještě není a ubude, pokud na něm již je. 
\\$C<100,{M,N}<1000000$
\begin{lstlisting}[language=C++]
double dp[1024][128];
double pb(int C,int M,int N){
    if(M>C||M>N||(M+N)&1)
        return 0;
    N=N>1001?(N&1)+1000:N;
    memset(dp,0,sizeof(dp));
    dp[0][0]=1;
    for(int i(1);i<=N;++i)
        for(int j(0);j<=C;++j)
            if(!j)
                dp[i][0]=dp[i-1][j+1]/C;
            else
                dp[i][j]=(dp[i-1][j-1]/C)*(C-j+1)+dp[i-1][j+1]*(j+1)/C;
    return dp[N][M];
}
\end{lstlisting}
\subsection{Strom, který má právě dva potomky a M listů}
Vypíše se počet vrcholů
\\Multiple = více možností
\\Impossible = nemá řešení
\begin{lstlisting}[language=C++]
void tree(long long n,long long m){
    if(n==m&&m==1)
        printf("Multiple\n");
    else if(n==1||(n*m-1)%(n-1))
        printf("Impossible\n");
    else
        printf("%lld\n",(n*m-1)/(n-1));
}
\end{lstlisting}
\subsection{Vyplňování obdélníku obdélníčky}
Vrátí true, pokud lze vyplnit obdélník s koordináty \textsf{A} vyplnit obdélníky s koordináty \textsf{B};
\begin{lstlisting}[language=C++]
void eGCD(ll a,ll b,ll&x,ll&y,ll&g) {
  if(!b)x=1,y=0,g=a;
  else eGCD(b,a%b,y,x,g),y-=a/b*x;
}
bool ok(ll N,ll M,ll a,ll b){
    ll x,y,g,L,h;
    eGCD(a,b,x,y,g),L=a/g*b;
    if(N%g)return 0;
    x*=N/g,y*=N/g;
    if(x<0){
        h=abs(x/(b/g)),x+=b/g*h,y-=a/g*h;
        while(x<0)x+=b/g,y-=a/g;
    }else if(y<0){
        h=abs(y/(a/g)),x-=b/g*h,y+=a/g*h;
        while(y<0)x-=b/g,y+=a/g;
    }
    if(x<0||y<0||a*x+b*y>N)return 0;
    if(!y)return !(M%b);
    if(!x)return !(M%a);
    return !(M%L);
}
bool tl(int*A,int*B){
    F(2)FF(2)if(ok(A[i],A[i^1],B[j],B[j^1]))return 1;
    return 0;
}
\end{lstlisting}
\newpage\section{Ostatní}
\subsection{CYK}
Algoritmus je dělán pro 26 neterminálů (velká písmena) a 26 terminálů (malá písmena).
\\Vrací true, pokud je slovo \textsl{w} v gramatice.
\\Proměnné:
\begin{itemize}
\item \textbf{L} - délka slova.
\item \textbf{h} - neterminály generující terminál.
\item \textbf{hl} - počet neterminálů generujících terminál.
\item \textbf{gn} - neterminály generující neterminály. 
\item \textbf{gnl} - počet neterminálů generujících neterminály.
\item \textbf{cn} - poslední použití pravidla ($A\rightarrow BC$).
\item \textbf{g} - položky CYK (dynamické programování).
\item \textbf{gl} - počet položek CYK.
\item \textbf{rl} - počet pravidel typu $A\rightarrow BC$, $A,B,C\in N$.
\end{itemize}
Složitost $O((U*n)^3)$, kde \textsl{n} je velikost slova a \textsl{U} je univerzum neterminálů (algoritmus kontroluje navíc počet použitých pravidel, takže při nízkém počtu pravidel a jejich plném využití může být složitost $\Omega (U*n^2)$).
\begin{lstlisting}[language=C++]
int L,hl[26],h[26][26],gn[26][26][26],gnl[26][26]
    ,cn[26][26],g[1024][1024][32],gl[1024][1024],rl;
char w[1024];
bool cyk(void){
    for(int i(0);i<L;++i)
        for(int j(gl[0][i]=0),k(w[i]-'a');j<hl[k];++j)
            g[0][i][gl[0][i]++]=h[k][j];
    for(int i(1),K(L-1),ct(1);i<L;++i,--K)
        for(int j(0),ru(0);j<K;++j,++ct)
            for(int t(gl[i][j]=0),x(i-1),y(j+1);t<i&&ru!=rl;++t,--x,++y)
                for(int u(0);u<gl[t][j];++u)
                    for(int v(0);v<gl[x][y];++v)
                        if(cn[g[t][j][u]][g[x][y][v]]!=ct){
                            cn[g[t][j][u]][g[x][y][v]]=ct;
                            for(int r(0);r<gnl[g[t][j][u]][g[x][y][v]];++r)
                                g[i][j][gl[i][j]++]=gn[g[t][j][u]][g[x][y][v]][r],++ru;
                        }
    for(int i(0);i<gl[L-1][0];++i)
        if(g[L-1][0][i]=='S'-'A')
            return 1;
    return 0;
}
\end{lstlisting}
\subsection{Dynamika}
Nechť je dáno \textsf{N} území a možnost všechny natahat do \textsf{K} z nich. Otázkou je, kolik cesty se pronese za kus, aby se tak uskutečnilo.
\\V \textsf{a} budou dvojice: Součadnice (x-ová [1D]) / Počet prvků
\\Složitost $O(N^2)$
\begin{lstlisting}[language=C++]
#define MX (5000)
ll b[MX][MX],dp[2][MX],A[MX],B[MX];
int w[MX],P[MX],s[2][MX];
ll cc(int k,int i,int j){return i^j?P[k]*(A[k]*2-A[i-1]-A[j])+B[j]+B[i-1]-B[k]*2:0;}
ll gc(int h,int x,int j){return b[x+1][j]+dp[(h-1)&1][x];}
ll dyn(int N,int K,ii*a){
    int u,v;
    sort(a,a+N);
    FT(1,N+1)P[k]=a[k-1].aa,w[k]=a[k-1].bb,A[k]=A[k-1]+w[k],B[k]=B[k-1]+P[k]*1ll*w[k];
    FT(1,N+1)b[k][k]=0,s[1][k]=k;
    FT(2,N+1)FOR(i,1,N+2-k){
        u=s[(k-1)&1][i],v=s[(k-1)&1][i+1];
        FOR(j,u,v+1)
            if(cc(u,i,i+k-1)>cc(j,i,i+k-1))u=j;
        b[i][i+k-1]=cc(u,i,i+k-1),s[k&1][i]=u;
    }
    memcpy(&dp[1][1],&b[1][1],N*sizeof(ll));
    fill(&s[1][1],&s[1][N+1],1);
    FT(2,K+1){
        dp[k&1][k]=0;
        for(int i=N;i>k;--i){
            u=s[(k-1)&1][i-1],v=(i+1<=N)?s[k&1][i+1]:i-1;
            FOR(j,u,v+1)if(gc(k,u,i)>gc(k,j,i))u=j;
            dp[k&1][i]=gc(k,u,i),s[k&1][i]=u;
        }
    }
    return dp[K&1][N];
}
\end{lstlisting}
Obdobný problém jako nahoře, s rozdílem, že se prvky dají nosit POUZE do položek s vyšší souřadnicí (a.aa).
\begin{lstlisting}[language=C++]
#define MX 1024
ll dp[MX][MX],w[MX],S[MX];
struct DP{
    ll X[MX],Y[MX],B,E;
    void CLR(){B=0,E=-1;}
    ll XX(ll x1,ll y1,ll x2,ll y2){return x1*y2-y1*x2;}
    void add(ll x,ll y) {
        while(B<E&&XX(X[E]-X[E-1],Y[E]-Y[E-1],x-X[E-1],y-Y[E-1])<0)E--;
        X[++E]=x,Y[E]=y;
    }
    ll gt(ll m){
        while(B<E&&Y[B+1]-Y[B]<(X[B+1]-X[B])*m)++B;
        return Y[B]-m*X[B];
    }
}T;
ll dyn(int N,int M,ii*a){
	//sort(a,a+N);
    F(N)w[i+1]=w[i]+a[i].bb,S[i+1]=S[i]+a[i].aa*1ll*a[i].bb;
    F(N+1)fill(dp[i],dp[i]+M+1,1ll<<62);
    **dp=0;
    F(M){
        T.CLR();
        FT(i,N)T.add(w[k],dp[k][i]+S[k]),
               dp[k+1][i+1]=T.gt(a[k].aa)-S[k+1]+w[k+1]*1ll*a[k].aa;
    }
    return dp[N][M];
}
\end{lstlisting}
Convex Hull Trick:
\\Vkládají se úsečky $y=k_iX+Y_i$, a poté se v $log(N)$ nalezne optimální odpověď pro zadané \textsf{x}.
\begin{lstlisting}[language=C++]
#define MX (1<<18)
struct CH{
    int N;
    pll Q[MX];
    void add(ll k,ll Y){
        while(N){
            ll B=-1e7,E=1e7,u=Q[N-1].aa,y=Q[N-1].bb,x;
            if(u*B+y>=k*B+Y){--N;continue;}
            if(u*E+y<=k*E+Y)return;
            if(N==1)break;
            while(E-B>1){
                x=(B+E)/2;
                if(u*x+y<k*x+Y)B=x;
                else E=x;
            }
            if(Q[N-2].aa*B+Q[N-2].bb<=u*B+y)--N;
            else break;
        }
        Q[N++]={k,Y};
    }
    ll gt(ll x){
        if(N==1||Q->aa*x+Q->bb<=Q[1].aa*x+Q[1].bb)return Q->aa*x+Q->bb;
        int B=0,E=N-1,M;
        while(E-B>1)
            if((M=(B+E)/2),Q[M].aa*x+Q[M].bb>=Q[M+1].aa*x+Q[M+1].bb)B=M;
            else E=M;
        return Q[E].aa*x+Q[E].bb;
    }
}T;
\end{lstlisting}
\subsection{Excel}
Převod čísla na excelovský sloupec (řetězec v něm ['A','ABD',...])
\begin{lstlisting}[language=C++]
int ctt(int n,char *r){
    int l(0);
    while(n>0)r[l++]='A'+(n-1)%26,n=(n-1)/26;
    F(l>>1)swap(r[i],r[l-1-i]);
    r[l]=0;
    return l-1;
}
\end{lstlisting}
Získání n-tého písmene v excelovských řetězcích daných za sebe ($|U|$ nemusí být 26 - nějaká variable \textsf{N}).
\\\textsf{P} jsou mocniny čísla \textsf{N}.
\\Případně na konci přičíst 'A'
\begin{lstlisting}[language=C++]
int N;
ll P[64];
ll nth(ll n){
    int I(0);
    while(I*P[I]<n)n-=I*P[I],++I;
    --n;
    int x(n/I),y(I-n%I),r,k(0);
    while(k!=y)r=x%N,x/=N,++k;
    return r;
}
//*P=l=1;while((P[l]=N*P[l-1])<MX)++l;
\end{lstlisting}
\subsection{Hanoiská věž}
Vytisknutí prvních \textsf{M} tahů hanoiských věží o \textsc{N} prvcích
\begin{lstlisting}[language=C++]
int N,M,A[MX],B[MX],C[MX],a,b,c;
void pt(int*A,int L,char c){
    //Print or stack
}
#define PA pt(A,a,65),pt(B,b,66),pt(C,c,67);
void mg(int*U,int&u,int*V,int&v){
    if(--M<0)return;
    V[v++]=U[--u],pc(10),PA;
}
void ht(int p,int*A,int*B,int*C,int&a,int&b,int&c){
    if(M<0)return;    
    if(p-1)ht(p-1,A,C,B,a,c,b),mg(A,a,C,c),ht(p-1,B,A,C,b,a,c);
    else mg(A,a,C,c);
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
b=c=0,a=N,iota(A,A+a,1),reverse(A,A+a),PA;
ht(N,A,B,C,a,b,c),pc(10);
\end{lstlisting}
\subsection{Hodiny}
Vygenerování digitálního čísla $n$ na pozici $X,Y$.
\begin{lstlisting}[language=C++]
int sx[]={1,1,1,0,0,0,0},sy[]={0,0,0,1,1,1,1},sz[]={5,5,5,4,4,4,4},
bx[]={0,0,0,0,4,0,4},by[]={0,3,6,0,0,3,3},w[]={0,7,17,24};
vector<int> N[10]={{0,2,3,4,5,6},{4,6},{0,1,2,4,5},{0,1,2,4,6},{1,3,4,6},
{0,1,2,3,6},{0,1,2,3,5,6},{0,4,6},{0,1,2,3,4,5,6},{0,1,2,3,4,6}};
char c[9][32];
void hs(int X,int Y,int s){
    X+=bx[s],Y+=by[s];
    for(int i(0);i<sz[s];++i,X+=sx[s],Y+=sy[s])
        c[Y][X]=i&&i<sz[s]-1?(sx[s]?'-':'|'):'+';
}
void sdg(int X,int Y,int n){
    for(auto i(N[n].begin());i!=N[n].end();++i)
        hs(X,Y,*i);
}
\end{lstlisting}
\begin{figure}[H]
  \centering
  \includegraphics[width=2in]{pic/dig}
  \caption[Číslice na sedmisegmentu.]{Číslice na sedmisegmentu.}
\end{figure}
\subsection{Kalendářní data}
\begin{center}
Přestupní rok
\end{center}
\begin{lstlisting}[language=C++]
bool leap(int y){return !(y%400)||(y%100&&!(y&3));}
\end{lstlisting}
\begin{center}
Maximum dní měsíce (indexace od 0)
\end{center}
\begin{lstlisting}[language=C++]
int M[]={31,28,31,30,31,30,31,31,30,31,30,31};
int mm(int m,int y){return m==1?leap(y)?29:28:M[m];}
\end{lstlisting}
\begin{center}
Generování dat
\end{center}
\begin{lstlisting}[language=C++]
bool valid(int d,int m,int y){return m<13&&m&&d<=mm(m-1,y)&&d;}
void gen(int&d,int&m,int&y,int C){
    while(C--){
        if(valid(++d,m,y));
        else if(valid(d=1,++m,y));
        else m=1,++y;
    }
}
\end{lstlisting}
\begin{center}
Den v roce
\end{center}
\begin{lstlisting}[language=C++]
int mo[12]={0,1,-1,0,0,1,1,2,3,3,4,4};
int doy(int d, int m, int y){
    return (leap(y)&&m>=3)+30*(m-1)+mo[m-1]+d-1;
}
\end{lstlisting}
\begin{center}
Názvy
\end{center}
\begin{lstlisting}[language=C++]
unordered_map<string,int> T={{"January",1},{"February",2},{"March",3},{"April",4},{"May",5},
{"June",6},{"July",7},{"August",8},{"September",9},{"October",10},{"November",11}
,{"December",12}};
char Z[][32]={"","January","February","March","April","May","June","July","August",
"September","October","November","December"},
D[][32]={"Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"};
\end{lstlisting}
\subsection{Knapssack Problem}
Vrátí, jakou maximální cenu získáme, pokud do batohu o váze \textsf{M}, nacpeme věci (kterých je \textsf{N}) o váze \textsf{w} a hodnotě \textsf{V}.
\\Každá věc se dá do batohu vložit nejvýše jednou.
\\Složitost $O(NM)$
\begin{lstlisting}[language=C++]
int ksp(int M,int *w,int *V,int N){
    static int K[MX][MW];
    F(N+1)FF(M+1)
        if(!i||!j)K[i][j]=0;
        else if(w[i-1]<=j)
            K[i][j]=max(V[i-1]+K[i-1][j-w[i-1]],K[i-1][j]);
        else K[i][j]=K[i-1][j];
    return K[N][M];
}
\end{lstlisting}
Nexchť máme \textsf{P} batohů ($P\leq MP$) o nosnostech $C_i$ a \textsf{N} zboží ($N\leq MX$) o váze ($w_i<MW$) a hodnotě ($p_i$). Funkce vrátí maximální hodnotu zboží, kterou lze dohromady do batohů nacpat. Každé zboží zle vzít tolikrát, kolik máme batohů (do každého jednou).
\\Složitost $O(P+MW*N)$
\begin{lstlisting}[language=C++]
#define MX (1001)
#define MW (32)
#define MP (100)
int dp[MX][MW],p[MX],w[MX],C[MP];
int cbg(int N,int P){
    int S(0),X(*max_element(C,C+P));
    F(N+1)FF(X+1)if(!i||!j)dp[i][j]=0;
               else if(w[i-1]>j)dp[i][j]=dp[i-1][j];
               else dp[i][j]=max(dp[i-1][j],p[i-1]+dp[i-1][j-w[i-1]]);
    F(P)S+=dp[N][C[i]];
    return S;
}
\end{lstlisting}
Počet možností, jak dosáhnout ceny \textsf{n}, pomocí dvou věcí o ceně \textsf{A} a \textsf{B}.
\begin{lstlisting}[language=C++]
ll eGCD(ll a,ll b,ll &x,ll &y){
    ll xx,yy,r;
    if(a<b)return eGCD(b,a,y,x);
    if(!b)return x=1,y=0,a;
    return r=eGCD(b,a%b,xx,yy),x=yy,y=(xx-a/b*yy),r;
}
ll sm(ll A,ll B,ll n){
    ll a,b,g=eGCD(A,B,a,b),k=n/g,u,v;
    if(n%g)return 0;
    a*=k,b*=k,u=A*B/g/A,v=A*B/g/B;
    if(a<0)k=-a/u+!!(a%u),a+=k*u,b-=k*v;
    if(b<0)k=-b/v+!!(b%v),a-=k*u,b+=k*v;
    return a<0||b<0?0:((b+a/u*v)/v*u)/u+1;
}
\end{lstlisting}
0/1 batoh za pomocí bitsetu (a jeho posunu)
\begin{lstlisting}[language=C++]
int W;
void ad(int a){U=B,U<<=a,B|=U;}
int ans(){
    F(W+1)if(B.ct(W-i))return W-i;//possibly faster
    assert(0);
}
#define CLR (B.clr(),B.ad(0))
\end{lstlisting}
\subsection{Násobení matic}
V \textsf{d} jsou uloženy rozmery jednotlivých matic (0 až N-1 jsou x-ové, a na N je ypsilonová posledního prvku).
\\Volání probíhá pomocí $dyn(1,N)$
\\Návratovou hodnotou je počet násobení.
\begin{lstlisting}[language=C++]
int d[16],dp[16][16],x[16][16];
int dyn(int a,int b){
    if(a==b)return 0;
    int &v(dp[a][b]);
    if(~v)return v;
    FT(a,b){
        int S=d[a-1]*d[k]*d[b]+dyn(a,k)+dyn(k+1,b);
        if(!~v||S<v)v=S,x[a][b]=k;
    }
    return v;
}
\end{lstlisting}
Funkce tisknoucí zápis pak vypadá nějak takto:
\begin{lstlisting}[language=C++]
#define pc(C) putchar_unlocked(C)
void pp(int a, int b){
    if(a==b)printf("A%d",a);
    else pc(40),pp(a,x[a][b]),pc(32),pc(120),pc(32),pp(x[a][b]+1,b),pc(41);
}
\end{lstlisting}
\subsection{Načítání čísel - JAVA}
\begin{lstlisting}[language=C++]
static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
static StringTokenizer st=new StringTokenizer("");
static String nextToken()throws Exception {
    while(!st.hasMoreTokens())
        st=new StringTokenizer(br.readLine());
    return st.nextToken();
}
static int nextInt() throws Exception {
    return Integer.parseInt(nextToken());
}
\end{lstlisting}
\subsection{Permutování}
Příklad funkce $next_permutation$ (a při té příležitosti i $memcpy$).
\begin{lstlisting}[language=C++]
sort(h,h+6);
do{
    tp=h[0]*10+h[1]+h[2]*10+h[3];
    if(abs(tp-100)<d)
        d=abs(tp-100),memcpy(B,h,sizeof(h));
}while(next_permutation(h,h+6));
\end{lstlisting}
Nalezení K-té permutace.
\\Složitost $O(N*U^2)$, kde $U$ je velikost abecedy. [nicméně jsme dosti omezení faktoriálem, aby se vešel do longu].
\\Nalezení permutace stringu \textsf{s} a uložení do \textsf{o} (MX+1!!).
\begin{lstlisting}[language=C++]
#define MX (20)
ll f[MX+1]={1};
int C[26],X;
void nth(ll K,char*o,char*s){
    if(!X++)FT(1,MX+1)f[k]=f[k-1]*k;
    ll L(strlen(s)),X(f[L]),T,l(0);
    CL(C,o[L]=0);
    F(L)++C[s[i]-'a'];
    F(26)X/=f[C[i]];
    if(K>X){*o=0;return;};
    F(L)FF(26)if(C[j]){
        --C[j];
        T=f[L-i-1];
        F(26)T/=f[C[i]];
        if(K<=T){o[l++]='a'+j;break;}
        ++C[j],K-=T;
    }
}
\end{lstlisting}
\subsection{Římská čísla (generování)}
V cyklu volat tuto funkci (či pro jednoduché převedení - return)
\begin{lstlisting}[language=C++]
unordered_map<string,int> t;
unordered_map<int,string> invT;
const char r[][3]={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
const int v[]={1000,900,500,400,100,90, 50,40,10,9,5,4,1};
void toRoman(int num){
    string s;
    for(int i(0),n(num);i<13;++i)
        while(n>=v[i])
            n-=v[i],s+=r[i];
    t[s]=num,invT[num]=s;
}
\end{lstlisting}
\subsection{Šachovnice}
Pohyby figurek po šachovnici:
\\$KX,KY$: Král,Královna
\\$RX,RY$: Věž
\\$BX,BY$: Střelec
\\$NX,NY$: Kůň
\begin{lstlisting}[language=C++]
int KX[]={-1,0,1,-1,1,-1,0,1},KY[]={1,1,1,0,0,-1,-1,-1}
    ,RX[]={1,-1,0,0},RY[]={0,0,1,-1},BX[]={1,1,-1,-1},BY[]={1,-1,1,-1},
    NX[]={-2,-2,-1,-1,1,1,2,2},NY[]={1,-1,2,-2,2,-2,1,-1};
\end{lstlisting}
Funkce $uns$ vrátí true, pokud zadaná figurka nikoho neohrožuje.
\\Argumentem je její pozice na šachovnici ($0$ až $n$) a druh figurky (pod $default$ se skrývá kůň (\textbf{N}).
\\Šachovnice je v poli \textsl{g}, a její políčka jsou od $0$ do $w/h$ (výšky/šířky)
\\Složitost je pak lineární vzhledem šířce či výšce (konstanta 8 - královna).
\begin{lstlisting}[language=C++]
#define in(X,Y) (X>0&&X<=h&&Y>0&&Y<=w)
bool kill(int x,int y,int *sx,int *sy,int n=4){
    for(int i(0);i<n;++i)
        for(int tx=x+sx[i],ty=y+sy[i];in(tx,ty);tx+=sx[i],ty+=sy[i])
            if(g[tx][ty])
                return 0;
    return 1;
}
bool rnd(int x,int y,int *sx,int *sy){
    for(int i(0);i<8;++i)
        if(in(x+sx[i],y+sy[i])&&g[x+sx[i]][y+sy[i]])
            return 0;
    return 1;
}
bool uns(int x,int y,char t){
    switch(t){
        case 'K': return rnd(x,y,KX,KY);
        case 'Q': return kill(x,y,KX,KY,8);
        case 'R': return kill(x,y,RX,RY);
        case 'B': return kill(x,y,BX,BY);
        default: return rnd(x,y,NX,NY);
    }
}
\end{lstlisting}
Hledání maximálního počtu figurek, které ze zadaných mohou zůstat.
\\Složitost $O(2^L*max(w,h))$, kde \textsl{L} je počet figurek a $w/h$ jsou šířka a váha.
\begin{lstlisting}[language=C++]
int bts(int n){
    int ct(0);
    while(n)
        n&=n-1,++ct;
    return ct;
}
void tst(int cn){
    if((z=bts(cn))<=mx)
        return;
    bool X(1);
    for(int i(0);i<L;++i)
        if((1<<i)&cn)
            g[x[i]][y[i]]=f[i];
    for(int i(0);i<L;++i)
        if((1<<i)&cn)
            X&=uns(x[i],y[i],f[i]);
    if(X)
        mx=z;
    for(int i(0);i<L;++i)
        g[x[i]][y[i]]=0;
}
mx=0;
for(int i((1<<L)-1);i;--i)
    tst(i);
\end{lstlisting}
Počet možností rozmístění koňů na \textsf{M}*\textsf{N} šachovnici (pro malé \textsf{N} a velké \textsf{M}) - v modulu \textsf{MOD}.
\\Složitost $O(2^{2N}*log(M))$
\begin{lstlisting}[language=C++]
#define MOD (1000000009LL)
bool on(int s,int c,int r,int W){
    return s&(1<<(c*W+r));
}
bool ok(int s,int n,int W){
    F(W)if(on(n,0,i,W)){
        if(i-2>=0&&on(s,1,i-2,W))return 0;
        if(i-1>=0&&on(s,0,i-1,W))return 0;
        if(i+1<W&&on(s,0,i+1,W))return 0;
        if(i+2<W&&on(s,1,i+2,W))return 0;
    }
    return 1;
}
void kmx(ll M[MM][MM],int W){
    int s(1<<(W<<1));
    F(s)FF(s)M[i][j]=0;
    F(s)FF(1<<W)if(ok(i,j,W))M[i][(i>>W)|(j<<W)]=1;
}
ll sum(int s,ll M[MM][MM],ll MD){
    ll r(0);
    F(s)r+=M[0][i],r%=MD;
    return r;
}
\end{lstlisting}
Takto se to použije v programu, kde na vstupu je \textsf{N} a \textsf{M} a někde máme pole (matice) \textsf{X} a \textsf{R}.
\begin{lstlisting}[language=C++]
    kmx(X,N);
    pw(X,R,1<<(N<<1),M,MOD);//Viz. Mocneni matic
    sum(1<<(N<<1),R,MOD);//Result
\end{lstlisting}
Počet možností, jak rozmísti \textsf{K} věží na \textsf{$N^2$} šachovnici.
\begin{lstlisting}[language=C++]
void rk(int N,int K,big&S){
    S=0;
    if(K>N)return;
    S=1;
    F(K)S*=N*N,--N;
    while(K)S/=K--;
}
\end{lstlisting}
Maximum koňů, které lze umístit na $N*M$ šachovnici, tak aby se neohrožovali.
\begin{lstlisting}[language=C++]
int mxk(int N,int M){
    static int sx[]={0,2,4,4};
    if(N>M)swap(N,M);
    if(N==1)return M;
    if(N==2)return ((M>>2)<<2)+sx[M&3];
    return ((M>>1)*(N>>1))+(((M+1)>>1)*((N+1)>>1));
}
\end{lstlisting}
Maximum koňů, které lze umístit na $N*M$ šachovnici, tak aby se neohrožovali.
\\Zde je navíc ovšem šachovnice $G$, kde jsou 1 označena políčka, na kterých kůň nesmí stát.
\\Dále je nutné importovat Maximální Párování z kapitoly \textit{Hopcroft–Karp}.
\begin{lstlisting}[language=C++]
#define MV (200*200+2)
#define ME (MV*8)
//Maximal Matching
#define MM (200)
int NX[]={-2,-2,-1,-1,1,1,2,2},NY[]={1,-1,2,-2,2,-2,1,-1},I[MM][MM];
#define in(X,Y) (X<N&&X>=0&&Y<M&&Y>=0)
int nok(int N,int M,bool G[MM][MM]){
    int x(0),y(0),tx,ty;
    F(N)FF(M)if(!G[i][j])I[i][j]=(i+j)&1?y++:x++;
    g.ini(max(x,y));
    F(N)FF(M)if(!G[i][j]){
        if(!((i+j)&1))FT(0,8){
            tx=i+NX[k],ty=j+NY[k];
            if(in(tx,ty)&&!G[tx][ty]) g.add(I[i][j],I[tx][ty]);
        }
    }
    return x+y-g.mm();;
}
\end{lstlisting}
Počet věží, které lze na $N*M$ šachovnici s dírama (přes které není vidět).
\\Opět je potřeba Hopford-Karp.
\begin{lstlisting}[language=C++]
#define MX (101)
int rks(int N,int M,bool G[MX][MX]){
    static int A[MX][MX],B[MX][MX];
    int L=0,R=0;
    F(N)FF(M)if(!G[i][j]&&(!j||G[i][j-1]))A[i][j]=L++;
             else if(!G[i][j])A[i][j]=A[i][j-1];
    F(M)FF(N)if(!G[j][i]&&(!j||G[j-1][i]))B[j][i]=R++;
             else if(!G[j][i])B[j][i]=B[j-1][i];
    g.ini(max(R,L));
    F(N)FF(M)if(!G[i][j])g.add(A[i][j],B[i][j]);
    return g.mm();
}
\end{lstlisting}
Vygenerování všech možností, jak umístit královny na $8\times 8$ šachovnici.
\\Generování proběhne zavolání $GEN$
\\Výsledky budou uloženy v \textsf{G} (bude jich \textsf{S}).
\\Indexace od 1
\begin{lstlisting}[language=C++]
#define MX (8)
char G[92][MX+1],t[MX+1];
bool r[MX],R[2*MX],L[2*MX];
int S;
void gen(int n){
    if(n==MX)t[MX]=0,strcpy(G[S],t),S++;
    else F(MX)if(r[i]&&R[n-i+MX]&&L[n+i])
        r[i]=R[n-i+MX]=L[n+i]=0,t[n]=i+1,gen(n+1),r[i]=R[n-i+MX]=L[n+i]=1;
}
#define GEN CL(r,1),CL(R,1),CL(L,1),gen(S=0)
\end{lstlisting}
Funkce \textsf{mv} vrátí 0, pokud je $N\times N$ šachovnice s \textsf{N} dámama, které se neohrožují. \\Pokud tak lze dočinit během 1 tahu, návratovou hodnotou bude 1. 
\\Jinak bude návratová hodnota -1
\\Šachovnice je uložena v \textsf{g}, a volná políčka budou označna $0$. Dále je nutný import \textsf{KX} a \textsf{KY}.
\begin{lstlisting}[language=C++]
bool ck(int*qx,int*qy,int N){
    ll H=0,P=0;
    F(N)if(H&1ll<<qx[i]||P&1ll<<qy[i])return 0;
        else H|=1ll<<qx[i],P|=1ll<<qy[i];
    F(N)FT(i+1,N)
        if(abs(qx[i]-qx[k])==abs(qy[i]-qy[k]))return 0;
    return 1;
}
#define in(X,Y) (~X&&~Y&&X<N&&Y<N)
int qx[64],qy[64];
int mv(int N){
    int x,y,L=0;
    F(N)FF(N)if(g[i][j])qx[L]=i,qy[L++]=j;
    if(ck(qx,qy,N))return 0;
    F(N)FF(8){
        x=qx[i]+KX[j],y=qy[i]+KY[j];
        while(in(x,y)){
            if(!g[x][y]){
                swap(x,qx[i]),swap(y,qy[i]);
                if(ck(qx,qy,N))return swap(g[qx[i]][qy[i]],g[x][y]),1;
                swap(x,qx[i]),swap(y,qy[i]);
            }
            x+=KX[j],y+=KY[j];
        }
    }
    return -1;
}
\end{lstlisting}
Vygenerování právě jednoho řešení pro \textsf{N} dam na šachovnici.
\\Indexace je od 1 (a to jak v poli, tak číselně).
\\V \textsf{o} budou indexy pro $i$-tou řádku.
\begin{lstlisting}[language=C++]
void gq(int N,int*o){
    if(N&1)gq(N-1,o),o[N]=N;
    else if(N%6==2)FT(1,N/2+1)o[k]=1+(2*k+N/2-3+N)%N,o[N+1-k]=N-(2*k+N/2-3+N)%N;
    else FT(1,N/2+1)o[k]=2*k,o[N/2+k]=2*k-1;
}
\end{lstlisting}
Počet možností, kterými lze vygenerovat $N-queen problem$ - v \textbf{g} jsou "bad positions", na které nesmí královna přijít. 
\begin{lstlisting}[language=C++]
#define MX (13)
bool g[MX][MX];
int N;
int pp(int r=0,int R=0,int l=0,int L=0){
    if((((1<<N)-1)&R)==(1<< N)-1)return 1;
    int S=0,p=((1<<N)-1)&~(R|l|L);
    F(N)if(p>>i&g[i][r])S+=pp(r+1,R|1<<i,(l|1<<i)<<1,(L|1<<i)>>1);
    return S;
}
\end{lstlisting}
\subsection{Šifrování}
Zjištění, zda-li je možné, aby byla použita dvojnásobná substituční šifra.
\begin{lstlisting}[language=C++]
char s[26];
int M[26],T[26],cn[26],C[26];
bool ok(void){
    CL(cn,0),CL(T,0),CL(C,0);
	F(26)M[(int)(s[i]-='A')]=i;    
    F(26)if(!T[i]){
 	    int j(i),n(0);
     	do T[j]=1,j=M[j],++n;
	    while(j!=i);
	    ++C[n];
    }
    F(26)if(!(i&1)&&C[i]&1)return 0;
    return 1;
}
\end{lstlisting}
Zašifrování pomocí Playfairovi šifry
\begin{lstlisting}[language=C++]
char g[5][5];
ii P[26];
int cn[26],p;
string s,e,r;
void ct(string s) {
    CL(cn,p=0),cn[16]=1;
    F(26)s+=char(97+i);
    for(char c:s)if(islower(c)&&!cn[c-97])
        ++cn[c-97],P[c-97]={p/5,p%5},
        g[p/5][p%5]=toupper(c),++p;
}
string ep(char a,char b) {
    ii A=P[a-97],B=P[b-97];
    if(A.aa==B.aa)++A.bb,++B.bb;
    else if(A.bb==B.bb)++A.aa,++B.aa;
    else swap(A.bb,B.bb);
    e="XX",e[0]=g[A.aa%5][A.bb%5],
        e[1]=g[B.aa%5][B.bb%5];
    return e;
}
string ec(string s){
    string e;
    F(int(s.size()))
        if(i+1u==s.size()||s[i]==s[i+1])e+=ep(s[i],120);
        else e+=ep(s[i],s[i+1]),++i;
    return e;
}
string zo(string s) {
    r="";
    for(char c:s)if(islower(c))r+=c;
    return r;
}
//Pouziti - s klicem a plaintextem - vysledek v navratove hodnote.
ct(zo(a)),ec(zo(s));
\end{lstlisting}
\subsection{Stopky}
Funkce $ini$ nastaví stopky
\\Funkce $ok$ vráti true, pokud stopky běží méně jako \textsf{Z} sekund
\begin{lstlisting}[language=C++]
struct STOP{
    clock_t S;
    void ini(){S=clock();}
    bool ok(double Z){return (clock()-S)/(double)CLOCKS_PER_SEC<Z;};
}T;
\end{lstlisting}
\subsection{Sudoku}
Funkce řeší sudoku pomocí backtrackingu (nemusí být nejrychlejší!).
\\\textsf{XX} je číslo značící prázdné políčko
\\Při neúspěchu vrátí funkce $false$.
\begin{lstlisting}[language=C++]
#define XX 0
#define N 9
int g[N][N];
bool ful(int &r, int &c){
    for(r=0;r<N;++r)
        for(c=0;c<N;++c)
            if(g[r][c]==XX)return 1;
    return 0;
}
bool uir(int r, int n){
    F(N)if(g[r][i]==n)return 1;
    return 0;
}
bool uic(int c, int n){
    F(N)if(g[i][c]==n)return 1;
    return 0;
}
bool uib(int R, int C, int n){
    F(3)FF(3)if(g[i+R][j+C]==n)return 1;
    return 0;
}
bool sf(int r, int c, int n){
    return !uir(r,n)&&!uic(c,n)&&!uib(r-r%3,c-c%3,n);
}
bool ssk(void){
    int r, c;
    if(!ful(r,c))return 1; 
    F(9)if(sf(r,c,i+1)){
        g[r][c]=i+1;
        if(ssk())return 1;
        g[r][c] = XX;
    }
    return 0;
}
\end{lstlisting}
\subsection{Ternární vyhledávání}
Vyhledá minimum na intervalu.
\begin{lstlisting}[language=C++]
ld ok(ld w){
    //TODO
}
ld ts(ld B=0,ld E=INF){
    ld T;
    while(!EQ(B,E)){
        T=(E-B)/3;
        if(ok(B+T)>ok(E-T))B+=T;
        else E-=T;
    }
    return B;
}
\end{lstlisting}
\subsection{Unordered map párů}
\begin{lstlisting}[language=C++]
struct ph{int operator()(const ii&v)const{return v.aa*31+v.bb;}};
unordered_map<ii,int,ph> S;
\end{lstlisting}
\newpage\section{Posloupnosti a řetězce}
\subsection{Aho-Corasick}
Algoritmus přijme množství (až \textsf{PT}) patternů (automat se musí vlézt to \textsf{MX} stavů).
\\$AL$ je velikost abecedy.
\\Prvně se musí zavolat $ini$, která nainicializuje proměnné (netestováno!)
\\Dále se přidají řetězce pomocí $add$ (první parametr je řetězec a druhý je jeho pořadí [či nějaký klíč])
\\Když se přidají všechny $patterny$, zavolá se build, který inicializuje automat.
\\Nakonec se zavolá $fnd$ ($CAL$), který označí všechny patterny, které se v daném řetězci vyskytují. Označeny budou v \textsf{o} (true, pokud v něm jsou).
\begin{lstlisting}[language=C++]
#define MX (1<<17)
#define AL (130)
#define PT (1024)
bool o[PT];
int g[MX][AL],f[MX],E,q[MX];
vi O[MX];
void ini(){E=1;for(auto&h:O)h.clear();F(AL)g[0][i]=0;CL(f,0);}//MODIFY!! - no test for 2+
void add(char*s,int I){
    int L=strlen(s),u=0,c;
    F(L){
        if(!g[u][c=s[i]]){
            g[u][c]=E++;
            F(AL)g[E-1][i]=0;
        }
        u=g[u][c];
    }
    O[u].PB(I);
}
void bld(){
    int x,r,b=-1,e=0,u;
    F(AL)if(g[0][i])f[g[0][i]]=0,q[e++]=g[0][i];
    while(++b<e)F(AL){
        x=g[u=q[b]][i],r=g[f[u]][i];
        if(!x)g[u][i]=r;
        else{
            q[e++]=x,f[x]=r;
            for(auto&h:O[r])O[x].PB(h);
        }
    }
}
void fnd(char*T){
    int L=strlen(T),u=0,c;
    F(L){
        c=T[i];
        while(u&&!g[u][c])u=f[u];
        u=g[u][c];
        for(auto&h:O[u])o[h]=1;
    }
}
#define CAL(s) CL(o,0),fnd(s)
\end{lstlisting}
\subsection{Binární vyhledávání}
\begin{center}
lower\_bound a upper\_bound
\end{center}
\begin{lstlisting}[language=C++]
// lower_bound/upper_bound example
#include <iostream>     // std::cout
#include <algorithm>    // std::lower_bound, std::upper_bound, std::sort
#include <vector>
#include <stdio.h>       // std::vector
int main () {
  int myints[] = {5,10,20,30,30,20,10,10,20,666};
  std::vector<int> v(myints,myints+8);           // 5 10 20 30 30 20 10 10 20 666
  std::sort (v.begin(), v.end());                // 5 10 10 10 20 20 20 30 30 666
  for(int i(0);i<(int)v.size();++i)
      printf("%d(%d) ",v[i],i);
  putchar('\n');
  std::vector<int>::iterator lowA,upA,lowB,upB,lowC,upC,lowD,upD;
  lowA=std::lower_bound (v.begin(), v.end(), 20); //          ^
  upA= std::upper_bound (v.begin(), v.end(), 20); //                   ^
  lowB=std::lower_bound (v.begin(), v.end(), 25); //          ^
  upB= std::upper_bound (v.begin(), v.end(), 25); //                   ^
  lowC=std::lower_bound (v.begin(), v.end(), 1); //          ^
  upC= std::upper_bound (v.begin(), v.end(), 1); //                   ^
  lowD=std::lower_bound (v.begin(), v.end(), 700); //          ^
  upD= std::upper_bound (v.begin(), v.end(), 700); //                   ^
  std::cout << "lower_bound [20]at position " << (lowA- v.begin()) << '\n';
  std::cout << "upper_bound [20]at position " << (upA - v.begin()) << '\n';
  std::cout << "lower_bound [25]at position " << (lowB- v.begin()) << '\n';
  std::cout << "upper_bound [25]at position " << (upB - v.begin()) << '\n';
  std::cout << "lower_bound [1]at position " << (lowC- v.begin()) << '\n';
  std::cout << "upper_bound [1]at position " << (upC - v.begin()) << '\n';
  std::cout << "lower_bound [700]at position " << (lowD- v.begin()) << '\n';
  std::cout << "upper_bound [700]at position " << (upD - v.begin()) << '\n';
  return 0;
}
\end{lstlisting}
\verb|5(0) 10(1) 10(2) 10(3) 20(4) 20(5) 30(6) 30(7)|
\\\verb|lower_bound [20]at position 4|
\\\verb|upper_bound [20]at position 6|
\\\verb|lower_bound [25]at position 6|
\\\verb|upper_bound [25]at position 6|
\\\verb|lower_bound [1]at position 0|
\\\verb|upper_bound [1]at position 0|
\\\verb|lower_bound [700]at position 8|
\\\verb|upper_bound [700]at position 8|
\begin{center}
Vlastní binary search
\end{center}
\begin{lstlisting}[language=C++]
int binS(int w,int b,int e){
    if(b==e)return b;
    int k((b+e)>>1);
    return v[k]<w?binS(w,k+1,e):binS(w,b,k);
}
\end{lstlisting}
Vyhledává v poli \textsf{v} - začátek i konec jsou v poli.
\\\verb|5(0) 10(1) 10(2) 10(3) 20(4) 20(5) 30(6) 30(7)|
\\\verb|20: 4|
\\\verb|25: 6|
\\\verb|1: 0|
\\\verb|700: 7|
\\Binary Search pomocí funkce $ok$ na intervalu \textbf{[}\textsf{B}\textit{,}\textsf{E}\textbf{]}
\\Pokud je odpověď "ještě" $ok$, funkce $ok$ vrací $true$
\begin{lstlisting}[language=C++]
bool ok(ld H){
    //TODO
}
ld bs(ld B=0,ld E=INF){
    ld M;
    while(!EQ(B,E))
        if(ok(M=(B+E)/2))E=M;
        else B=M;
    return B;
}
\end{lstlisting}
Binary Search pomocí funkce $ok$ na intervalu \textbf{[}\textsf{B}\textit{,}\textsf{E}\textbf{]}
\\Pokud je odpověď "už" $ok$, funkce $ok$ vrací $true$
\begin{lstlisting}[language=C++]
bool ok(ll t){
    //TODO
}
ll bs(ll B=0,ll E=INF){
    ll M;
    while(B<E)
        if(ok(M=(B+E)>>1))E=M;
        else B=M+1;
    return max(B-1,0ll);
}
\end{lstlisting}
\subsection{Burrows Wheeler}
Inverze Burrows Wheelera, pokud známe vzniklý řetězec \textsf{s} a řádek \textsf{R}, ve kterém byl původní string.
\\Původní řětězec bude uložen v poli \textsf{o}
\\Složitost $O(nlog(n))$, kde $n$ je délka řetězce (jde napsat v $O(n)$ za použití counting sortu).
\begin{lstlisting}[language=C++]
void bwlI(char *s,char *o,int R){
    static char w[MX];
    static int n[MX];
    int L(strlen(s)),j,l(o[L]=0);
    strcpy(w,s);sort(w,w+L);
    F(L){
        if(i&&w[i]==w[i-1])++j;
        else j=0;
        while(w[i]!=s[j])++j;
        n[i]=j;
    }
    j=n[R];
    F(L)o[l++]=s[j],j=n[j];
}
\end{lstlisting}
Rekonstrukce lexikograficky nejnižšího stringu ze zadaného Suffix Arraye (indexace od 0)
\\Vstupem je délka SA, SA a výstupní string. Návratovou hodnotou je, zda-li lze takový string zrekonstruovat.
\\String může mít pouze malá písmena - úprava na řádcích \textbf{5} a \textbf{6}.
\\Složitost $O(N)$
\begin{lstlisting}[language=C++]
#define MX (1<<19)
bool solve(int N,int*SA,char*s){
    static int b[MX];
    F(N)b[SA[i]]=i;
    s[N]=0,b[N]=-1,s[*SA]=97;//least-char
    FT(1,N)if((s[SA[k]]=s[SA[k-1]]+(b[SA[k]+1]<b[SA[k-1]+1]))>'z')return 0;;
    return 1;
}
\end{lstlisting}
\subsection{Frekvence čísel}
Funkce $bld$ slouží k vybudování \textit{Sparse Table} z posloupnosti, která je neklesající (mělo by fungovat i s nerostoucí).
\\Pomocí $g1$ lze pak dotazovat query, které vrátí počet nejčetnějšího čísla na intervali \textsf{i} až \textsf{j}.
\\Složitost vybudování $O(Nlog(N))$ a query je pak $O(log(n))$ (nicméně na bitech - jinak konstantní).
\begin{lstlisting}[language=C++]
#define LG (18)
#define MX (1<<LG)
int V[MX][LG];
#define XP(N) (sizeof(N)*8-__builtin_clz(N)-1)
int L[MX],R[MX];
void bld(int *A,int n){
    int T(0),b(*A),h;
    F(n){	
        if(A[i]==b)++T;
        else{
            h=i-1;
            while(~h&&A[i-1]==A[h])*V[h--]=T;
            T=1;
        }b=A[i];
    }h=n-1;
    while(~h&&A[n-1]==A[h])*V[h--]=T;
    *L=0,R[n-1]=n-1;
    FT(1,n)if(A[k]==A[k-1])L[k]=L[k-1];
           else L[k]=k;
    for(int i(n-2);~i;--i)
        if(A[i]==A[i+1])R[i]=R[i+1];
        else R[i]=i;
    for(int k(1),t(2);t<n;++k,t<<=1)F(n-t+1)
        V[i][k]=max(V[i][k-1],V[i+(t>>1)][k-1]);
}
int g1(int i,int j,int*A) {
    int a(R[i]+1),l(L[j]-1),k,r(0);
    if(a<=l)
        k=XP(l-a+1),r=max(V[a][k],V[l-(1<<k)+1][k]),
        r=max(max(r,(a-1)-i+1),j-(l+1)+1);
    else if(A[i]!=A[j])
        r=max(a-i,j-l);
        else r=j-i+1;
    return r;
}
\end{lstlisting}
Funkce, která naleznce nejfrekventovanější číslo a jeho frekvenci na intervalu.
\\Funkce potřebuje mít vyplněno $N$ a $A$ před spuštěním.
\\Funkce pre udělá předpočet $O(N\sqrt{N})$
\\Funkce $qy$ nalezne nejfrekventovanější čílo a jeho frekvenci na intervalu $O(\sqrt{N})$
\\Čísla musí být $<$ MX (pokud nejsou, tak je nutno normalizovat)
\\Čištění (zakomentovaná část) zatím není otestováno!
\begin{lstlisting}[language=C++]
#define MX (100020)
#define SQ (220)
#define DV (MX/SQ+2)
int A[MX],N,S[MX][DV],M[MX],L[MX],G[DV][DV],I[DV][DV],Z[MX];
void pre(){
    //CL(S,0),CL(M,0);
    F(N)L[A[i]]=i,++M[A[i]],++S[A[i]][i/SQ];
    F(MX)if(M[i]>1)FT(1,DV)S[i][k]+=S[i][k-1];
    F(DV){
        int X=0,B=0;
        FT(SQ*i,N){
            if(++Z[A[k]]>=X){
                if(Z[A[k]]>X)X=Z[A[k]],B=A[k];
                else B=min(B,A[k]);
            }
            if(i/SQ^(k+1)/SQ)G[i][k/SQ]=X,I[i][k/SQ]=B;
        }
        CL(Z,0);
    }
}
#define SM(D) (M[D]>1?(S[D][R]-(L?S[D][L-1]:0)):0)
ii qy(int b,int e){
    int L=b/SQ+!!(b%SQ),R=(e+1)/SQ-1,X=0,B;
    if(2*SQ+2>e-b){
        FT(b,e+1)if(++Z[A[k]]>=X){
            if(Z[A[k]]>X)X=Z[A[k]],B=A[k];
            else B=min(B,A[k]);
        }
        FT(b,e+1)Z[A[k]]=0;
        return {X,B};
    }
    X=G[L][R],B=I[L][R];
    FT(b,L*SQ)if(++Z[A[k]]+SM(A[k])>=X){
        if(Z[A[k]]+SM(A[k])>X)X=Z[A[k]]+SM(A[k]),B=A[k];
        else B=min(B,A[k]);
    }
    FT((R+1)*SQ,e+1)if(++Z[A[k]]+SM(A[k])>=X){
        if(Z[A[k]]+SM(A[k])>X)X=Z[A[k]]+SM(A[k]),B=A[k];
        else B=min(B,A[k]);
    }
    FT(b,L*SQ)Z[A[k]]=0;
    FT((R+1)*SQ,e+1)Z[A[k]]=0;
    return {X,B};
}
\end{lstlisting}
\subsection{Edit Distance}
Vstupem jsou dva řetězce a jejich délky
\\Výstupem je počet operací (delete,insert,replace), pomocí kterých lze první řetězec přeměnit na ten druhý.
\\Složitost $O(n*m)$.
\begin{lstlisting}[language=C++]
#define MX (2048)
int ed(char*s,char*r,int m,int n){
    static int t[MX][MX];
    F(m+1)FF(n+1)t[0][j]=j,t[i][0]=i;
    F(m)FF(n)t[i+1][j+1]=min(min(t[i][j+1]+1,t[i+1][j]+1),t[i][j]+(s[i]!=r[j]));
    return t[m][n];
}
\end{lstlisting}
Verze s lineární paměťovou složitostí (nelze upravit aby šlo rekonstruovat)
\begin{lstlisting}[language=C++]
int ed(char*s,char*r,int m,int n){
    static int t[2][MX];
    iota(*t,*t+n+1,0);
    F(m)FF(n)t[(i+1)&1][j+1]=min(min(t[i&1][j+1]+1,j?t[(i+1)&1][j]+1:i+2),(j?t[i&1][j]:i)+(s[i]!=r[j]));
    return t[m&1][n];
}
\end{lstlisting}
\subsection{Index lexikograficky nejnižšího cyklického řetězce}
Nalezne index lexikograficky nejnižšího cyklického řetězce - tedy lexikograficky nejmenší řetězec po rotaci písmen.
\\Složitost $O(n)$ (nejsem si však jist, zda-li tam není nějaký posek v implementaci)
\\Pozor - po provedení funkce bude vstupní řetězec znetvořen (bude obsahovat kopii sebe sama za sebou) - je tedy nutné aby měl dvojnásobnou délku, něž by bylo potřeba.
\begin{lstlisting}[language=C++]
int idx(char *c,int N){
    int R(0);
    char *p,*d;
    memcpy(c+N,c,N);
    for(int j(1),k(0);j<N;k=0){
        p=c+R,d=c+j;
        while(p[k]==d[k]&&k<N)++k;
        if(p[k]>d[k])R=max(R+k+1,j);
        else ++j+=k;
        if(R==j)++j;
    }
    return R;
}
\end{lstlisting}
Snad kratší verze - ještě ale chce otestovat.
\begin{lstlisting}[language=C++]
int idx(char*s,int N){
    F(N)s[N+i]=s[i];
    int a=0;
    FF(N)F(N)if(a+i==j||s[a+i]<s[j+i]){j+=max(0,i-1);break;}
             else if(s[a+i]>s[j+i]){a=j;break;}
    return a;
}
\end{lstlisting}
\subsection{Indexace řetězců}
Řetězci je přiřazen index. Pod ním je pak dohledatelný v poli \textsf{R}.
\begin{lstlisting}[language=C++]
int C;
string R[MX];
unordered_map<string,int> T;
int gt(string s){
    if(T.count(s))return T[s];
    return R[C]=s,T[s]=C++;
}
#define CLR (C=0,T.clear())
\end{lstlisting}
Bez pamatování stringu.
\begin{lstlisting}[language=C++]
int C;
unordered_map<string,int> T;
int gt(string s){return T.count(s)?T[s]:T[s]=C++;}
#define CLR (C=0,T.clear())
\end{lstlisting}
Obdobně s char* (trochu poladit, nějaké pomalé zdá se - zmenšit universum!)
\\V MP je nějaká mapující funkce aby mohlo být menší univerzum
\begin{lstlisting}[language=C++]
#define SZ (1<<14)
#define OO (1<<10)
#define OL (16)
#define UV (52)
#define MP(C) (islower(C)?C-'a':C-'A'+26)
int t[UV][SZ],L(1),CT,E[SZ];
char T[OO][OL];
int trans(char *c){
    if(!CT){F(UV)t[i][0]=-1;L=1;*E=-1;}
    int nd(0);
    for(int i(0);c[i];++i)if(~t[MP(c[i])][nd])
            nd=t[MP(c[i])][nd];
        else{
            t[MP(c[i])][nd]=L,nd=L++;E[nd]=-1;
            F(UV)t[i][nd]=-1;
        }
    if(~E[nd])return E[nd];
    strcpy(T[CT],c);
    return E[nd]=CT++;
}   
\end{lstlisting}
\subsection{Knuth–Morris–Pratt}
Zjistí, zda-li je pattern \textsf{p} obsažen v textu \textsf{t}.
\\Složitost $O(n+m)$ (délky obou textů).
\begin{lstlisting}[language=C++]
#define MX (1024)
void preKMP(const char *p,int *f){
    *f=-1;
    for(int i(1),k;p[i];++i){
        k=f[i-1];
        while(~k&&p[k]!=p[i-1])k=f[k];
        f[i]=k+1;
    }
}
bool KMP(const char *p,const char *t){
    static int f[MX];  
    preKMP(p,f);     
    for(int i(0),k(0),m(strlen(p));t[i];)
        if(!~k)
            ++i,k=0;
        else if(t[i]==p[k]){
            ++i;
            if(++k==m)return 1;
        } else k=f[k];
    return 0;
}
\end{lstlisting}
Verze, kde v \textsf{o} budou všechny indexy výskytů.
\\Složitost až $O(N)$
\begin{lstlisting}[language=C++]
#define MX (1<<22)
vi o;
void preKMP(const char *p,int *f){
    *f=-1;
    for(int i(1),k;p[i];++i){
        k=f[i-1];
        while(~k&&p[k]!=p[i-1])k=f[k];
        f[i]=k+1;
    }
}
void KMP(const char *p,const char *t){
    static int f[MX];  
    preKMP(p,f);
    for(int i(0),k(0),m(strlen(p));t[i];)
        if(!~k)++i,k=0;
        else if(t[i]==p[k]){
            ++i;
            if(++k==m)o.PB(i-k),k=f[k-1],--i;//Repaired? O(N)
        }else k=f[k];
}
\end{lstlisting}
\subsection{Lexikograficky nejmenší superstring}
Je zadáno až \textsf{MS} řetězců (délky až \textsf{MX}). Funkce $sos$ nejkratší (za předpkladu vícero možností i lexikograficky nejnižší) řetězec, který obsahuje jako podstringy všechny řetězce.
\\Složitost $O(MX*2^{MS})$
\begin{lstlisting}[language=C++]
#define MX (101)
#define MS (15)
#define S(A) ((ll)A.size())
typedef vector<string> vs;
int T,ov[MX][MX],dp[MX][(1<<MS)];
string B;
int in(vs&W,int a,int b){
    if(!~a)return S(W[b]);
    int &v(ov[a][b]),x;
    if(~v)return v;
    F(S(W[a])){
        x=1;
        FF(S(W[b])&&i+j<S(W[a])&&x)x&=W[a][i+j]==W[b][j];
        if(x)return v=S(W[b])-S(W[a])+i;
    }
    return v=S(W[b]);
}
int go(vs&W,int l,int cn){
    int &v(dp[l+1][cn]);
    if(cn==T)return v=0;
    if(~v)return v;
    v=INF;
    F(S(W))if(!((cn>>i)&1))v=min(v,go(W,i,cn|(1<<i))+in(W,l,i));
    return v;
}
void fB(vs&w,int l,int cn,string s){
    if(s>B)return;
    if(cn== T){B=min(B,s);return;}
    int e;
    F(S(w))if(!((cn>>i)&1)&&dp[l+1][cn]==dp[i+1][cn|1<<i]+(e=in(w,l,i)))
        fB(w,i,cn|1<<i,s+w[i].substr(S(w[i])-e,e));
}
string sos(vs&W){
    F(S(W))FF(S(W))if(i<S(W)&&i!=j&&~W[i].find(W[j]))
    	swap(W[j--],W[S(W)-1]),W.pop_back();
    CL(ov,-1),CL(dp,-1);
    T=(1<<S(W))-1,go(W,-1, 0);
    B = 127;//lexikograficaly last char
    fB(W,-1,0,"");
    return B;
}
\end{lstlisting}
\subsection{LCP array}
Na vstupu jsou Suffix Array \textsf{sa}, LCP array \textsc{lcp} (to je výstup algoritmu), délka řetězce \textsf{n} a řetězec samotný \textsf{s};
\\Složitost $O(n)$
\begin{lstlisting}[language=C++]
void lcp(int*sa,int*lcp,int n,uc*s){
    static int r[MX];
    F(n)r[sa[i]]=i,lcp[i]=0;;
    int h(0);F(n)if(r[i]<n-1){
        for(int j(sa[r[i]+1]);s[i+h]==s[j+h];++h);
        lcp[r[i]]=h;
        if(h)--h;
    }
}
\end{lstlisting}
Jednoduchý $O(n^3)$ předpočet všech dvojic, pro dva rozdílné stringy.
\begin{lstlisting}
int sme(char*s,char*r){
    int i(0);
    while(s[i]&&r[i]&&s[i]==r[i])++i;
    return i;
}
void lcp(char C[MX][MX]){
    F(S)FF(R)C[i][j]=sme(s+i,r+j);
}
\end{lstlisting}
\subsection{Manacherův Algoritmus}
Vstupem je vstupní text a jeho délka;
\\Výstupem je délka nejdelšího substringu - palindromu.
\\Ten se nachází mezi indexy \textsf{b} a \textsf{e};
\\Složitost $O(n)$
\\Pozor, je třeba více jak dvojnásobné velikosti pole, než je maximální délka textu. (viz řádek 5)
\begin{lstlisting}[language=C++]
int lps(char *s,int N){
    static int L[MX];
    if(!N)return 0;
    int C(1),R(2),l(0),P(0),b,e;
    N=(N<<1)+1;
    L[0]=0,L[1]=1;
    FT(2,N){
        L[k]=(R-k>0)*min(L[2*C-k],R-k);
        while(k+L[k]<N&&k-L[k]>0&&(!((k+L[k]+1)&1)||
            s[(k+L[k]+1)>>1]==s[(k-L[k]-1)>>1]))
                L[k]++;
        if(L[k]>l)l=L[P=k];
        if(k+L[k]>R)R =k+L[C=k];
    }
    b=(P-l)>>1;
    e=b+l-1;
    return e-b+1;
}
\end{lstlisting}
Úprava na dva po sobě jdoucí sudé palindromy (trochu ztrácí složitost, ale na 300 000 proběhlo pořád rozumně).($\omega\omega^R\omega\omega^R$)
\begin{lstlisting}[language=C++]
bool ck(char *s,int b,int e){
    while(b<e)if(s[b++]!=s[e--])return 0;
    return 1;
}
int lps(char *s,int N){
    static int L[MX];
    if(!N)return 0;
    int C(1),R(2),l(0),P(0),b,e;
    N=(N<<1)+1;
    L[0]=0,L[1]=1;
    FT(2,N){
        L[k]=(R-k>0)*min(L[2*C-k],R-k);
        while(k+L[k]<N&&k-L[k]>0&&(!((k+L[k]+1)&1)||
             s[(k+L[k]+1)>>1]==s[(k-L[k]-1)>>1])){
                L[k]++;
                if(L[k]>l&&!(L[k]&3)&&(L[k-(L[k]>>1)]==L[k]>>1||
                (L[k-(L[k]>>1)]>=L[k]>>1&&ck(s,(k-L[k])>>1,((k-L[k])>>1)+(L[k]>>1)-1))))
                        l=L[P=k];
        }
        if(k+L[k]>R)R=k+L[C=k];
    }
    b=(P-l)>>1;
    e=b+l-1;
    return e-b+1;
}
\end{lstlisting}
Funkce přijme string, jeho délku a output Manachera. Do pole \textsf{D} pak vyplní "nejdelší palindrom začínající na indexu $i$". Pokud nás budou zajímat pouze sudé či pouze liché palindromy, stačí zakomentovat jednu část if/else. 
\\Složitost $O(L)$
\begin{lstlisting}[language=C++]
void eo(uc*s,int L,int*W,int*D){
    F(L*2+1)if(W[i]){
        if(i&1)D[i/2-W[i]/2]=max(D[i/2-W[i]/2],W[i]);
        else D[i/2-W[i]/2]=max(D[i/2-W[i]/2],W[i]);
    }
    FT(1,L)D[k]=max(D[k-1]-2,D[k]);
}
\end{lstlisting}
Jiná verze manachera. Zde v \textsf{R} jsou uloženy délky palindromů pramenících z pozic [viz manacher style]
\begin{lstlisting}[language=C++]
int lps(char *s,int N,int*R){
    static char t[2*MX];
    int m=N*2-1,X=0,x=0;
    fill(t,t+m,-1);
    F(N)t[i<<1]=s[i];
    FT(1,m){
        int &r=R[k]=0;
        if(k<=x+R[x])r=min(R[x+x-k],x+R[x]-k);
        while(k-r-1>=0&&k+r+1<m&&t[k-r-1]==t[k+r+1])++r;
        if(k+r>=x+R[x])x=k;
    }
    F(m)if(i==R[i]||i+R[i]==m-1)++R[i];
    F(m)X=max(R[i],X);
    return X;
}
\end{lstlisting}
\subsection{Maximální součet podposloupnosti [query]}
Je dána posloupnost kladných a záporných čísel. Na ní se hledají nejlepší výsledky na podposloupnostech (query). Indexace od 1.
\\Složitost query je $O(log(N))$
\begin{lstlisting}[language=C++]
#define PR(A,X) (X?A.second:A.first)
#define MX (1<<19)
#define LL l,m,rt<<1
#define RR m+1,r,rt<<1|1
struct IT{
    ll S[MX];
    ll gs(int L,int R){
        return S[R]-S[L-1];
    }
    ii br(ii a,ii b){
        if(gs(PR(a,0),PR(a,1))!=gs(PR(b,0),PR(b,1)))
        	return gs(PR(a,0),PR(a,1))>gs(PR(b,0),PR(b,1))?a:b;
        return a<b?a:b;
    }
    int qL,qR,n,L[MX<<2],R[MX<<2];
    ii X[MX<<2];
    void ini(int N,int *a){
        *S=0;
        F(N)S[i+1]=S[i]+a[i];
        bld(1,n=N,1);
    }
    void bld(int l,int r,int rt){
        if(l==r)
            L[rt]=R[rt]=l,X[rt]={l,l};
        else{
            int m((l+r)>>1);
            bld(LL),bld(RR);
            ll v1(gs(l,L[rt<<1])),v2(gs(l,L[rt<<1|1]));
            if(v1==v2)L[rt]=min(L[rt<<1],L[rt<<1|1]);
            else L[rt]=v1>v2?L[rt<<1]:L[rt<<1|1];
            v1=gs(R[rt<<1],r),v2=gs(R[rt<<1|1],r);
            if(v1==v2)R[rt]=min(R[rt<<1],R[rt<<1|1]);
            else R[rt]=v1>v2?R[rt<<1]:R[rt<<1|1];
            X[rt]=br(X[rt<<1],X[rt<<1|1]),
            X[rt]=br(X[rt],{R[rt<<1],L[rt<<1|1]});
        }
    }
    ii ql(int l,int r,int rt){
        if(L[rt]<=qR)return {l,L[rt]};
        int m((l+r)>>1);
        if(qR<=m)return ql(LL);
        ii i(ql(RR));
        PR(i,0)=l;
        return br(i,{l,L[rt<<1]});
    }
    ii qr(int l,int r,int rt){
        if(R[rt]>=qL)return {R[rt],r};
        int m((l+r)>>1);
        if(qL>m)return qr(RR);
        ii i(qr(LL));
        PR(i,1)=r;
        return br(i,{R[rt<<1|1],r});
    }
    ii qry(int l,int r,int rt){
        if(qL<=l&&r<=qR)return X[rt];
        int m((l+r)>>1);
        if(qR<=m)return qry(LL);
        if(qL>m) return qry(RR);
        ii i1(qr(LL)),i2(ql(RR)),i3(br(qry(LL),qry(RR)));
        return br({PR(i1,0),PR(i2,1)},i3);
    }
    ii gt(int f,int t){return qL=f,qR=t,qry(1,n,1);}
}A;
\end{lstlisting}
Pouze nalezení, pokud nejsou query.
\\Pokud je vícero posloupností, je nalezena ta, která je nejdelší.
\\Začátek a konec posloupnosti budou uloženy v \textsf{u} a \textsf{v} (pozor, indexy trochu jinak - upravit!!)
\\Složitost je $O(N)$
\begin{lstlisting}[language=C++]
int fnd(int N,int*A,int&u,int&v){
    int B=-INF,I(u=v=0),S=-1;
    F(N){
        if(S>=0)S+=A[i];
        else S=A[i],I=i+1;
        if(S>B||(S==B&&v-u<i+2-I))B=S,v=i+2,u=I;
    }
    return B;
}
\end{lstlisting}
\subsection{Maximální součin podposloupnosti}
\begin{lstlisting}[language=C++]
ll msp(ll *a,ll n){
    ll x(1),h(1),r(1),t;
    F(n){
        if(a[i]>0)x*=a[i],h=min(h*a[i],1LL);
        else if(!a[i])x=h=1;
        else t=x,x=max(h*a[i],1LL),h=t*a[i];
        r=max(x,r);
    }
    return r;
}
\end{lstlisting}
\subsection{Medián}
Struktura, která umí dynamicky udržovat medián.
\\Funkce $ad$ přidá prvek do množiny.
\\Funkce $MB$ vrátí medián.
\\Funkce $MA$ vrátí druhý medián (pokud jsou dva)
\\V proměnných \textsf{U} a \textsf{V} je suma každé půlky množiny (menší/větší, než-li medián).
\begin{lstlisting}[language=C++]
struct MED{
    multiset<int> A,B;
    ll U,V;
    ll dif(){return U-V;}
    int MA(){return *--A.end();}
    int MB(){return *B.begin();}
    void ad(int a){
        if(!B.empty()&&a>MB())V+=MB(),U+=a-MB(),A.insert(MB()),B.erase(B.begin()),B.insert(a);
        else A.insert(a),V+=a;
        if(B.size()<A.size())V-=MA(),U+=MA(),B.insert(MA()),A.erase(--A.end());
    }
    void clr(){A.clear(),B.clear(),U=V=0;}
}M;
\end{lstlisting}
\subsection{MO}
Struktura přijme jednotlivé query, které zpracuje a vypočítá ($offline$)
\begin{itemize}
\item \textbf{CLR}: Inicializace!
\item \textbf{QY}: Přidá query ke zpracování
\item \textbf{GO}: Vypočítá jednotilivé query - složitost $O((N+Q)\sqrt{N})$
\end{itemize}
Dále je zde několik dalších funkcí, které se musí dopsat dle funkcionality.
\begin{itemize}
\item \textbf{add}: Query je provedeno na prvku s indexem \textsf{w} 
\item \textbf{add}: Query nebude provedeno na prvku s indexem \textsf{w}
\item \textbf{st}: Inicializace
\item \textbf{ans}: Vrátí výsledek, pokud je query provedeno nad zadaným intervalem.
\end{itemize}
Jakékoli další globální pole, které je při výpočtu využito, a další pomocné proměnné musí být též dopsány!
\begin{lstlisting}[language=C++]
#define MX (1<<28)
#define SQ (222)
int N,Q,a,b,A[MX],O[MX];
struct MOQ{
    int b,e,i;
    bool operator<(const MOQ&r)const{return b/SQ^r.b/SQ?b/SQ<r.b/SQ:e<r.e;}
};
struct MO{
    MOQ T[MX];
    int C[MX],L,b,e;
    void CLR(){L=0;}//clr not tested
    void QY(int b,int e){T[L]={min(b,e),max(b,e),L};++L;}
    void GO(int*O){
        CL(C,0),st();
        sort(T,T+L),b=T[0].b-1,e=T[0].b-1;
        F(L){
            while(b>=T[i].b)add(b--);
            while(e<T[i].e)add(++e);
            while(b+1<T[i].b)del(++b);
            while(e>T[i].e)del(e--);
            O[T[i].i]=ans();
        }
    }
    //MO
	int H,Z[1<<21];
    void add(int w){
        H+=!Z[A[w]]++;
    }
    void del(int w){
        H-=!--Z[A[w]];
    }
    int ans(){
        return H;
    }
    void st(){
        CL(Z,H=0);
    }
}T;
\end{lstlisting}
\subsection{Nalezení indexu prvního výskytu patternu}
Načtou se sekvence (funguje samozřejmě i na stringy) do \textsf{r,q}, kde r je pattern a v q vyhledáváme.
\\První se vybuduje automat (a[\textit{max délka patternu}][\textit{univerzum}]) a poté se funkcí all vyhledá první shoda.
\begin{lstlisting}[language=C++]
int a[60000][256],r[1<<17],q[1<<17],ac,tp,s,k,m,n,mn;
void am(void){
    for(int i(a[0][r[0]]=1),b(0);i<m;++i){
        for(int c(0);c<256;++c)
            a[i][c]=a[b][c];
        ac=r[i];
        a[i][ac]=i+1;
        b=a[b][ac];
    }
}
inline int add(int c,int&e){
    if((tp=a[s][c])==m)
        return e-=m-1;
    else
        s=tp,++e;
    return -1;
}
int all(void){
    for(int i(s=k=0);i<n;++i)
        if(~add(q[i],k))
            return k;
    return -1;
}
\end{lstlisting}
\subsection{Nalezení nejdelšího podřetězce dvou řetězců}
Nalezne délku nejdelšího společného podřetězce dvou řetězců.
\\Dále je nutno naimplementovat $suffix array$ a $lcp$ (viz. lcp a suffix array).
\\\textsf{UF} je char, který zaručeně nebude v řetězcích (ideálně jiný než 0 - to by se mohlo lišit o 1 (výsledek))
\\Složitost dle $sa$ a $lcp$ - takže optimálně $O(n)$
\begin{lstlisting}[language=C++]
#define UF ('$')
int lcs(char*s,char*r){
    static unsigned char c[MX<<1];
    static int SA[MX<<1],L[MX<<1];
    int A(strlen(s)),B(strlen(r)),R(0);
    strcpy((char*)c,s),c[A]='$',strcpy((char*)c+A+1,r);
    sa(c,SA,A+B+2);
    lcp(SA,L,A+B+2,c);
    F(A+B+1)if((SA[i]<A&&SA[i+1]>A)||(SA[i]>A&&SA[i+1]<A))R=max(L[i],R);
    return R;
}
\end{lstlisting}
Tady navíc je vektor, ve kterém budou indexy do prvního stringu, odpovídající všem nejdelším společným podřetězcům. 
\\Složitost se nemění (navíc jeden lineární průchod).
\begin{lstlisting}[language=C++]
#define MX (1024)
#define UF ('$')
int lcs(char*s,char*r,vi&o){
    o.clear();
    static unsigned char c[MX<<1];
    static int SA[MX<<1],L[MX<<1];
    int A(strlen(s)),B(strlen(r)),R(0);
    strcpy((char*)c,s),c[A]='$',strcpy((char*)c+A+1,r);
    sa(c,SA,A+B+2);
    lcp(SA,L,A+B+2,c);
    F(A+B+1)if((SA[i]<A&&SA[i+1]>A)||(SA[i]>A&&SA[i+1]<A))R=max(L[i],R);
    F(A+B+1)if(((SA[i]<A&&SA[i+1]>A)||(SA[i]>A&&SA[i+1]<A))&&L[i]==R){
        o.PB(SA[i]<A?SA[i]:SA[i+1]);
        while(L[i]>=R&&A+B+1>i)++i;
    }
    return R;
}
\end{lstlisting}
\subsection{Nalezení nejdelšího podřetězce vícero řetězců}
Z předešlých činností je v \texttt{n} uložen počet řetězců a v \texttt{s} jsou pak uloženy řetězce (a v \textsf{l} jejich délky).
\begin{center}
Vybudování automatu:
\end{center}
\begin{lstlisting}[language=C++]
char s[4096][64],c[256],u[256];
int l[4096],ab[256],L,r,n,k;
void am(int b){
    L=*l-b,*ab=-1,ab[1]=0;
    FF(L)c[j]=s[0][j+b];
    FT(2,L){
        int v(ab[k-1]);
        while(~v&&c[k-1]!=c[v])v=ab[v];
        ab[k]=v+1;
    }
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
int lng(int a){
    int p(0),r(0);
    F(l[a]){
        while(~p&&s[a][i]!=c[p])p=ab[p];
        r=max(++p,r);
    }
    return r;
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
r=0;*u=0;int ml;
F(*l){
    am(i),ml=~L?L:1<<30;
    FF(n)if(j)ml=min(ml,lng(j));
    if(ml>r||(r&&ml==r&&strcmp(&s[0][i],u)<0))
        r=ml,strcpy(u,&s[0][i]),u[r]=0;
}
\end{lstlisting}
Výsledný podřetězec je uložen v poli \texttt{u}
\begin{center}
Další metoda - Hashování
\end{center}
Vstupem je \textsf{s} (pole řetězců), \textsf{L} (délky řetězců) a \textsf{N} (počet řetězců).
\\Dále je nutné nastavit parametry \textsf{MS} (maximální pořet řetězců) a \textsf{MX} (jejich maximální délka).
\\Složitost je podle kolizí.
\\Za předpokladu žádných kolizí je složitost $O(N*M*log(N))$, kde M je počet různých řetězců a N je jejich délka.
\\Hashovací funkce je relativně slušná, při špatném případu by však mohla být šložitost až $O(N^M*M*log(N))$ (snad se to nestane ;-) )
\begin{lstlisting}[language=C++]
#define MS (32)
#define MX (1<<17)
#define MOD (2147483647)
#define BS (257)
struct hs{
    ll h;
    char *s;
    bool operator<(const hs&r)const{return h<r.h;}
}f[MS][MX];
ll P[MX]={1},x;
void pw(void){if(!x++)FT(1,MX)P[k]=(P[k-1]*BS)%MOD;}
int polH(hs*f,char*s,int L,int N){
    ll H(0),r(1);
    F(L)H=(H*BS+s[i])%MOD;
    f[0].s=s,f[0].h=H;
    FT(L,N)H=(H*BS+s[k])%MOD,H-=(P[L]*s[k-L])%MOD,H+=H<0?MOD:0,f[r].s=s+r,f[r++].h=H; 
    return r;
}
bool eq(hs&a,hs&b,int D){
    F(D)if(a.s[i]!=b.s[i])return 0;
    return 1;
}
bool cac(int N,int *J,int *S,int *A,int p,int D){
    if(p==N){
        F(N-1)if(!eq(f[i][A[i]],f[i+1][A[i+1]],D))return 0;
        return 1;
    }
    ll H(f[p][J[p]].h);
    A[p]=J[p];
    while(A[p]<S[p]&&f[p][A[p]].h==H){
        if(cac(N,J,S,A,p+1,D))return 1;
        ++A[p];
    }
    return 0;
}
bool ali(int *J,int *S,int N){
    FT(1,N)while(J[k]<S[k]&&f[k][J[k]].h<f[0][*J].h)++J[k];
    FT(1,N)if(J[k]==S[k]||f[k][J[k]].h!=f[0][*J].h)return 0;
    return 1;
}
bool ssr(char s[MS][MX],int *L,int N,int D){
    static int S[MS],J[MS],T[MS];
    F(N)S[i]=polH(f[i],s[i],D,L[i]),sort(f[i],f[i]+S[i]);
    CL(J,0);
    while(*J<*S){
        if(ali(J,S,N))if(cac(N,J,S,T,0,D))return 1;
        while(*J<*S&&f[0][*J].h==f[0][*J+1].h)++J[0];
        ++J[0];
    }
    return 0;
}
int lcs(char s[MS][MX],int *L,int N){
    pw();
    int B(0),E(MX),M;
    F(N)E=min(E,L[i]);
    while(B<E)
        if(ssr(s,L,N,M=(B+E+1)>>1))B=M;
        else E=M-1;
    return B;
}
\end{lstlisting}
Metoda pomocí Suffix Array.
\\Je nutný $import$ lcp, Suffix Array, RMQ
\\$MG$ je maximální počet řetězců
\\$MO$ je maximální délka jednoho řetězce
\\$MX$ pak bude celkévá maximální délka
\\Složitost $O(Nlog(N)+N*MG)$, kde N je délka podřetězců
\begin{lstlisting}[language=C++]
#define MG (6)
#define MO (1<<20)
uc c[MX];
int SA[MX],L[MX],X[MG],C[MX];
int osa(int I,int N){
    int S(0);
    F(N)if(I<(S+=X[i]+1))return i;
    if(I==S)return N;
    assert(0);
}
int lcs(char s[MG][MO],int N){
    F(N)X[i]=strlen(s[i]);
    int R(0),A(0),P(0),I(0),J(-1);
    F(N)strcpy((char*)c+A,s[i]),A+=X[i],c[A++]=128+i;
    c[A]=0,sa(c,SA,A+1),lcp(SA,L,A+1,c),CL(C,0),T.ini(L,A+1),C[N]=INF;
    while(P^N)P+=!C[osa(SA[++J],N)]++;
    while(J<A-N+1){
        if(P^N)P+=!C[osa(SA[++J],N)]++;
        else {
            while(P==N)P-=!--C[osa(SA[I++],N)];
            R=max(R,T.qy(L,I-1,J-1));
        }
    }
    return R;
}
\end{lstlisting}
Suffix Automaton
\\$MX$ je celková dílka stringu
\\$CC$ je velikost abecedy
\\Funkce $MP$ namapuje char na int ($< CC$)
\\Funkce $ini$ inicializuje s počátečním řetězcem
\\Funkce $add$ přidá další řetězec
\\Funkce $lcs$ vrátí velikost největšího společnéhopodřetězce
\begin{lstlisting}[language=C++]
#define MX (2000099)
#define CC (4)
struct SA{
    struct nd{
        nd(){p=0,CL(x,s=a=0),b=INF;}
        nd *x[CC],*p;
        int s,a,b;
    }d[MX],*o[MX],*r,*t,*u;
    int L,C[MX],h;
    int MP(int c){return c==65?0:c=='T'?1:c==67?2:3;}
    void INI(){L=0,r=t=nnd();}
    nd* nnd(){
        nd *p=&d[L++];
        return *p=nd(),p;
    }
    void add(int c,int N) {
        nd *p,*q,*a,*b;
        c=MP(c),p=t,a=nnd(),a->s=N;
        while(p&&!p->x[c])p->x[c]=a,p=p->p;
        t=a;
        if(!p)a->p=r;
        else if(p->x[c]->s==p->s+1)a->p=p->x[c];
        else{
            q=p->x[c],b=nnd(),*b=*q,b->s=p->s+1,q->p=a->p=b;
            while(p&&p->x[c]==q)p->x[c]=b,p=p->p;
        }
    }
    void rs(){
        F(L)C[i]=0;
        F(L)++C[d[i].s];
        F(L)C[i+1]+=C[i];
        F(L)o[--C[d[i].s]]=&d[i];
    }
    void ini(char*s) {
        INI(),h=strlen(s);
        F(h)add(s[i],i+1);
        rs();
    }
    void add(char *s) {
        u=r;
        int c,S=0,h=strlen(s);
        F(L)d[i].a=0;
        F(h){
            if(u->x[c=MP(s[i])])++S,u=u->x[c];
            else{
                while(u&&!u->x[c])u=u->p;
                if(!u)S=0,u=r;
                else S=u->s+1,u=u->x[c];
            }
            u->a=max(u->a,S);
        }
        for(int i=L-1;~i;--i){
            u=o[i],u->b=min(u->b,u->a);
            if(u->p)u->p->a=max(u->p->a,min(u->p->s,u->a));
        }
    }
    int lcs(){
        int S(0);
        F(L)S=max(S,d[i].b);
        return S;
    }
}T;
\end{lstlisting}
\subsection{Nejdelší nerostoucí podposloupnost}
Nalezení délky nejdelší nerostoucí posloupnosti.
\\Lze změnit na neklesající, pokud nebude proveden $reverse$.
\\Složitost $O(Nlog(N))$
\begin{lstlisting}[language=C++]
int lds(int*a,int S){
    static int C[MX];
    if(!S)return 0;
    int L(1),c;
    reverse(a,A+S),*C=*a;//REVERSE - if not, it is increasing
    FT(1,S)if(a[k]>=C[L-1])C[L++]=a[k];
           else c=upper_bound(C,C+L,a[k])-C,C[c]=a[k];
    return L;
}
\end{lstlisting}
\subsection{Nejdelší rostoucí podposloupnost}
Najde délku nejdelší rostoucí podposloupnosti (nemusí být spojitá).
\\Složitost $O(nlog(n))$
\\Indexy posloupnosti budou uloženy v parametru \textsf{b}.
\\Návratovou hodnotou je délka takové podposloupnosti.
\\Vstupem je sekvence uložená v poli \textsf{a} s délkou \textsf{AS}.
\begin{lstlisting}[language=C++]
int lis(int *a,int AS,int *b){
    if(!AS)return 0;
    static int p[MX];
    int u,v,L(1),c;
    *b=0;
    FT(1,AS)
        if(a[b[L-1]]<a[k])
            p[k]=b[L],b[L++]=k;
        else{
            for(u=0,v=L-1;u<v;)
                if(a[b[c=(u+v)>>1]]<a[k])u=c+1;
                else v=c;
            if(a[k]<a[b[u]]){
                if(u>0)p[k]=b[u-1];
                b[u]=k;
            }
        }
    for(u=L,v=b[L-1];--u;v=p[v]) 
        b[u]=v;
    return L;
}
\end{lstlisting}
Jiná verze - posloupnost je "TA POSLEDNÍ", která se vyskytuje (v \textsf{C}).
\begin{lstlisting}[language=C++]
int lis(int*a,int S,int*C){
    static int D[MX],X[MX];
    if(!S)return 0;
    int L(1),c,H,t;
    *C=*a,*X=-1,*D=0;
    FT(1,S)if(a[k]>C[L-1])D[L]=k,X[k]=D[L-1],C[L++]=a[k];
           else c=lower_bound(C,C+L,a[k])-C,C[c]=a[k],D[c]=k,X[k]=c?D[c-1]:-1;
    H=L-1,t=D[L-1];
    while(~H)C[H--]=a[t],t=X[t];
    return L;
}
\end{lstlisting}
\begin{center}
Nejdelší ohodnocená rostoucí/klesající posloupnost
\end{center}
Složitost $O(n^2)$
\\Vstupem jsou velikosti \textsf{H}, hodnoty \textsf{W} a počet prvků \textsf{N}.
\\Návratovou hodnotou je hodnota nejhodnotnější klesající a rostoucí posloupnosti.
\begin{lstlisting}[language=C++]
#define MX (1<<14)
ii wd(int *H,int *W,int N){
    static int I[MX],d[MX];
    int X(0),O(0),u;
    F(N){
        u=I[i]=d[i]=W[i];
        FF(i)
            if(H[j]<H[i])I[i]=max(I[i],u+I[j]);
            else if(H[j]>H[i])d[i]=max(d[i],u+d[j]);
        X=max(X,I[i]);
        O=max(O,d[i]);
    }
    return {O,X};
}
\end{lstlisting}

\subsection{Nejdelší společná podposloupnost}
Najde délku nejdelší společné podposloupnosti (nemusí být spojitá) dvou posloupností.
\\Složitost $O(n^2)$
\begin{lstlisting}[language=C++]
int dp[MX][MX];
int lcs(int*r,int rs,int *s,int ss){
    for(int i(0);i<=rs;++i)
        for(int j(0);j<=ss;++j)
            if(!i||!j)
                dp[i][j]=0;
            else if(r[i-1]==s[j-1])
                dp[i][j]=dp[i-1][j-1]+1;
            else
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
    return dp[rs][ss];
}
\end{lstlisting}
Najde nejdelší společnou podposloupnost a uloží jí do \textsf{lcs} (s délkou \textsf{LL}).
\\Složitost $O(n^2)$
\begin{lstlisting}[language=C++]
void lcs(int *X,int *Y,int m,int n,int *lcs,int &LL){
    static int L[MX][MX],D;
    for(int i(0);i<=m;++i)
        for(int j(0);j<=n;++j)
            if(!i||!j)L[i][j]=0;
            else if(X[i-1]==Y[j-1])
                L[i][j]=L[i-1][j-1]+1;
            else L[i][j]=max(L[i-1][j],L[i][j-1]);
    LL=D=L[m][n];
    int i(m),j(n);
    while(i&&j)
        if(X[i-1]==Y[j-1])
            lcs[D-1]=X[i-1],--i,--j,--D;
        else if(L[i-1][j]>L[i][j-1]) --i;
        else --j;
}
\end{lstlisting}
\begin{center}
Pro tři posloupnosti ($O(n^3)$)
\end{center}
\begin{lstlisting}[language=C++]
int dp[MX][MX][MX];
int lcs(int *r,int rs,int *s,int ss,int *t,int ts){
   for(int i(0);i<=rs;++i)
       for(int j(0);j<=ss;++j)
           for(int k(0);k<=ts;++k)
               if(!i||!j||!k)
                   dp[i][j][k]=0;
               else if(r[i-1]==s[j-1]&&r[i-1]==t[k-1])
                   dp[i][j][k]=dp[i-1][j-1][k-1]+1;
               else
                   dp[i][j][k]=max(dp[i][j][k-1],max(dp[i-1][j][k],dp[i][j-1][k]));
   return dp[rs][ss][ts];
}
\end{lstlisting}
Pro dva řetězce (výsledek lexikograficky nejmenší).
\\Návratová hodnota je přímo řetězec.
\\Složitost $O(n^3)$
\begin{lstlisting}[language=C++]
#define MX (101)
#define FL ("$")
#define S size()
string dp[MX][MX];
string lcs(char *X,char *Y,int a,int b){
    if(!X[a]||!Y[b])return "";
    string &v(dp[a][b]),w;
    if(v!=FL)return v;
    if(X[a]==Y[b])return v=X[a]+lcs(X,Y,a+1,b+1);
    v=lcs(X,Y,a+1,b);
    w=lcs(X,Y,a,b+1);
    if(w.S>v.S||(w.S==v.S&&w<v))v=w;
    return v;
}
#define CLR F(MX)FF(MX)dp[i][j]=FL;
\end{lstlisting}
Pro dvě permutace (permutace stejných čísel které se neopakují)
\\Složitost $O(Nlog(N))$
\begin{lstlisting}[language=C++]
#define MX (1<<18)
int lcs(int L,int*A,int*B){
    static int P[MX],p[MX],dp[MX],X,c,l;
    F(L)p[A[i]]=i;
    F(L)P[i]=p[B[i]];
    *dp=*P,X=1;
    FT(1,L)if((l=dp[X-1])<(c=P[k]))dp[X++]=c;
           else *lower_bound(dp,dp+X,c)=c;
    return X;
}
\end{lstlisting}
\subsection{Nejdelší společná rostoucí podposloupnost}
Najde délku nejdelší společné rostoucí podposloupnosti (nemusí být spojitá) dvou posloupností.
\\Složitost $O(nlog(n))$
\begin{lstlisting}[language=C++]
#define MX 1<<16
int lsi(int *r,int rs,int *s,int ss){
    static int U[MX],f[MX],d[MX],S,l;
    memset(U,S=l=0,sizeof(U));
    for(int i(0);i<rs;++i)
        U[r[i]]=i+1;
    for(int i(0);i<ss;++i)
        if(U[s[i]])
            f[l++]=U[s[i]];
    memset(U,63,sizeof(U));
    for(int i(0),t;i<l;++i)
        t=lower_bound(U+1,U+l+1,f[i])-U,S=max(d[i]=t,S),U[t]=f[i];
    return S;
}//maybe not working :/
\end{lstlisting}
Složitost $O(n^2)$
\begin{lstlisting}[language=C++]
#define MX (1003)
int lsi(int *r,int N,int *s,int M){
    static int U[MX],S,t;
    CL(U,S=0);
    F(N){
        t=0;
        FF(M)
            if(r[i]==s[j]&&U[j]<t+1)S=max(S,U[j]=t+1);
            else if(r[i]>s[j]&&t<U[j])t=U[j];
    }
    return S;
}
\end{lstlisting}
\subsection{Nejkratší podposloupnost obsahující všechny prvky od 1 do K}
Velikost bude v proměnné \textsf{x}.
\\Složitost $O(nlog(n))$
\begin{lstlisting}[language=C++]
int N,K,a[1<<20],k[128],x;
set<int> t;
void inc(int &b){
    while((int)t.size()!=K&&++b<=N)
        if(a[b]<=K)
            k[a[b]]=b,t.insert(a[b]);
}
void dec(int &b){
    while((int)t.size()==K)
        if(a[b]<=K&&k[a[b]]==b)
            t.erase(a[b]);
        else ++b;
}
void it(void){
    int b(1),e(0);
    while(e<=N)
        inc(e),dec(b),x=min(x,e-b+1);
}
\end{lstlisting}
\subsection{Nejvyšší absolutní hodnota sumy libovolného segmentu na sekvenci}
Sekvence je uložena v poli \textsf{a}
\\Algoritmus funguje i pro sekvenci posunutou o konstantu (pokud se zavolá $mab$ s parametrem).
\\Složitost $O(n)$
\begin{lstlisting}[language=C++]
double cmx(double d){
    double r(0),b(0);
    F(N)r=max(r,b),b+=a[i]-d,b=max(b,0.0);
    return max(r,b);
}
double cmn(double d){
    double r(0),b(0);
    F(N)r=min(r,b),b+=a[i]-d,b=min(b,0.0);
    return min(r,b);
}
#define mab(D) max(cmx(D),-cmn(D))
#define mab max(cmx(0),-cmn(0))
\end{lstlisting}
\subsection{Next}
Předpočtení dalšího výskytu znaku v řetězci. (zde děláno pro \textit{lowerbound})
\\Vstupem je řetězec \textsf{s}, tabulka \textsf{xx} a délka řetězce \textsf{L}
\\Složitost $O(LU)$, kde $U$ je velikost univerza (počet znaků - zde 26)
\begin{lstlisting}[language=C++]
void pc(char*s,int xx[MX][26],int L){
    F(26)xx[L][i]=-1;
    for(int i(L-1);~i;--i){
        FF(26)xx[i][j]=xx[i+1][j];
        xx[i][s[i]-97]=i;
    }
}
\end{lstlisting}
Pokud by nás zajímal jen $next$ vždy toho stejného písmene, které je na aktuálním indexu.
\begin{lstlisting}[language=C++]
int  X[MX],H[26];
void pre(int L,char*s){CL(H,-1);for(int i=L-1;~i;--i)X[i]=H[s[i]-97],H[s[i]-97]=i;}
\end{lstlisting}
\subsection{Obracení podposloupností [query]}
Nechť v \textsf{I} a \textsf{J} jsou jednotilivé obracení posloupnosti (od $I_i$ do $J_i$), kterých je \textsf{R}. Dotas $gps$ řekne, v kolikátý prvek z původního pole je nyní na pozici \textsf{q}.
\\Složitost $O(R)$ (za každý dotaz).
\begin{lstlisting}[language=C++]
int gps(int q){
    FF(R)if(I[j]<=q&&J[j]>=q)q=I[j]+J[j]-q;
    return q;
}
\end{lstlisting}
\subsection{Odstranění patternu z textu}
Složitost $O(m+n|U|)$, kde $m$ je velikost textu, ve kterém se vyhledává, $n$ velikost patternu a |U| velikost abecedy patternu.
\begin{center}
Vybudování automatu (pro pattern velkých písmen).
\end{center}
\begin{lstlisting}[language=C++]
void am(void){
    memset(a,0,sizeof(a));
    f=strlen(r);
    for(int i(a[0][r[0]-'A']=1),b(0);(ac=r[i]);++i){
        a[i][ac-'A']=i+1;
        for(char c('A');c<='Z';++c)
            if(c!=ac)
                a[i][c-'A']=a[b][c-'A'];
        b=a[b][ac-'A'];
    }
}
\end{lstlisting}
\begin{center}
Postupné přelití textu, ve kterém se vyhledává z pole \textit{q}, do pole \textit{o};
\end{center}
\begin{lstlisting}[language=C++]
void add(char c,int&e){
    if(c<'A'||c>'Z')
        o[e]=c,s[++e]=0;
    else if((tp=a[s[e]][c-'A'])==f)
        e-=(f-1);
    else
        o[e]=c,s[++e]=tp;
}
for(int i(0);q[i];++i)
	add(q[i],k);
\end{lstlisting}
\subsection{Palindromic tree}
Strom, uchovávající počet podpalindromů.
\\Funkce $ct$ spočítá počet podpalindromů nějakého řetězce.
\\Složitost $O(nlog(n))$
\\Je dělán pro $lower\_case$
\begin{lstlisting}[language=C++]
#define MX 1024
struct nd {
    int g[26],l,s,n;
}T[MX];
char s[MX];
int n,f;
bool ad(int p,char *s){
    int c(f),cl(0),e(s[p]-'a'),x(1);
    while(1){
        cl=T[c].l;
        if(p-1-cl>=0&&s[p-1-cl]==s[p])break;
        c=T[c].s;
    }
    if(T[c].g[e])return f=T[c].g[e],0;
    f=++n;
    T[n].l=T[c].l+2;
    T[c].g[e]=n;
    if(T[n].l==1)return T[n].s=2,T[n].n=1;
    while(x){
        c=T[c].s,cl=T[c].l;
        if(p-1-cl>=0&&s[p-1-cl]==s[p])T[n].s = T[c].g[e],x=0;
    }       
    return T[n].n=1+T[T[n].s].n,1;
}
void ini(){
    n=2,f=2;
    T[1].l=-1,T[1].s=1;
    T[2].l=0,T[2].s=1;
}
ll ct(char *s){
    int l(strlen(s));
    ll A(0);
    ini();
    F(l)ad(i,s),A+=T[f].n;
    return A;
}
\end{lstlisting}
\subsection{Počet palindromů na intervalu}
Nechť v \textsf{s} je uložen řetězec. Funkcí $ini$ se předvypočítá tabulka. Funkcí $dyn$ se pak dotazuje, kolik palindromů leží na intervalu \textsf{b} až \textsf{e}.
\\Složitost $O(N^2)$ (obecně - dotazy amortizovaně konstantní).
\begin{lstlisting}[language=C++]
#define MX (5050)
char s[MX];
int P[MX][MX],dp[MX][MX],N;
bool pm(int b,int e){
    int &v(P[b][e]);
    if(~v)return v;
    if(b==e||b+1==e)return (v=s[b]==s[e]);
    return (v=pm(b+1,e-1)&&s[b]==s[e]);
}
int dyn(int b,int e){
    int &v(dp[b][e]);
    if(~v)return v;
    v=P[b][e];
    if(b==e)return v;
    return v+=dyn(b+1,e);
}
void ini(void){
	N=strlen(s);
    CL(P,-1);CL(dp,-1);
    F(N)FT(i,N)pm(i,k);
    F(N)FF(N)P[i][j]=max(0,P[i][j]);
    F(N)FT(i,N)P[i][k]+=P[i][k-1];
}
\end{lstlisting}
\subsection{Počet podřetězců dané délky}
Počet unikátních podřetězců délky mezi \textsf{b} a \textsf{e} (včetně).
\\Řešení probíhá pomocí $suffix array$ a $lcp array$. Složitost závisí na $suffix array$, tedy $O(Nlog(N)^2)$. Případně $O(N)$ pokud je nutno.
\begin{lstlisting}[language=C++]
ll fss(int b,int e,char*s){
    static int SA[MX],L[MX],N,h;
    CL(L,0);
    ll S(0);
    sa(s,SA,N=strlen(s));
    lcp(SA,L,N,s);
    F(N)h=min(N-SA[i],e)-max(L[i],b-1),S+=h>0?h:0;
    return S;
}
\end{lstlisting}
\subsection{Počet rostoucích podsequencí o délce k}
Do \textsf{A} se uloží počet podsequencí o délce \textsf{i}, pro všechna $i\leq k$ (max \textsf{SZ}).
\\Délka sequence je v \textsf{n} ($n\leq\ MX$)
\\Vstupní sequence je uložena v \textsf{a} a její nejvyšší hodnota může nabývat \textsf{mc}
\\Složitost $O(N*K*log(mc))$
\begin{lstlisting}[language=C++]
#define MX 2012
#define SZ 2012
#define UV 2012
#define MOD 1000000007
ll d[MX][SZ],e[UV];
ll S(int i){
    ll S(0);
    while(i>0)S+=e[i],S%=MOD,i-=i&-i;
    return S;
}
void add(int i,int k) {
    while(i<n+1)e[i]+=k,e[i]%=MOD,i+=i&-i;
}
ll A[SZ];
void iseq(int n,int *a,int k,int mc){
    F(n)d[i][1]=1;
    FOR(p,2,k+1){
        F(mc+1)e[i]=0;
        FOR(i,1,n)add(a[i-1],d[i-1][p-1]),d[i][p]+=S(a[i]),d[i][p]%=MOD;
    }
    FOR(i,1,k+1)FF(n)A[i]+=d[j][i],A[i]%=MOD;
}

\end{lstlisting}
\subsection{Rolling Hash}
\textbf{Nutno otestovat}!!
\\Na vstupu bude string, délka podřetězce, délka řetězce a výsledné pole.
\\Ve výsledném poly bude prvních \textsf{N-L+1} pozic zaplněných hashemi podřetězců o dané délce.
\begin{lstlisting}[language=C++]
#define MOD (2147483647)
#define BS (257)
ll P[MX]={1};
void pw(void){FT(1,MX)P[k]=(P[k-1]*BS)%MOD;}
void rh(char*s,int L,int N,ll*T){
    ll H(0);
    F(L)H=(H*BS+s[i])%MOD;
    *T=H;
    FT(L,N)H=(H*BS+s[k])%MOD,H=(H-(P[L]*s[k-L])%MOD+MOD)%MOD,T[k-L+1]=H;//TODO
}
\end{lstlisting}
Obdobně pro dvojitý rolling hash:(místo \textsf{ll} přijímá \textsf{pll}) [o poznání jistější]
\begin{lstlisting}[language=C++]
#define MX (100001)
#define MOD (2147483647)
#define MOX (1000000009)
#define BS (257)
#define BR (263)
ll P[MX]={1},p[MX]={1},x;
void pw(void){FT(1,MX)P[k]=(P[k-1]*BS)%MOD,p[k]=(p[k-1]*BR)%MOX;}
void rh(char*s,int L,int N,pll*T){
    if(!x++)pw();
    ll H=0,h=0;
    F(L)H=(H*BS+s[i])%MOD,h=(h*BR+s[i])%MOX;
    *T={H,h};
    FT(L,N)H=(H*BS+s[k])%MOD,H=(H-(P[L]*s[k-L])%MOD+MOD)%MOD,
           h=(h*BR+s[k])%MOX,h=(h-(p[L]*s[k-L])%MOX+MOX)%MOX,T[k-L+1]={H,h};
}
\end{lstlisting}
\subsection{Řazení}
\begin{center}
Counting sort (nestabilní)
\end{center}
\begin{lstlisting}[language=C++]
void cs(int *v,int e){
    static int a[10001]={};
    F(e)++a[v[i]];
    for(int i(0),j(0);i<e;++i){
        while(!a[j])++j;
        --a[v[i]=j];
    }
}
\end{lstlisting}
Řazení pole od prvku \textsl{b} do prvku \textsl{e} (včetně).
\begin{center}
Quick Sort
\end{center}
\begin{lstlisting}[language=C++]
void qs(int *v,int b,int e){
    int B=b,E=e,D=v[(b+e)>>1],t;
    do{
        while(v[B]<D)++B;
        while(v[E]>D)--E;
        if(B<=E)
            t=v[B],v[B++]=v[E],v[E--]=t;
    }while(B<E);
    if(E>b)qs(v,b,E);
    if(B<e)return qs(v,B,e);
}
\end{lstlisting}
\begin{center}
Insertion sort
\end{center}
\begin{lstlisting}[language=C++]
void is(int *a,int b,int e){
    for(int i(b+1);i<=e;++i)
        for(int j(i);j>b&&a[j]<a[j-1];--j)
            a[j]^=a[j-1],a[j-1]^=a[j],a[j]^=a[j-1];
}
\end{lstlisting}
\begin{center}
Řazení pole páru, od největšího po nejmenší (priorita na first)
\end{center}
\begin{lstlisting}[language=C++]
sort(g,g+N,greater<pair<int,int> >());
\end{lstlisting}
\subsection{Suffix Array}
Funkce sa vybuduje Suffix Array (tedy pole se seřazenými indexy podle abecedy).
\\Parametry jsou vstupní string, výstupní pole indexů - oboje délky \textsf{n} (třetí parametr)
\\Složitost $O(nlog^2(n))$
\begin{lstlisting}[language=C++]
struct sx{
    int i,a,b;
    bool operator<(const sx&r)const{return a==r.a?b<r.b:a<r.a;}
}s[MX];
void sa(char *c,int *a, int n){
    static int I[MX]; 
    F(n)s[i]={i,c[i],c[i+1]};
    sort(s,s+n);
    for(int l(4),r,x,p;l<2*n;l<<=1){
        p=(*s).a,(*s).a=I[(*s).i]=r=0;
        FT(1,n)x=s[k].a,s[k].a=r+=!(s[k].a==p&&s[k].b==s[k-1].b),p=x,I[s[k].i]=k;
        F(n)x=s[i].i+l/2,s[i].b=x<n?s[I[x]].a:-1;
        sort(s,s+n);
    }
    F(n)a[i]=s[i].i;
}
\end{lstlisting}
Kratší, ale o konstantu pomalejší
\begin{lstlisting}[language=C++]
#define MX (1<<18)
void sa(char*s,int*a,int N) {
    static pll Z[MX];
    static ll U[2][MX],p;
    F(N)U[0][i]=s[i]+1;
    FF(2*N+j-(1<<j)){
        F(N)Z[i]={U[j&1][i]<<30,i};
        FT(1<<j,N)Z[k-(1<<j)].aa+=U[j&1][k];
        sort(Z,Z+N),p=1;
        F(N)U[(j^1)&1][Z[i].bb]=p+=i&&Z[i-1].aa< Z[i].aa;
    }
    F(N)a[i]=Z[i].bb;
}
\end{lstlisting}
Obdobně zde. S rozdílem, že zde je řetězec jako $unsiigned char$.
\\Volání funkce $sa(STRING,SA,STRLEN(STRING)+1)$ - tedy se 3 parametry. Zbytek je pro rekurzi.
\\Složitost $O(N)$
\begin{lstlisting}[language=C++]
#define MX (1<<19)
typedef unsigned char uc;	
uc M[]={128,64,32,16,8,4,2,1};
#define SI (sizeof(int))
#define tg(i) ((t[(i)>>3]&M[(i)&7])?1:0)
#define ts(i, b) t[(i)>>3]=(b) ? (M[(i)&7]|t[(i)>>3]):((~M[(i)&7])&t[(i)>>3])
#define chr(i) (cs==SI?((int*)s)[i]:((uc*)s)[i])
#define lms(i) (i>0&&tg(i)&&!tg(i-1))
void buc(uc *s,int *b,int n,int K,int cs,bool e){
    int S(0);
    F(K+1)b[i]=0;
    F(n)++b[chr(i)];
    F(K+1)S+=b[i],b[i]=e?S:S-b[i];
}
void isa(uc*t,int*SA,uc*s,int*b,int n,int K,int cs,bool e){
    int j;
    buc(s,b,n,K,cs,e);
    F(n)if((j=SA[i]-1)>=0&&!tg(j))
        SA[b[chr(j)]++]=j;
}
void sas(uc*t,int*SA,uc*s,int*b,int n,int K,int cs,bool e){
    int j;
    buc(s,b,n,K,cs,e);
    for(int i(n-1);~i;--i)
        if((j=SA[i]-1)>=0&&tg(j))
            SA[--b[chr(j)]]=j;
}
void sa(uc*s,int*SA,int n,int K=256,int cs=1){
    static int b[MX];
    int j,n1(0),h(0),w(-1),p,f;
    uc *t=(uc*)malloc(n>>3|1);
    ts(n-2,0),ts(n-1,1);
    for(int i(n-3);~i;--i)
        ts(i,(chr(i)<chr(i+1)||(chr(i)==chr(i+1)&&tg(i+1)==1))?1:0);
    buc(s,b,n,K,cs,1);
    F(n)SA[i]=-1;
    FT(1,n)if(lms(k))SA[--b[chr(k)]]=k;
    isa(t,SA,s,b,n,K,cs,0);
    sas(t,SA,s,b,n,K,cs,1);
    F(n)if(lms(SA[i]))SA[n1++]=SA[i];
    FT(n1,n)SA[k]=-1;
    F(n1){
        p=SA[i],f=0;
        F(n)if(!~w||chr(p+i)!=chr(w+i)||tg(p+i)!=tg(w+i))f=1,i=n;
            else if(i>0&&(lms(p+i)||lms(w+i)))break;
        if(f)++h,w=p;
        p>>=1,SA[n1+p]=h-1;
    }
    for(int i(n-1),j(n-1);i>=n1;--i)
        if(SA[i]>=0)SA[j--]=SA[i];
    int *SA1=SA,*s1=SA+n-n1;
    if(h<n1)sa((uc*)s1,SA1,n1,h-1,SI);
    else F(n1)SA1[s1[i]]=i;
    buc(s,b,n,K,cs,1);
    j=0;FT(1,n)if(lms(k))s1[j++]=k;
    F(n1)SA1[i]=s1[SA1[i]];
    FT(n1,n)SA[k]=-1;
    for(int i(n1-1);~i;--i)
        j=SA[i],SA[i]=-1,SA[--b[chr(j)]]=j;
    isa(t,SA,s,b,n,K,cs,0),sas(t,SA,s,b,n,K,cs,1);
    free(t);
}
\end{lstlisting}
Zde neni nic - slouží jen pro koírování (vše najednou)
\\Funkce call inicializuje Suffix Array, LCP array a RMQ. Vrátí délku + 1 (nula na začátku)
\begin{lstlisting}[language=C++]
#define LG (18)
#define MX (1<<LG)
typedef unsigned char uc;	
uc M[]={128,64,32,16,8,4,2,1};
#define SI (sizeof(int))
#define tg(i) ((t[(i)>>3]&M[(i)&7])?1:0)
#define ts(i, b) t[(i)>>3]=(b) ? (M[(i)&7]|t[(i)>>3]):((~M[(i)&7])&t[(i)>>3])
#define chr(i) (cs==SI?((int*)s)[i]:((uc*)s)[i])
#define lms(i) (i>0&&tg(i)&&!tg(i-1))
void buc(uc *s,int *b,int n,int K,int cs,bool e){
    int S(0);
    F(K+1)b[i]=0;
    F(n)++b[chr(i)];
    F(K+1)S+=b[i],b[i]=e?S:S-b[i];
}
void isa(uc*t,int*SA,uc*s,int*b,int n,int K,int cs,bool e){
    int j;
    buc(s,b,n,K,cs,e);
    F(n)if((j=SA[i]-1)>=0&&!tg(j))
        SA[b[chr(j)]++]=j;
}
void sas(uc*t,int*SA,uc*s,int*b,int n,int K,int cs,bool e){
    int j;
    buc(s,b,n,K,cs,e);
    for(int i(n-1);~i;--i)
        if((j=SA[i]-1)>=0&&tg(j))
            SA[--b[chr(j)]]=j;
}
void sa(uc*s,int*SA,int n,int K=256,int cs=1){
    static int b[MX];
    int j,n1(0),h(0),w(-1),p,f;
    uc *t=(uc*)malloc(n>>3|1);
    ts(n-2,0),ts(n-1,1);
    for(int i(n-3);~i;--i)
        ts(i,(chr(i)<chr(i+1)||(chr(i)==chr(i+1)&&tg(i+1)==1))?1:0);
    buc(s,b,n,K,cs,1);
    F(n)SA[i]=-1;
    FT(1,n)if(lms(k))SA[--b[chr(k)]]=k;
    isa(t,SA,s,b,n,K,cs,0);
    sas(t,SA,s,b,n,K,cs,1);
    F(n)if(lms(SA[i]))SA[n1++]=SA[i];
    FT(n1,n)SA[k]=-1;
    F(n1){
        p=SA[i],f=0;
        F(n)if(!~w||chr(p+i)!=chr(w+i)||tg(p+i)!=tg(w+i))f=1,i=n;
        else if(i>0&&(lms(p+i)||lms(w+i)))break;
        if(f)++h,w=p;
        p>>=1,SA[n1+p]=h-1;
    }
    for(int i(n-1),j(n-1);i>=n1;--i)
        if(SA[i]>=0)SA[j--]=SA[i];
    int *SA1=SA,*s1=SA+n-n1;
    if(h<n1)sa((uc*)s1,SA1,n1,h-1,SI);
    else F(n1)SA1[s1[i]]=i;
    buc(s,b,n,K,cs,1);
    j=0;FT(1,n)if(lms(k))s1[j++]=k;
    F(n1)SA1[i]=s1[SA1[i]];
    FT(n1,n)SA[k]=-1;
    for(int i(n1-1);~i;--i)
        j=SA[i],SA[i]=-1,SA[--b[chr(j)]]=j;
    isa(t,SA,s,b,n,K,cs,0),sas(t,SA,s,b,n,K,cs,1);
    free(t);
}
void lcp(int *sa,int *lcp,int n,uc *s){
    static int r[MX];
    F(n)r[sa[i]]=i,lcp[i]=0;;
    int h(0);F(n)if(r[i]<n-1){
        for(int j(sa[r[i]+1]);s[i+h]==s[j+h];++h);
        lcp[r[i]]=h;
        if(h)--h;
    }
}
#define P2(v) (!(v&(v-1)))
int dp[MX][LG+2],G[MX],XX,O=-1,SA[MX],C[MX];
void ini(int *A,int n){
    if(!XX++)FT(1,MX)G[k]=O+=P2(k);
    F(n)dp[i][0]=i;
    FT(1,k-(1<<k)+n+1)F(n+1-(1<<k))
        if(A[dp[i][k-1]]<A[dp[i+(1<<(k-1))][k-1]])
            dp[i][k]=dp[i][k-1];
        else dp[i][k]=dp[i+(1<<(k-1))][k-1];
}
int qy(int *A,int L,int R){
    int j(G[R-L+1]);
    if(A[dp[L][j]]<=A[dp[R-(1<<j)+1][j]])
        return A[dp[L][j]];
    return A[dp[R-(1<<j)+1][j]];
}
int CAL(uc*s){
    int L=strlen((char*)s);
    sa(s,SA,L+1),lcp(SA,C,L+1,s),ini(C,L+1);
    return L+1;
}
\end{lstlisting}
\subsection{Suffix Automat}
Vytvoří suffixový automat, s přechodama v \textsf{g}.
\\Složitost vybudování ~ $O(N)$
\begin{lstlisting}[language=C++]
struct SA{
    typedef map<char,int> mp;
    vector<mp> g;
    vi x,l;
    int T;
    SA(char*s){
        g.PB(mp()),x.PB(-1),l.PB(T=0);
        int L(strlen(s));
        F(L){
            g.PB(mp()),l.PB(i+1),x.PB(0);
            int r(g.size()-1),p(T),q,qq;
            while(~p&&!g[p].count(s[i]))g[p][s[i]]=r,p=x[p];
            if(~p){
                if(l[p]+1==l[q=g[p][s[i]]])x[r]=q;
                else{
                    g.PB(g[q]),l.PB(l[p]+1),x.PB(x[q]);
                    x[q]=x[r]=qq=g.size()-1;
                    while(~p&&g[p][s[i]]==q)g[p][s[i]]=qq,p=x[p];
                }
            }
            T=r;
        }
    }
};
\end{lstlisting}
Zjistí, zda-li je \textsf{w} podřetězcem \textsf{a}.
\begin{lstlisting}[language=C++]
bool ssr(SA&a,char*w){
    int n(0),L(strlen(w));
    F(L)if(!a.g[n].count(w[i]))return 0;
    else n=a.g[n][w[i]];
    return 1;
}
\end{lstlisting}
\subsection{Unikátnost všech podposloupností}
Vráti true, pokud pro posloupnost $a$ ($v==a$) platí, že všechny její (spojité) podposloupnosti obsahují alespoň 1 unikátní prvek.
\\Složitost $O(nlog(n))$
\begin{lstlisting}[language=C++]
#include <stdio.h>
#include <algorithm>
#include <string.h>
using namespace std;
int n,m,v[1<<18],a[1<<18],x[1<<18],p[1<<18],l[1<<18];
bool rec(int b,int e){
    for(int i(0),d;i<e-b;++i){
        d=i&1?b+(i>>1):e-1-(i>>1);
        if(p[d]<b&&x[d]>=e)
            return rec(b,d)||rec(d+1,e);
    }
    return b!=e;
}
bool isUq(void){
    sort(v,v+n);
    m=unique(v,v+n)-v;
    memset(l,-1,m<<2);
    for(int i(0);i<n;++i)
        p[i]=l[a[i]=lower_bound(v,v+m,a[i])-v],l[a[i]]=i;
    fill(l,l+m,n);
    for(int i(n-1);~i;--i)
        x[i]=l[a[i]],l[a[i]]=i;
    return rec(0,n);
}
\end{lstlisting}
Struktura, která umízjišťovat počet unikátních prvků na intervalu $qr(L,R)$ a umí modifikovat prvek na pozici \textsf{p} (na \textsf{x}) ($add$). Inicializace probíhá pomocí pole a jeho délky.
\\Složitost $O(sqrt(N)log(N))$ za query.
\begin{lstlisting}[language=C++]
#define MX (50001)
#define BS 240
#define LN (MX/BS+1)
struct VW{
	int A[LN][BS+1],B[LN][BS+1],T[LN],L[MX*2],w[MX*2],N;
	unordered_map<int,set<int>>M;
	void Badd(int p,int v){
		int r=p/BS,c=p%BS,l=A[r][c],I;
		if(l==v)return;
		A[r][c]=v,I=lower_bound(B[r],B[r]+T[r],l)-B[r];
		B[r][I]=v;
		if(v>l)while(I<T[r]-1&&B[r][I+1]<B[r][I])
            swap(B[r][I],B[r][I+1]),++I;
		else while(I>0&&B[r][I-1]>B[r][I])
            swap(B[r][I],B[r][I-1]),--I;
	}
	int qr(int l,int r){
		if(r<l)return 0;
		int x=l,R=l/BS,U=r/BS,C=l%BS,V=r%BS,S=0;
		if(R==U)while(C<=V)S+=A[R][C]<x,C++;
		else{
			while(C<T[R])S+=A[R][C]<x,C++;
			++R;
			while(~V)S+=A[U][V]<x,--V;
			while(R<U)S+=lower_bound(B[R],B[R]+T[R],x)-B[R],++R;
		}
		return S;
	}
	void ini(int n,int*W){
        int r=0,c=0;
        N=n,M.clear(),M.max_load_factor(.4),CL(T,0);
        F(n){
			w[i]=W[i];
            if(!M.count(w[i]))M[w[i]].insert(-1),M[w[i]].insert(n);		
			M[w[i]].insert(i),L[i]=*--M[w[i]].lower_bound(i);
			A[r][c]=L[i],B[r][c]=A[r][c],++T[r];
			if(++c==BS)c=0,++r;
		}
        F(r+1)sort(B[i],B[i]+T[i]);
	}
	void add(int p,int x){
		if(w[p]==x)return;
		int l=w[p],I;
		w[p]=x,M[l].erase(p),I=*M[l].upper_bound(p);
		if(I^N)L[I]=*--M[l].lower_bound(p),Badd(I,L[I]);
        if(!M.count(x))M[x].insert(-1),M[x].insert(N);
		M[x].insert(p),I=*M[x].upper_bound(p);
		if(I^N)L[I]=p,Badd(I,p);
		L[p]=*--M[x].lower_bound(p),Badd(p,L[p]);
	}
}T;

\end{lstlisting}
\subsection{Unique}
Všechny prvky pole v něm budou pouze jednou. Přizpůsobena je i velikost pole (druhý parametr).
\\Složitost $O(nlog(n))$
\begin{lstlisting}[language=C++]
void uq(ll*G,int&g){
    sort(G,G+g);
    int r(0),u(0);
    while(u<g){
        while(u<g&&u&&G[u]==G[u-1])++u;
        if(u<g)G[r++]=G[u++];
    }
    g=r;
}
\end{lstlisting}
\subsection{Z-Function}
Nalezne největší délku nejdelšího společného substringu s prefixem řetězce.
\\Složitost $O(N)$
\\Délky budou uloženy v \textsf{z}
\begin{lstlisting}[language=C++]
#define MX (1<<20)
int z[MX];
void ZF(char*s){
    int L(0),R(0),n(strlen(s)),l;
    FT(1,n)if(k>R){
            L=R=k;
            while(R<n&&s[R-L]==s[R])++R;
            z[k]=R-- -L;
        }else if(z[l=k-L]<R-k+1)z[k]=z[l];
        else{
            L=k;
            while(R<n&&s[R-L]==s[R])++R;
            z[k]=R-- -L;
        }
}
\end{lstlisting}
\newpage\section{Struktury a pole}
\subsection{Bitset}
$SQ$ je počet 64-ic bitů.
\begin{itemize}
\item $clr$ - Nastaví příznaky na 0. $O(SQ)$
\item $tr$ - Nastaví prvních \textsf{H} prvků na 1. $O(\dfrac{H}{64}+64)$
\item $is$ - Zjistí, zda-li mají bitsety nějaký společný prvek. $O(SQ)$
\item $|=$ - Dělá přesně to, co by se očekávalo. $O(SQ)$
\item $\&=$ - Dělá přesně to, co by se očekávalo. $O(SQ)$
\item $ad$ - Přidá číslo do bitsetu. $O(1)$
\item $cg$ - Zmení status čísla (vymaže pokud tam je, přidá, pokud tam neni)
\item $ct$ - Zeptá se, jestli je hodnota nastavena. $O(1)$
\item $bt$ - Vrátí počet bitů nastavených na 1. $O(max(SQ,Bits))$
\end{itemize}
\begin{lstlisting}[language=C++]
#define SQ (16)
struct bs{
    ll A[SQ];
    void clr(){CL(A,0);}
    void tr(int H){F(H>>6)A[i]=-1;FT(H-(H&63),H)ad(k);}
    bool is(bs&r){F(SQ)if(A[i]&r.A[i])return 1;return 0;}
    void operator|=(bs&r){F(SQ)A[i]|=r.A[i];}
    void operator&=(bs&r){F(SQ)A[i]&=r.A[i];}
    void operator^=(bs&r){F(SQ)A[i]^=r.A[i];}
    void ad(int u){A[u>>6]|=1ull<<(u&63);}
    void cg(int u){A[u>>6]^=1ull<<(u&63);} 
    bool ct(int v){return (A[v>>6]>>(v&63))&1;}
    int bt(){int l(0);F(SQ)l+=__builtin_popcountll(A[i]);return l;}
};
\end{lstlisting}
$xt$ - Vrátí nejmenší vyšší číslo (-1 pokud je nejvyšší).$O(SQ+64)$ 
\begin{lstlisting}[language=C++]
	int xt(int u){
        while(++u&63)if((A[u>>6]>>(u&63))&1)return u;
        while(u<SQ<<6&&!A[u>>6])++u;
        if(u==SQ<<6)return -1;
        while(!ct(u))++u;
        return u;
    }
\end{lstlisting}
$<<$ - Bitový posun o \textsf{s}.
\\Je nutný "unsigned"
\\Složitost $O(SQ)$
\\Nesmí se posouvat o víc než $SQ$ (jinak stačí udělat nějaký "if" s "$clr()$")
\begin{lstlisting}[language=C++]
	void operator<<=(int s){
        if(s>63){
            for(int i=SQ-(s>>6)-1;~i;--i)A[i+(s>>6)]=A[i];
            F(s>>6)A[i]=0;
        }
        A[SQ-1]<<=s;
        if(s&63)for(int i=SQ-2;~i;--i)A[i+1]|=A[i]>>(64-s),A[i]<<=s;
    }
\end{lstlisting}
\subsection{Fenwick Tree}
Funkce \textit{clr} vynuluje strom a nastaví velikost na parametr (pokud bude větší, nemělo by to vadit).
\\Funkce \textit{inc} zvýší hodnotu na pozici \textsf{i} o \textsf{d}.
\\Funkce \textit{gt} získá sumu prvků od pozice \textsf{l} do \textsf{r} (včetně)
\\Složitost $O(log(n))$ obou operací (\textit{clr} je samozřejmě lineární).
\begin{lstlisting}[language=C++]
int t[MX],S;
void clr(int s){CL(t,0);S=s;}
void inc(int i,int d){for(;i<S;i|=i+1)t[i]+=d;}
int sum(int i){int s(0);while(~i)s+=t[i],i&=i+1,--i;return s;}
int gt(int l,int r){return sum(r)-sum(l-1);}
\end{lstlisting}
Fenwickův Strom, který je v mapě.
\begin{lstlisting}[language=C++]
struct fw{
    unordered_map<int,int> t;
    int S;
    void clr(int s){S=s,t.clear();}
    void inc(int i,int d){for(;i<S;i|=i+1)t[i]+=d;}
    int sum(int i){int s(0);while(~i)s+=t[i],i&=i+1,--i;return s;}
    int gt(int l,int r){return sum(r)-sum(l-1);}
}T;
\end{lstlisting}
Maximovej FW. Pozor - hodnoty nelze snižovat!
\begin{lstlisting}[language=C++]
#define MX (1<<19)
int t[MX],L;
void ud(int x,int v) {while(x<=L)t[x]=max(t[x],v),x+=x&-x;}
int MAX(int x){int X=-INF;while(x)X=max(X,t[x]),x-=x&-x;return X;}
void ini(int N){L=N,fill(t,t+N,-INF);}
\end{lstlisting}
\subsection{Fenwick Tree [2D]}
Obdobná funkčnost jako jednodimenzionální.
\\První je nutno zavolat $ini$ s velikostí plochy (oboje dimenze budou stejné).
\\$st$ \texttt{nastaví} \textbf{[x,y]} na danou hodnotu (ještě není otestováno na long long)
\\$sum$ získá sumu na obdélníku.
\begin{lstlisting}[language=C++]
#define MX (1030)
ll T[MX][MX],D;
void ud(int n,int x,int y,ll v) {
    while(x<=n){
        int Y=y;
        while(Y<=n)T[x][Y]+=v,Y+=Y&-Y;
        x+=x&-x;
    }
}
ll SUM(int x, int y) {
    ll S=0;
    while(x>0){
        int Y=y;
        while(Y>0)S+=T[x][Y],Y-=Y&-Y;	
        x-=x&-x;
    }
    return S;
}
ll sum(int x,int y,int X,int Y){return SUM(X+1,Y+1)-SUM(X+1,y)-SUM(x,Y+1)+SUM(x,y);}
void st(int x,int y,ll v){ud(D,x+1,y+1,v-sum(x,y,x,y));}
void ini(int N){D=N,CL(T,0);}
\end{lstlisting}
\subsection{Fenwick Tree [3D]}
Obdobná funkčnost jako dvoudimenzionální.
\\První je nutno zavolat $ini$ s velikostí plochy (všechny dimenze budou stejné).
\\$st$ \texttt{nastaví} \textbf{[x,y,z]} na danou hodnotu (ještě není otestováno na long long)
\\$sum$ získá sumu na obdélníku.
\\Pozor, souřadnice jsou divně přeházeny, možná trochu upravit.
\begin{lstlisting}[language=C++]
#define MX (109)
ll T[MX][MX][MX],D,W;
void ud(int n,int x,int y,int z,ll v){
    while(x<=n){
        int Y=y;
        while(Y<=n){
            int Z=z;
            while(Z<=n)T[x][Y][Z]+=v,Z+=Z&-Z;;
            Y+=Y&-Y;
        }
        x+=x&-x;
    }
}
ll SUM(int x,int y,int z){
    ll S=0;
    while(x>0){
        int Y=y;
        while(Y>0){
            int Z=z;
            while(Z>0)S+=T[x][Y][Z],Z-=Z&-Z;
            Y-=Y&-Y;	
        }
        x-=x&-x;
    }
    return S;
}
ll sum(int x,int y,int X,int Y,int z,int Z){
    return SUM(X+1,Y+1,Z+1)-SUM(X+1,Y+1,z)-SUM(x,Y+1,Z+1)-SUM(X+1,y,Z+1)
    		-SUM(x,y,z)+SUM(X+1,y,z)+SUM(x,y,Z+1)+SUM(x,Y+1,z);
}
void st(int x,int y,int z,ll v){ud(D,x+1,y+1,z+1,v);}
void ini(int N){D=N,CL(T,0);}
\end{lstlisting}
\subsection{Halda (Binární)}
Binární halda a případná struktura - podporuje operator $<$.
\begin{lstlisting}[language=C++]
int L;
struct hp{
    int v,w;
    bool operator<(const hp&r)const{return v<r.v;}
}h[1<<18];
#define L(i) ((i)<<1)
#define R(i) (L(i)+1)
\end{lstlisting}
Funkce \textsl{xTop} [Extract Top] - odstraní vrchní (nejnižší) hodnotu haldy a vrátí ho (resp jeho signifikantní prvek).
\begin{lstlisting}[language=C++]
int xTop(void){
    int k(h[1].w);
    hp a;
    if(!--L)
        return k;
    h[1]=h[L+1];
    for(int i(1),u;i<=L&&2*i<=L;i=u){
        a=h[i];
        u=R(i)-(R(i)>L||h[L(i)]<h[R(i)]);
        if(h[u]<a)
            h[i]=h[u],h[u]=a;
        else break;
    }
    return k;
}
\end{lstlisting}
Funkce \textsl{add} na přidání prvku do haldy, na správnou pozici.
\begin{lstlisting}[language=C++]
void add(int v, int w){
    h[++L].v=v,h[L].w=w;
    for(int i(L);i>>1&&!(h[i>>1]<h[i]);i>>=1)
        swap(h[i],h[i>>1]);
}
\end{lstlisting}
\subsection{HLD}
Je nutné dodělat některé funkčnosti v reálném použití
\begin{itemize}
\item $D$ - Hloubka node
\item $R$ - Root (dáno při $ini$)
\item $P$ - Rodič node
\item $I$ - Kolikátý je node chainu
\item $C$ - V kolikátém chainu je
\item $G$ - Segment tree chainu
\item $O$ - Počet chainů
\item $F$ - Nejtlustší syn (-1 pokud se jedná o leaf)
\item $T$ - Rodič chainu
\end{itemize}
\begin{lstlisting}[language=C++]
#define MX 1024
ll H[1<<20],W;
struct sX{
    ll *p,*P;
    int N;
    void ini(int n){
        N=1<<(int(log2(n)-ZERO)+1),p=H+W,W+=N*2,P=H+W,W+=N*2;
        F(N<<1)p[i]=INF,P[i]=-1;//init val
    }
    ll gt(int u){return ~P[u]?P[u]:p[u];}
    void st(int b,int e,ll v){st(b,e,v,1,0,N-1);}
    void st(int b,int e,ll v,int u,int B,int E){
        if(B>e||E<b)return;
        if(b<=B&&e>=E){if(B^E)P[u]=v;else p[u]=v;return;}
        if(~P[u])p[u<<1]=p[u<<1|1]=p[u]=P[u],P[u]=-1;
        st(b,e,v,u<<1,B,(B+E)>>1),st(b,e,v,u<<1|1,(B+E)/2+1,E);
        p[u]=min(gt(u<<1),gt(u<<1|1));
    }
    ll gt(int b,int e){return gt(b,e,1,0,N-1);}
    ll gt(int b,int e,int u,int B,int E){
        if(B>e||E<b)return INF;//fail value
        if(b<=B&&e>=E)return gt(u);
        if(~P[u])p[u<<1]=p[u<<1|1]=p[u]=P[u],P[u]=-1;
        return min(gt(b,e,u<<1,B,(B+E)>>1),gt(b,e,u<<1|1,(B+E)/2+1,E));
    }
    
}G[MX];
#define CLR W=0
vi g[MX];
int D[MX],P[MX],R,I[MX],T[MX],C[MX],O,F[MX];
int dfs(int u,int d,int p){
    int w,S(1),b=-1;
    D[u]=d,P[u]=p,F[u]=-1;
    for(auto&h:g[u])if(h^p){
        S+=w=dfs(h,d+1,u);
        if(w>b)b=w,F[u]=h;
    }
    return S;
}
void hld(int u,int B,int c){
    for(auto&h:g[u])if(h^P[u]){
        if(h^F[u])hld(h,0,O++);
        else hld(h,B+1,c);
    }
    if(!~F[u])G[c].ini(B+1);
    if(!B)T[c]=u;
    I[u]=B,C[u]=c;
    //TODO seg-tree?!
}
void ini(int r=0){dfs(R=r,0,r),CLR,O=1,hld(R,0,0);}
void clr(){CLR;F(MX)g[i].clear();}
int lca(int a,int b){
    if(C[a]==C[b])return D[a]<D[b]?a:b;
    return D[T[C[a]]]<D[T[C[b]]]?lca(P[T[C[b]]],a):lca(P[T[C[a]]],b);
}
\end{lstlisting}
\subsection{Matice}
2D matice.
\begin{lstlisting}[language=C++]
struct m2{
    ll M[MM][MM];
    void mul(ll A[MM][MM],ll B[MM][MM],ll R[MM][MM],int W,ll M){
        R[0][0]=(A[0][0]*B[0][0]+A[0][1]*B[1][0])%M;
        R[0][1]=(A[0][0]*B[0][1]+A[0][1]*B[1][1])%M;
        R[1][0]=(A[1][0]*B[0][0]+A[1][1]*B[1][0])%M;
        R[1][1]=(A[1][0]*B[0][1]+A[1][1]*B[1][1])%M;
    }
    void pw(ll M[MM][MM],ll R[MM][MM],int W,ll k,ll MD){
        static ll E[MM][MM],H[MM][MM];
        F(W)FF(W)R[i][j]=E[i][j]=i==j;
        while(k){
            if(k&1)mul(E,M,R,W,MD),memcpy(E,R,sizeof(E));
            mul(M,M,H,W,MD);
            memcpy(M,H,sizeof(H));
            k>>=1;
        }
    }
    void operator*=(m2&a){
        static ll R[MM][MM];
        F(MM)FF(MM)R[i][j]=M[i][j];
        mul(R,a.M,M,2,MOD);
    }
    void operator+=(m2&a){F(MM)FF(MM)M[i][j]+=a.M[i][j],M[i][j]%=MOD;}
    m2 operator+(m2 a){
        m2 t=*this;
        t+=a;
        return t;
    }
    void operator*=(ll a){F(MM)FF(MM)M[i][j]*=a,M[i][j]%=MOD;}
    m2 operator*(m2&a){
        m2 t=*this;
        t*=a;
        return t;
    }
    void operator+=(ll a){F(MM)FF(MM)M[i][j]+=a,M[i][j]%=MOD;}
    void pw(ll a){
        static ll R[MM][MM];
        F(MM)FF(MM)R[i][j]=M[i][j];
        pw(R,M,2,a,MOD);
    }
    void ini(int a,int b,int c,int d){**M=a,M[0][1]=b,*M[1]=c,M[1][1]=d;}
}F;
\end{lstlisting}
\subsection{Matice (2D pole)}
Orotuje pole $N\times N$ o $90^{\circ}$
\begin{lstlisting}[language=C++]
void RL(int &a,int &b,int &c,int &d){int t(a);a=b,b=c,c=d,d=t;}
void rot(int r[][MX],int N){
    F(N>>1)FF((N+1)>>1)RL(r[i][j],r[N-1-j][i],r[N-1-i][N-1-j],r[j][N-1-i]);
}
\end{lstlisting}
Obecněji na změnu koordinát bodu při rotaci by mělo stačit toto
\begin{lstlisting}[language=C++]
void rt(int&a,int&b){swap(a,b),a=M-1-a;}
\end{lstlisting}
Největší spojitá plocha čtverce (matice obsahuje [0/1] - my hledáme jedničky).
\begin{lstlisting}[language=C++]
bool M[MX][MX];
int msm(int R,int C){
    static int S[MX][MX];
    int xs(0);
    F(R)S[i][0]=M[i][0];
    F(C)S[0][i]=M[0][i];
    for(int i(1);i<R;++i)
        for(int j(1);j<C;++j)
            if(M[i][j])
                S[i][j]=min(S[i][j-1],min(S[i-1][j],S[i-1][j-1]))+1;
            else S[i][j]=0;
    F(R)FF(C)xs=max(xs,S[i][j]);
    return xs*xs;
}
\end{lstlisting}
Největší spojitá plocha obdélníka (matice obsahuje [0/1] - my hledáme nuly).
\\Složitost $O(N^2M)$
\begin{lstlisting}[language=C++]
int P[MX][MX];
int lrc(int N,int M){
    static int S[101];
    int X(0),t,l,w;
    F(N){
        CL(S,0);
        FT(i,N)FF(M){
            S[j]+=!P[k][j];
            if(!j||t!=l*w)t=0,l=0;
            ++l,w=k-i+1,t+=S[j];
            if(t==l*w)X=X>t?X:t;
        }
    }
    return X;
}
\end{lstlisting}
Největší obvod spojitého obdélníka (matice [0/1] - my hledáme jedničky)
\\V poli \textsf{W} budou uloženy obvody levý dolní roh podmatic.
\\Složitost $O(n^2)$
\begin{lstlisting}[language=C++]
int lrc(int N,int M){
    static int U[MX][MX],t,b,qf[MX],qs[MX],W[MX][MX];
    int r(0);
    F(N)FF(M){
        t=j;b=j?b:0;
        U[i][j]=P[i][j]?i?U[i-1][j]+1:1:0;
        while(b&&qf[b-1]>=U[i][j])t=qs[--b];
        if(!U[i][j])continue;
        if(!b||U[i][j]-qf[b-1]>t-qs[b-1])
            r=max(r,W[i][j]=(U[i][j]+j-t+1)<<1),qf[b++]=U[i][j],qs[b-1]=t;
        else r=max(r,W[i][j]=(qf[b-1]+j-qs[b-1]+1)<<1);
    }
    return r;
}
\end{lstlisting}
Předpočet sumy obdélníka.
\begin{lstlisting}[language=C++]
ll M,N,G[MX][MX],S[MX][MX];
void sum(ll N,ll M){
    static ll H[MX][MX];
    F(N)FF(M)H[i][j]=(i?H[i-1][j]:0)+G[i][j];
    F(N)FF(M)S[i][j]=H[i][j]+(j?S[i][j-1]:0);
}
\end{lstlisting}
Získání sumy podobdélníka (pokud byl použit výše zmíněný předpočet).
\\Složitost $O(1)$
\begin{lstlisting}[language=C++]
ll sq(int ax,int ay,int bx,int by){
    ll W(S[bx][by]);
    if(ax)W-=S[ax-1][by];
    if(ay)W-=S[bx][ay-1];
    if(ax&&ay)W+=S[ax-1][ay-1];
    return W;
}
\end{lstlisting}
Nejmenší plocha podobdélníka,se součtem alespoň \textsf{K}
\\Složitost $O(NM(N+M))$
\\Matice je uložena v \textsf{G} - jsou vyžádovány hořejší dvě funkce.
\\If na řádku 4 je pouze optimalizace - nezlepšuje složitost.
\begin{lstlisting}[language=C++]
int rc(int N,int M,ll K){
	sum(N,M);
    int X(INF);
    F(N)FF(M)if(sq(0,0,i,j)>=K){
        int a(0),b(j);
        while(a<=i&&~b){
            while(~b&&sq(a,b,i,j)<K)--b;
            if(~b)X=min(X,(j-b+1)*(i-a+1));
            ++a;
        }
    }
    return X;
}
\end{lstlisting}
\subsection{MEX}
Struktura která podporuje rychlé vkládání a vyhledávání \textbf{mexu}.
\\$MM$ je nejvetší možný mex-1 (musí být mocnina dvojky)
\\Struktura podporuje
\begin{itemize}
\item \textbf{add} - Zvýší četnost čísla: $O(log(MEX))$
\item \textbf{del} - Sníží četnost čísla: $O(log(MEX))$
\item \textbf{CLR} - Inicializace: $O(MEX)$
\item \textbf{get} - Vrátí mex (tedy nejnižší prvek, který ve struktuře neni): $O(log(MEX))$
\end{itemize}
\begin{lstlisting}[language=C++]
#define MM (1024)
struct MEX{
    int p[MM<<1],C[MM];
    int st(int b,int v,int u,int B,int E){
        if(B>b||E<b)return p[u];
        if(B==E)return p[u]+=v;
        return p[u]=st(b,v,u<<1,B,(B+E)>>1)+st(b,v,u<<1|1,(B+E)/2+1,E);
    }
    int gt(int u,int B,int E){
        if(B==E)return B;
        if(p[u<<1]==(B+E)/2-B+1)return gt(u<<1|1,(B+E)/2+1,E);
        return gt(u<<1,B,(B+E)>>1);
    }
    int get(){return gt(1,0,MM-1);}
    void CLR(){CL(C,0),CL(p,0);}
    void add(int I){if(!C[I]++)st(I,1,1,0,MM-1);}
    void del(int I){if(!--C[I])st(I,-1,1,0,MM-1);}
}T;
\end{lstlisting}
\subsection{Monotóni fronta}
Fronta, která umí přidat/odebrat prvek. Dále umí říct maximum / minimum z prvků, které se v ní aktuálně nachazí.
\\Složitost každé z operací (kromě $clr$) je $O(1)$
\begin{lstlisting}[language=C++]
#define DL pop_back()
#define D2 pop_front()
template<class T> struct MQ{
    deque<T> D,E,Q;//E(min)|D(max)
    void push(T x){
        while(!D.empty()&&x>D.back())D.DL;
        while(!E.empty()&&x<E.back())E.DL;
        D.PB(x),E.PB(x),Q.PB(x);
    }
    void pop(){
        if(D.front()==Q.front())D.D2;
        if(E.front()==Q.front())E.D2;
        Q.D2;
    }
    T mx(){return D.front();}
    T mn(){return E.front();}
    T front(){return Q.front();}
    bool empty(){return Q.empty();}
    int size(){return Q.size();}
    void clr(){while(!Q.empty())Q.D2;while(!D.empty())D.D2;while(!E.empty())E.D2;}
};
\end{lstlisting}
\subsection{Mřížka hexagonu}
Index nula je vlevo od původního prvku. Další indexy jdou dokola, po směru hodinových ručiček.
\begin{lstlisting}[language=C++]
/*
      / \   / \   / \
     /   \ /   \ /   \
    | 10  |  3  |  4  |
    |-1,-3|-1,-1|-1,1 |
   / \   / \   / \   / \
  /   \ /   \ /   \ /   \
 |  9  |  2  |  1  |  5  |
 | 0,-4| 0,-2| 0,0 | 0,2 |
  \   / \   / \   / \   /
   \ /   \ /   \ /   \ /
    |  8  |  7  |  6  |
    | 1,-3| 1,-1| 1,1 |
     \   / \   / \   /
      \ /   \ /   \ /
*/
int dx[]={0,-1,-1, 0,+1,+1},dy[]={-2,-1,1,2,1,-1};
\end{lstlisting}
\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{pic/hexagon.png}
  \caption[Hexagon.]{Hexagon.}
\end{figure}
\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{pic/h2.png}
  \caption[Putování hexagonem.]{Putování hexagonem.}
\end{figure}
Putujeme li N kroků po hexagonové mříšce uvedeným způsobem, na jakých budeme koordinátech?
\begin{lstlisting}[language=C++]
pll hxp(ll N){
    static int sx[][2]={{2,0},{1,2},{-1,2},{-2,0},{-1,-2},{1,-2},{2,0}};
    ll B(0),E(INF),M,p,X,Y;
    while(B<E){
        M=(B+E)>>1;
        if(3*M*(M+1)+1<=N)B=M+1;
        else E=M;
    }
    p=N-3*B*(B-1)-1;
	if(!p)return {(B-1)<<1,0};
    X=p/B,Y=p%B;
	return{B*sx[X][0]+Y*(sx[X+1][0]-sx[X][0]),B*sx[X][1]+Y*(sx[X+1][1]-sx[X][1])};
}
\end{lstlisting}
Nechť putujeme výše uvedeným způsobem. Pokud začínáme v bodě jedna, tak se z body \textsc{N} do bodu \textsf{M} dostaneme během $qr$ kroků. Předem je však nutno předspracovat mřížku  v $O(MX)$.
\\Pokud se hýbe s $MX$ je také nutné upravit číslo ve $FT$ (a patřičně poštelovat!)
\begin{lstlisting}[language=C++]
#define MX (1<<14)
struct pt{int x,y;}p[MX]={{0,0},{0,0},{1,-1}};
int sx[]={-1,-1,0,1,1,0},sy[]={0,1,1,0,-1,-1},P(2);
void er(int s,int H){F(H)++P,p[P]={p[P-1].x+sx[s],p[P-1].y+sy[s]};}
void pre(){
    FT(1,60){
        F(4)er(i,k);
        er(4,k+1),er(5,k);
    }
}
int qr(int N,int M){
    int x=p[N].x-p[M].x,y=p[N].y-p[M].y;
    if((x<0&&y>0)||(x>0&&y<0))return max(abs(x),abs(y));
    return abs(x+y);
}
\end{lstlisting}
Iterace po hexagonu - \textbf{OTESTOVAT}
\begin{lstlisting}[language=C++]
bool g[MX][MX];
#define MX (1024)
#define AD (512)
void sim(){
    //omitting first two
    CL(g,0);
    int d=0,x=AD,y=AD+2,u;
    while(666){
        F(6)g[x+sx[i]][y+sy[i]];//visit neighbors
        //TODO
        u=(d+1)%6;
        if(!g[x+sx[u]][y+sy[u]])d=u;
        g[x+=sx[d]][y+=sy[d]]=1;
    }
}
\end{lstlisting}
\subsection{Mřížka trojúhelníku}
\begin{figure}[H]
  \centering
  \includegraphics[width=2in]{pic/triangle.png}
  \caption[Mřížka trojúhelníku.]{Mřížka trojúhelníku.}
\end{figure}
\begin{lstlisting}[language=C++]
int sy[]={-1,0,-1,1,0,1},sx[]={-1,-1,0,0,1,1};
\end{lstlisting}
\subsection{Multiset}
Pomocí mapy
\begin{lstlisting}[language=C++]
struct MTS{
    map<int,int> T;
    bool ep(){return T.empty();}
    int lst(){return (*--T.end()).aa;}
    int fst(){return (*T.begin()).aa;}
    void ad(int x){++T[x];}
    void del(int x){if(!--T[x])T.erase(x);}
    void clr(){T.clear();}
}S;
\end{lstlisting}
\subsection{Průnik množin [T/F]}
\begin{lstlisting}[language=C++]
bool doIn(int nd){
    auto i(A.begin()),j(B.begin());
    while(i!=A.end()&&j!=B.end())
        if(*i==*j)
            return 1;
        else if(*i<*j)
            ++i;
        else ++j;
    return 0;
}
\end{lstlisting}
\subsection{RMQ}
Algoritmus zjistí minimum na podposloupnosti nějaké posloupnosti. Posloupnost musí být statická (teda g- nesmí se měnit během query).
\\Složitost vybudování je $O(log(N))$
\\Složitost query je $O(1)$
\begin{lstlisting}[language=C++]
#define LG (17)
#define MX (1<<LG)
#define P2(v) (!(v&(v-1)))
int dp[MX][LG+2],G[MX],XX,O=-1;
void ini(int *A,int n){
    if(!XX++)FT(1,MX)G[k]=O+=P2(k);
    F(n)dp[i][0]=i;
    FT(1,k-(1<<k)+n+1)F(n+1-(1<<k))
        if(A[dp[i][k-1]]<A[dp[i+(1<<(k-1))][k-1]])
            dp[i][k]=dp[i][k-1];
        else dp[i][k]=dp[i+(1<<(k-1))][k-1];
}
int qy(int *A,int L,int R){
    int j(G[R-L+1]);
    if(A[dp[L][j]]<=A[dp[R-(1<<j)+1][j]])
        return A[dp[L][j]];
    return A[dp[R-(1<<j)+1][j]];
}
\end{lstlisting}
Obdobně maxium
\begin{lstlisting}[language=C++]
int dp[MX][LG+2],G[MX],XX,O=-1;
void ini(int *A,int n){
    if(!XX++)FT(1,MX)G[k]=O+=P2(k);
    F(n)dp[i][0]=i;
    FT(1,k-(1<<k)+n+1)F(n+1-(1<<k))
        if(A[dp[i][k-1]]>A[dp[i+(1<<(k-1))][k-1]])
            dp[i][k]=dp[i][k-1];
        else dp[i][k]=dp[i+(1<<(k-1))][k-1];      
}
int qy(int *A,int L,int R){
    int j(G[R-L+1]);
    if(A[dp[L][j]]>=A[dp[R-(1<<j)+1][j]])
        return A[dp[L][j]];
    return A[dp[R-(1<<j)+1][j]];
}
\end{lstlisting}
2D Maximum
\begin{lstlisting}[language=C++]
#define LG (10)
#define MX (1001)
struct R2Q{
    int M[LG][LG][MX][MX],lt[MX]={-1,0,1};
    void ini(int n,int m,int P[MX][MX]){
        int L=max(n,m);
        F(L)while(1<<(lt[i+1]+1)<i+2)++lt[i+1];
        F(INF&&1<<i<=n)FF(INF&&1<<j<=m)
            REP(x,n+1-(1<<i))REP(y,m+1-(1<<j)){
                int X=x+(1<<(i-1)),Y=y+(1<<(j-1));
                if(!i&&!j)M[i][j][x][y]=P[x][y];
                else if(!i)M[i][j][x][y]=max(M[i][j-1][x][y],M[i][j-1][x][Y]);
                else if(!j)M[i][j][x][y]=max(M[i-1][j][x][y],M[i-1][j][X][y]);
                else M[i][j][x][y]=max(M[i-1][j-1][x][y],max(M[i-1][j-1][X][y],
                            max(M[i-1][j-1][x][Y], M[i-1][j-1][X][Y])));
            }
    }
    int qy(int x, int y, int A, int B){
        int k=lt[A-x+1],l=lt[B-y+1],X=A-(1<<k)+1,Y=B-(1<<l)+1;
        return max(M[k][l][x][y],max(M[k][l][X][y],max(M[k][l][x][Y],M[k][l][X][Y])));
    }
}T;
\end{lstlisting}
\subsection{Rope}
Je zde normálně push\_back
\begin{lstlisting}[language=C++]
#include <ext/rope>
using namespace __gnu_cxx;
rope<int> S,h;
\end{lstlisting}
Přesunití intervalu na začátek
\begin{lstlisting}[language=C++]
h=S.substr(a,b-a+1),S.erase(a,b-a+1),S.insert(S.mutable_begin(),h);
\end{lstlisting}
iterace (bohužel nefunguje auto)
\begin{lstlisting}[language=C++]
for(rope <int>::iterator it=S.mutable_begin();it!=S.mutable_end();++it)
        printf("%d%c",(int)*it,++I^N?32:10);
\end{lstlisting}
\subsection{Rozdělení plochy}
Inicializace proběhne pomocí čtyř mezí, ohraničujících plochu (levá,pravá,dolní a horní). Dále je nutné mít DX/DY (počet, na který se má rozdělovat - obvykle něco jako $\sqrt{\sqrt{n}}$).
\\Struktura $it$ uchovává nějaké geometrické těleso, bod, přímku atp.... Metoda fit zjistí, zda-li těleso leží v dotazovaném čtverci.
\\Funkce $ftx$ a $fty$ lze využít pouze pokud lze každé těleso přiřadit pouze jednomu území (například v případě bodů) - pak to vrátí $X/Y$ - do kterého čtverce se má zařadit. Složitost $O(n)$, kde \textsf{n}$\times$\textsf{m} je počet území. Lze napsat i logaritmicky, ale to bývá zbytečné.
\\Pokud může těleso náležet vícero čtvercům, je pak nutné využít funkci $put$, která tělese zařadí do všech možných čtverců.
\begin{lstlisting}[language=C++]
int N,x[MX],y[MX];
int LR[DX+1],BT[DY+1];
struct it{
    it(int i):i(i){}
    int i;
    //bool operator<(const it&r)const{return x[i]+y[i]<x[r.i]+y[r.i];}
    bool fit(int l,int r,int b,int t)const{return !(x[i]<l||x[i]>r||y[i]<b||y[i]>t);}
};
vector<it> p[DX][DY];
int ftx(int x){
    F(DX)if(LR[i]>x)return i-1;
    return DX-1;
}
int fty(int y){
    F(DY)if(BT[i]>y)return i-1;
    return DY-1;
}
void init(int lx,int rx,int by,int ty){
    rx+=DX+1,ty+=DY+1;
    int sx((rx-lx)/DX),sy((ty-by)/DY);
    for(int i(L),j(0);j<DX;++j,i+=sx)LR[j]=i;
    for(int k(B),j(0);j<DY;++j,k+=sy)BT[j]=k;
    LR[DX]=rx,BT[DY]=ty;
}
void put(const it &a){
    F(DX)FF(DY)if(a.fit(LR[i],LR[i+1]-1,BT[j],BT[j+1]-1))p[i][j].push_back(a);
}
\end{lstlisting}
\begin{center}
Používání
\end{center}
\begin{lstlisting}[language=C++]
L=B=1<<30,R=T=-B;
L=min(L,x[i]),R=max(R,x[i]),T=max(T,y[i]),B=min(B,y[i]);
init(L,R,B,T);
\end{lstlisting}
\subsection{Segment Tree}
\begin{center}
Vybudování stromu
\end{center}
Je zavolána jedna z funkcí $stO$ či $stR$.
\\$stO$ nastaví velikosti segmentů na konstantu (defaultně velikost 1 \textsf{s}).
\\$stR$ nastaví velikosti segmentů podle hodnot v poli \textsf{a}.
\\Dalšími dvěmi argumenty jsou \textsf{za} a \textsf{zb} - to jsou hodnoty, které nijak neovlivňují výpočet prvku 1/2 (například poud v segmentovém stromu bude uchováváno sčítání, pak to bude 0 - či 1 pro násobení).
\\\textsf{MX} musí být alespoň nejméně dvojnásobek a nejvýše čtyřnásobek maximálního počtu segmentů.
\\$o1$ a $o2$ jsou operace, které se provádějí při sjednocování segmentů.
\begin{lstlisting}[language=C++]
#define MX (1<<19)
typedef int it;
it V[MX],W[MX],B[MX],E[MX],L[MX],R[MX],N,O,ZA,ZB;
void bt(int n,it za,it zb){
    ZA=za,ZB=zb;
    FT(n,N)V[k]=za,W[k]=zb;
    for(int K(N),l(N>>1),p(0);l;K+=l,l>>=1,O=K)
        FT(K,K+l)B[k]=B[p],E[k]=E[p+1],V[k]=o1(V[p],V[p+1])
                ,W[k]=zb,L[k]=p,R[k]=p+1,p+=2;
    if(!~--O)O=0;
}
void stO(int n,it za=0,it zb=0,int s=1){
    N=1<<(int)(ceil(log2(n))+0.1);
    F(N)E[i]=(B[i]=i*s)+s-1;
    bt(n,za,zb);
}
void stR(int n,int *a,it za=0,it zb=0){
    N=1<<(int)(ceil(log2(n))+0.1);
    F(n-1)B[i]=a[i],E[i]=a[i+1]-1;
    FT(n,N)B[k]=E[k]=a[n-1]+1;/*care if not too low*/
    bt(n-1,za,zb);
}
\end{lstlisting}
Funkce \textbf{g1} vyhledá hodnotu na intervalu \textsf{b}, \textsf{e}.
\\Funkce ud updatne hodnotu na intervalu (přičte jí k W[u]).
\\Funkce $o1$ je operace která se vykonává na obou potomcích. Funkce $vl$ je způsob počítní hodnoty v node.
\\Zde je strom podporující součet na intervalu.
\begin{lstlisting}[language=C++]
it o1(it a,it b){
    return a+b;
}
it vl(int u){
    return V[u]+W[u]*(E[u]-B[u]+1);
}
it ud(int b,int e,it v,int u=O){
    if(e<B[u]||b>E[u])return vl(u);
    if(u<N)return W[u]+=v,V[u]=vl(u),W[u]=0,V[u];
    if(b<=B[u]&&e>=E[u])return W[u]+=v,vl(u);//MD
    return V[u]=o1(ud(b,e,v,L[u]),ud(b,e,v,R[u])),vl(u);
}
it g1(int b,int e,int u=O){
    if(b<=B[u]&&e>=E[u])return vl(u);
    if(e<B[u]||b>E[u])return ZA;
    V[u]=o1(ud(B[u],E[u],W[u],L[u]),ud(B[u],E[u],W[u],R[u]));W[u]=0;
    return o1(g1(b,e,L[u]),g1(b,e,R[u]));
}
\end{lstlisting}
Zde je strom podporující min a max na intervalu.
\\Pozor, zde je nutné změnit nejen \textsf{it} ale i \textsf{ii}
\\Funkce \textit{g1} vrací pár $min/max$.
\begin{lstlisting}[language=C++]
#define PR(A,X) (X?A.second:A.first)
typedef int it;
it V[MX],X[MX],W[MX],B[MX],E[MX],L[MX],R[MX],N,O,ZA,ZB;
it o1(it a,it b){
    return min(a,b);
}
it o2(it a,it b){
    return max(a,b);
}
void bt(int n,it za,it zb){
    ZA=za,ZB=zb;CL(W,0);
    F(n)X[i]=V[i];
    FT(n,N)V[k]=za,X[k]=zb;
    for(int K(N),l(N>>1),p(0);l;K+=l,l>>=1,O=K)
        FT(K,K+l)B[k]=B[p],E[k]=E[p+1],V[k]=o1(V[p],V[p+1])
                ,X[k]=o2(X[p],X[p+1]),L[k]=p,R[k]=p+1,p+=2;
    if(!~--O)O=0;
}
void stO(int n,it za=INF,it zb=-INF,int s=1){
    N=1<<(int)(ceil(log2(n))+0.1);
    F(N)E[i]=(B[i]=i*s)+s-1;
    bt(n,za,zb);
}
it mn(int u){
    return V[u]+W[u];
}
it mx(int u){
    return X[u]+W[u];
}
void ud(int b,int e,it v,int u=O){
    if(e<B[u]||b>E[u])return;
    if(u<N){V[u]=X[u]+=v;return;}
    if(b<=B[u]&&e>=E[u]){W[u]+=v;return;};
    if(W[u])ud(B[u],E[u],W[u],L[u]),ud(B[u],E[u],W[u],R[u]),W[u]=0;
    ud(b,e,v,L[u]),ud(b,e,v,R[u]),W[u]=0;
    V[u]=o1(mn(R[u]),mn(L[u]));
    X[u]=o2(mx(R[u]),mx(L[u]));
}
ii g1(int b,int e,int u=O){
    if(b<=B[u]&&e>=E[u])return {mn(u),mx(u)};
    if(e<B[u]||b>E[u])return {ZA,ZB};
    if(W[u])ud(B[u],E[u],W[u],L[u]),ud(B[u],E[u],W[u],R[u]),W[u]=0,
        V[u]=o1(mn(R[u]),mn(L[u])),X[u]=o2(mx(R[u]),mx(L[u]));
    ii A(g1(b,e,L[u])),H(g1(b,e,R[u]));
    return {o1(PR(A,0),PR(H,0)),o2(PR(A,1),PR(H,1))};
}
\end{lstlisting}
Segment tree na vracení univerza na intervalu (v bitsetu - ten je nutno "naincludovat").
\\Inicializace probíhá pomocí pole \textsf{v}, ve kterém jsou hodnoty v poly (jako integery).
\\Pozor, neumí update.
\\Složitosti jsou násobeny velikostí univerza / 64 (tedy pro univerza $\geq 10^4$ už to není úplně optimální)
\\Funkce \textsf{g1} přijímá bitset \textsf{H}, ve kterém budou výsledky. Je ale nutné ho předem vynulovat.
\\Pole \textsf{V} je posunuto \textsf{N}, aby zabíralo méně místa (není nutno pro prvky, které jsou ve \textsc{v});
\begin{lstlisting}[language=C++]
#define MX (1<<18)
#define MB (MX>>1)
bs V[MB];
typedef int it;
bool W[MX];
int v[MX],B[MX],E[MX],L[MX],R[MX],N,O;
bool pt(bs&H,int u){
    int x(0);
    if(u<N)return !~v[u]?0:x=H.ct(v[u]),H.ad(v[u]),x;
    return x=H.is(V[u-N]),H|=V[u-N],x;
}
bool is(int a,int b){
    if(b<N)return ~v[b]?v[b]==v[a]:0;
    return W[a]||W[b]||V[a-N].is(V[b-N]);
}
void bt(int n){
    CL(W,0);
    FT(n,N)v[k]=-1;
    F(N)V[i].clr();
    for(int K(N),l(N>>1),p(0);l;K+=l,l>>=1,O=K)
        FT(K,K+l)B[k]=B[p],E[k]=E[p+1],pt(V[k-N],p),pt(V[k-N],p+1),
                 W[k]=is(p,p+1),L[k]=p,R[k]=p+1,p+=2;
    --O;
}
void stO(int n,int s=1){
    N=1<<(int)(ceil(log2(n))+0.1);
    F(N)E[i]=(B[i]=i*s)+s-1;
    bt(n);
}
bool g1(int b,int e,bs&H,int u=O){
    if(e<B[u]||b>E[u])return 0;
    if(b<=B[u]&&e>=E[u])return pt(H,u)||W[u];
    return g1(b,e,H,L[u])|g1(b,e,H,R[u]);
}
\end{lstlisting}
Segment tree, který vrací počet čísel nižších, než-li číslo zadané (bez update).
\\Funkce $bld$ vytvoří strom
\\Složitost vybudování $O(Nlog(N))$ / dotaz $O(log(N)^2)$
\begin{lstlisting}[language=C++]
vi V[MX*2];
int get(int l,int r,int x) {
    int s(0);
    l+=MX,r+=MX;
    while(l<r){
        if(l&1)s+=LB(l);
        if(!(r&1))s+=LB(r);
        l=(l+1)>>1,r=(r-1)>>1;
    }
    return s+(l==r?LB(r):0);
}
void bld(int n,int*a){
    //F(MX<<1)V[i].clear();
    F(n)V[i+MX]={a[i]};
    for(int i(MX-1);i;--i)
        V[i].resize(V[i*2].size() + V[i*2+1].size()),
        merge(all(V[i*2]), all(V[i*2+1]),V[i].BG);
}
\end{lstlisting}
Modifikace, pokud budeme chtít k-té nejmenčí číslo na intervalu (přidá $O(log(U))$ navíc).
\\Volání s levá/pravá hranice intervalu + k. 
\begin{lstlisting}[language=C++]
int kth(int a,int b,int c){
    int B(-1e9),E(1e9),M;
    while(B<E){
        M=(B+E+1)/2;
        if(get(a,b,M)>=c)E=M-1;
        else B=M;
    }
    return B;
}
\end{lstlisting}
2D strom podporující min/max.
\\Update probíhá pomocí mod (element $[x,y]$ s hodnotou \textsf{V})
\\Nastavení velikosti pomocí $ini$
\\Nalezení minima/maxima pomocí funkce qr (je zadán pravý horní a levý dolní roh). Výsledek je uložen v $mn$ a $mx$.
\begin{lstlisting}[language=C++]
#define MX (1024)
struct IT{
    int X[MX][MX],N[MX][MX],n,m;
    int xo,l,x1,y1,x2,y2,x,y,v,mx,mn;
    void q1(int o,int L,int R){
        if(y1<=L&&R<=y2)mx=max(mx,X[xo][o]),mn=min(mn,N[xo][o]);
        else{
            int M((L+R)>>1);
            if(y1<=M)q1(o<<1,L,M);
            if(M<y2)q1((o<<1)+1,M+1,R);
        }
    }
    void q2(int o,int L,int R){
        if(x1<=L&&R<=x2)return xo=o,q1(1,1,m);
        int M((L+R)>>1);
        if(x1<=M)q2(o<<1,L,M);
        if(M<x2)q2((o<<1)+1,M+1,R);
    }
    void m1(int o,int L,int R){
        if(L==R){
            if(l){X[xo][o]=N[xo][o]=v;return;}
            X[xo][o]=max(X[xo<<1][o],X[(xo<<1)+1][o]);
            N[xo][o]=min(N[xo<<1][o],N[(xo<<1)+1][o]);
        }else{
            int M((L+R)>>1);
            if(y<=M)m1(o<<1,L,M);
            else m1((o<<1)+1,M+1,R);
            X[xo][o]=max(X[xo][o<<1],X[xo][(o<<1)+1]);
            N[xo][o]=min(N[xo][o<<1],N[xo][(o<<1)+1]);
        }
    }
    void m2V(int o,int L,int R) {
        if(L==R)return xo=o,l=1,m1(1,1,m);
        int M((L+R)>>1);
        if(x<=M)m2V(o<<1,L,M);
        else m2V((o<<1)+1,M+1,R);
        xo=o,l=0,m1(1,1,m);
    }
    void qr(int x,int y,int X,int Y){x1=x,x2=X,y1=y,y2=Y,mx=-INF,mn=INF,q2(1,1,n);}
    void mod(int X,int Y,int V){x=X,y=Y,v=V,m2V(1, 1, n);}
    void ini(int N,int M){n=N,m=M;}
}T;
\end{lstlisting}
Počet prvků na intervalu, menších než-li $v$.
\\$MV$ je maximální velikost prvku
\\$MX$ je maximální velikost pole
\\$DS$ je nějaká konstanta, při jejíž velikosti se přestává Segmentový Strom půlit (a projde se to brute-force). Dobré vymyslet podle complexity. Může šetřit čas, ale zejména šetří memory. Pokud se nejedná o chtěnou vlastnost, stačí nastavit na $1$.
\\Update probíhá pomocí funkce $st$. Probíhá pouze na jednom $node$. Voolá se s indexem $node$ a hodnoutou $update$. Složitost $O(log(N)log(MV)H)$, kde $H$ je složitost hash-mapy.
\\Funkce gt $l,r,v$ nalezne počet prvků, menších než-li $v$ na intervalu od $l$ do $r$. Složitost $Nlog(N)log(MV)H+DS$
\\Inicializace pomocí $ini$ s argumentem velikosti segmentu
\begin{lstlisting}[language=C++]
#define MV (600000)
#define MX (1<<20)
#define DS (750)
struct fw{
    unordered_map<int,int> t;
    int S;
    void clr(int s){S=s,t.clear();}
    void inc(int i,int d){for(;i<S;i|=i+1)t[i]+=d;}
    int sum(int i){int s(0);while(~i)s+=t[i],i&=i+1,--i;return s;}
}T[MX*2];
int N,P[MX*2];
void iii(int u,int B,int E){
    if(E-B+1<=DS)return;
    T[u].clr(MV+2),T[u].inc(MV+1,E-B+1);
    iii(u<<1,B,(B+E)>>1),iii(u<<1|1,(B+E)/2+1,E);
}
void ini(int n){
    N=1<<(int(log2(n)-ZERO)+1);
    fill(P,P+N,MV+1),iii(1,0,N-1);
}
int st(int W,int v,int u,int B,int E){
    if(W>E||W<B)return -2e9;
    if(E-B+1<=DS){
        int t=P[W];
        return P[W]=v,t;
    }
    int t=max(st(W,v,u<<1,B,(B+E)>>1),st(W,v,u<<1|1,(B+E)/2+1,E));
    T[u].inc(t,-1),T[u].inc(v,1);
    return t;
}
int gt(int b,int e,int v,int u,int B,int E){
    if(B>e||E<b)return 0;
    if(E-B+1<=DS){
        int S=0;
        b=max(B,b),e=min(E,e);
        FT(b,e+1)S+=P[k]<=v;
        return S;
    }
    if(b<=B&&e>=E)return T[u].sum(v);
    return gt(b,e,v,u<<1,B,(B+E)>>1)+gt(b,e,v,u<<1|1,(B+E)/2+1,E);
}
void st(int B,int v){st(B,v,1,0,N-1);}
int gt(int b,int e,int v){return gt(b,e,v,1,0,N-1);}
\end{lstlisting}
\subsection{Segment Tree - pro HLD}
Minimový segmentový strom ve struktuře
\begin{lstlisting}[language=C++]
ll H[1<<20],W;
struct sX{
    ll *p,*P;
    int N;
    void ini(int n){
        N=1<<(int(log2(n)-ZERO)+1),p=H+W,W+=N*2,P=H+W,W+=N*2;
        F(N<<1)p[i]=INF,P[i]=-1;//init val
    }
    ll gt(int u){return ~P[u]?P[u]:p[u];}
    void st(int b,int e,ll v){st(b,e,v,1,0,N-1);}
    void st(int b,int e,ll v,int u,int B,int E){
        if(B>e||E<b)return;
        if(b<=B&&e>=E){if(B^E)P[u]=v;else p[u]=v;return;}
        if(~P[u])p[u<<1]=p[u<<1|1]=p[u]=P[u],P[u]=-1;
        st(b,e,v,u<<1,B,(B+E)>>1),st(b,e,v,u<<1|1,(B+E)/2+1,E);
        p[u]=min(gt(u<<1),gt(u<<1|1));
    }
    ll gt(int b,int e){return gt(b,e,1,0,N-1);}
    ll gt(int b,int e,int u,int B,int E){
        if(B>e||E<b)return INF;//fail value
        if(b<=B&&e>=E)return gt(u);
        if(~P[u])p[u<<1]=p[u<<1|1]=p[u]=P[u],P[u]=-1;
        return min(gt(b,e,u<<1,B,(B+E)>>1),gt(b,e,u<<1|1,(B+E)/2+1,E));
    }
    
}T;
#define CLR W=0
\end{lstlisting}
Sčítací segmentový strom ve struktuře
\\Navíc funkce $INI$ která by měla lineárně vyplnit strom hodnotami.
\begin{lstlisting}[language=C++]
#define MX (1<<19)
ll H[1<<21],W;
struct sS{
    ll *p,*P;
    int N;
    void ini(int n){
        N=1<<(int(log2(n)-ZERO)+1),p=H+W,W+=N*2,P=H+W,W+=N*2;
        F(N<<1)p[i]=P[i]=0;
    }
    void INI(int n,int*D){
        FT(N,N+n)P[k]=p[k]=D[k-N];
        for(int i=N-1;~i;--i)p[i]=p[i<<1]+p[i<<1|1];
    }
    void st(int b,int e,ll v=1){st(b,e,v,1,0,N-1);}
    void st(int b,int e,ll v,int u,int B,int E){
        if(B>e||E<b)return;
        if(b<=B&&e>=E){P[u]+=v,p[u]+=(E-B+1)*v;return;}
        st(b,e,v,u<<1,B,(B+E)>>1),st(b,e,v,u<<1|1,(B+E)/2+1,E);
        p[u]=p[u<<1|1]+p[u<<1]+P[u]*(E-B+1);
    }
    ll gt(int b,int e){return gt(b,e,1,0,N-1);}
    ll gt(int b,int e,int u,int B,int E){
        if(B>e||E<b)return 0;
        if(b<=B&&e>=E)return p[u];
        return gt(b,e,u<<1,B,(B+E)>>1)+gt(b,e,u<<1|1,(B+E)/2+1,E)+(min(e,E)-max(b,B)+1)*P[u];
    }
}T;
#define CLR W=0
\end{lstlisting}
\subsection{Treap}
Náhodně vyvažovaný strom (klíčem je zde \textsf{K} - $int$)
\\Funkčnosti
\begin{itemize}
\item $add$ - přidá klíč do stromu (pouze unikátní)
\item $del$ - odstraní klíč ze stromu
\item $cnt$ - zjistí, kolikátý prvek je klíč [pokud klíč není v Treapě, chová se funkce, jako by se jednalo o další největší prvek]
\item $kth$ - zjistí, který prvek je $k-tý$ [pokud k > počet prvků, je navrácen -INF]
\end{itemize}
Složitost $log(N)$ je předpokládaná složitost na všechny operace - vyvažování je ovšem náhodné, takže by mohlo dojít i k $O(N)$
\begin{lstlisting}[language=C++]
struct nd {
    int K;
    int c,p;
    nd *l, *r;
};
struct Treap{
    void add(int K){add(R,K);}
    void del(int K){del(R,K);}
    int cnt(int M){return cnt(R,M);}
    int kth(int k){return kth(R, k);}
    nd* R;
    Treap(){R=0; srand(time(0));}
    int sz(nd*T){return T?T->c:0;}
    void uc(nd*&T){if(T)T->c=1+sz(T->l)+sz(T->r);}
    void lr(nd* &T){
        nd*t(T->l);
        T->l=t->r,t->r=T,T=t;
        uc(T->r),uc(T);
    }
    void rr(nd*&T){
        nd*t(T->r);
        T->r=t->l,t->l=T,T=t;
        uc(T->l),uc(T);
    }
    void add(nd*&T,int K){
        if(!T){T=new nd{K,1,rand(),0,0};return;}
        if(T->K>K){
            add(T->l, K);
            if(T->p<T->l->p)lr(T);
        }else if(T->K<K){
            add(T->r,K);
            if(T->p<T->r->p)rr(T);
        }uc(T);
    }
    void del(nd*&T,int K){
        if(!T)return;
        if(T->K>K)del(T->l,K);
        else if(T->K<K)del(T->r,K);
        else if(T->l&&T->r){
            if(T->l->p>T->r->p)lr(T);
            else rr(T);
            del(T, K);
        }else{
            nd*t=T;
            if(T->l)T=T->l;
            else T=T->r;
            delete t;
        }uc(T);
    }
    int cnt(nd*T,int M){
        if(!T)return 0;
        if(T->K<M)return 1+sz(T->l)+cnt(T->r, M);
        return cnt(T->l, M);
    }
    int kth(nd*T,int k){
        if(sz(T)<k)return -INF;
        int z(1+sz(T->l));
        if(z==k)return T->K;
        if(z<k)return kth(T->r,k-z);
        return kth(T->l,k);
    }
}T;
\end{lstlisting}
Jednou testováno, snad to podporuje všechny operace? ($multitreap$)
\\Pozor na elementy > INF (nebude pro ně fungovat správně!)
\begin{lstlisting}[language=C++]
#define MX (1<<20)
struct nd{
    nd *ls,*rs,*f;
    int x,N,S,R;
    nd *clr(int xx,nd *ff=0){return f=ff,x=xx,ls=rs=0,N=S=1,R=rand(),this;}
    void rsz() {
        S=N;
        if(ls)S+=ls->S;
        if(rs)S+=rs->S;
    }
    void rot(){
        nd *x=this,*y=this->f;
        if(x==y->ls) {
            y->ls=x->rs,x->rs=y;
            if(y->ls)y->ls->f=y;
        }else{
            y->rs=x->ls,x->ls=y;
            if(y->rs)y->rs->f=y;
        }
        x->f=y->f,y->f=x;
        if(x->f){
            if(x->f->ls==y)x->f->ls=x;
            else x->f->rs=x;
        }
        y->rsz(),x->rsz();
    }
}b[MX],*bp,*R;
void ur(nd *x) {
    while(x->f&&x->R<x->f->R)x->rot();
    if(!x->f)R=x;
}
bool has(int x){
    for(nd *I=R;I;){
        if(I->x==x)return I->N>0;
        else if(x<I->x)I=I->ls;
        else I=I->rs;
    }
    return 0;
}
void add(int x) {
//    if(has(x)) return; //multitreap
    for(nd *I=R;I;) {
        I->S++;
        if(x==I->x){++I->N;return;}
        else if(x<I->x){
            if(I->ls)I=I->ls;
            else return I->ls=(bp++)->clr(x,I),ur(I->ls);
        }else if(I->rs)I=I->rs;
        else return I->rs=(bp++)->clr(x,I),ur(I->rs);
    }
}
bool del(int x){
    if(!has(x))return 0;//!!
    for(nd *I=R;I;){
        --I->S;
        if(I->x==x)return --I->N,1;
        else if(x<I->x)I=I->ls;
        else I=I->rs;
    }
    assert(0);//?!Care
}
int kth(int k){
    if(!k)return 0;
    for(nd *I=R;I;){
        if(I->ls){
            if(k<=I->ls->S){I=I->ls;continue;}
            else k-=I->ls->S;
        }
        if(k<=I->N)return I->x;
        k-=I->N,I=I->rs;
    }
    return INF;
}
int cnt(int x) {
    int r=0;
    for(nd *I=R;I;)
        if(x==I->x){
            if(I->ls)r+=I->ls->S;
            return r;
        }else if(x>I->x){
            if(I->ls)r+=I->ls->S;
            r+=I->N,I=I->rs;
        }else I=I->ls;
    return r;
}
\end{lstlisting}
%https://github.com/0Xellos/treapset/blob/master/treapset.cpp Verze od Xellose / dlouhá, hodně funkční
\subsection{Trie}
Tento trie funguje pro malá anglická písmena.
\\\textit{t} - uzly s odkazy na syny (počet - [$abeceda$][$velikost\_slovniku\times delka\_slov$]).
\\\textit{pr} - otec uzlu.
\\textit{p} - hodnota uzlu.
\\textit{w} - písmeno uzlu (aby šlo zjistit konstantně).
\begin{center}
Základní uzly trie a inicializace.
\end{center}
\begin{lstlisting}[language=C++]
int t[26][1<<17],pr[1<<17],p[1<<17],w[1<<17],L;
char d[128];
memset(t,pr[0]=-1,sizeof(t));
L=1;
\end{lstlisting}
\begin{center}
Přidání slova do trie.
\end{center}
\begin{lstlisting}[language=C++]
void addW(int pb,char *c){
    for(int i(0),nd(0);c[i];++i)
        if(~t[c[i]-'a'][nd])
            nd=t[c[i]-'a'][nd],p[nd]+=pb;
        else
            t[c[i]-'a'][nd]=L,pr[L]=nd,w[L]=c[i],p[nd=L++]=pb;
}
\end{lstlisting}
\begin{center}
Vytištění slova (či jeho prefixu) v nějakém node.
\end{center}
\begin{lstlisting}[language=C++]
void prt(int nd){
    int i(0);
    while(~pr[nd])
        d[i++]=w[nd],nd=pr[nd];
    while(~--i)
        putchar_unlocked(d[i]);
}
\end{lstlisting}
\begin{center}
Zjištění počtu různých slov o délce \textsf{l}.
\end{center}
Toto lze ale rychleji udělat počítáním rovnou (kódově i rychlostně) - viz dole.
\begin{lstlisting}[language=C++]
int len(int nd,int l){
    if(!l) return 1;
    int S(0);
    for(int i(0);i<26;++i)
        if(~t[i][nd])
            S+=len(t[i][nd],l-1);
    return S;
}
\end{lstlisting}
Verze bez $memsetu$ (jen na node 0!), bez dalších polí a s předeslanou $feature$.
\begin{lstlisting}[language=C++]
int t[26][MX],L(1),S;
void addW(char *c,int l){
    for(int i(0),nd(0),x(1);i<l;++i)
        if(~t[c[i]-'a'][nd])
            nd=t[c[i]-'a'][nd];
        else{
            t[c[i]-'a'][nd]=L,nd=L++;
            for(int i(0);i<26;++i)
                t[i][nd]=-1;
            S+=x,x=0;
        }
}
\end{lstlisting}
\begin{center}
Vyhledávání slov (zda-li jsou ve slovníku)
\end{center}
Pozor - je to na univerzu 0-255, tedy nutno odečíst 'a' obecně.
\begin{lstlisting}[language=C++]
bool is(char *c){
    int nd(0);
    for(int i(0);c[i];++i)
        if(!~t[(int)c[i]][nd])return 0;
        else nd=t[(int)c[i]][nd];
    return E[nd];
}
\end{lstlisting}
Dále je nutno přidat pole 'E' které se vynuluje a na konec addW se přidá 2. řádek.
\begin{lstlisting}[language=C++]
memset(E,0,sizeof(n)
E[nd]=1;
\end{lstlisting}
Obecná verze - stejně se to vždy ořeže
\begin{lstlisting}[language=C++]
int t[26][MX],L,E[MX];
void addW(char*c,int l){
	if(!L){F(26)t[i][0]=-1;L=1;*E=-1;}
    int nd(0);
    F(l)if(~t[c[i]-'a'][nd])
            nd=t[c[i]-'a'][nd];
        else{
            t[c[i]-'a'][nd]=L,E[nd=L++]=-1;
            F(26)t[i][nd]=-1;
        }
}
\end{lstlisting}
\newpage\section{Vzorce, užitečné funkce a čísla (něčí)}
\subsection{Barycentrický n-simplex}
\textbf{5 25 149 1081 9365 94585 1091669 14174521 204495125 3245265145}
\\Jedná se pouze o aproximaci (do n==13 sedí).
\begin{lstlisting}[language=C++]
ll fc(ll a){
    return a?fc(a-1)*a:1;
}
ll bss(ll n){
    return fc(n)/(pow(log(2),n+1))-0.5;
}
\end{lstlisting}
\subsection{Catalanova čísla}
Funkce $icn$ se volá jednou, pro inicializaci - složitost $O(MX)$
\\Funkce $CN$ vrátí \textsf{N}-té Catalánovo číslo (max $MX$).
\begin{lstlisting}[language=C++]
#define MOD 100000007//10^8+7
#define MX (2222)
ll gcdE(ll a,ll m,ll &x,ll &y){
    if(!a)return x=0,y=1,m;
    ll u,v,g(gcdE(m%a,a,u,v));
    return x=v-(m/a)*u,y=u,g;
}
ll inv(ll a,ll m=MOD){
    ll x,y,g(gcdE(a,m,x,y));
    return g==1?(x%m+m)%m:-1;
}
int f[MX]={1},I[MX];
void icn(){
    FT(1,MX)f[k]=(f[k-1]*1ll*k)%MOD;
    F(MX)I[i]=inv(f[i]);
}
int CN(int N){
    if(!N)return 0;//ERASE - NOT TRUE
    return ((((f[2*N]*1ll*I[N])%MOD)*I[N])%MOD)*inv(N+1)%MOD;
}
\end{lstlisting}
Verze bez modula. Catalanova čísla jsou uložena přímo v \textsf{C}.
\begin{lstlisting}[language=C++]
#define MX (1024)
big C[MX];
void icn(){
    *C=1,C[1]=1;
    FT(2,MX)C[k]=C[k-1],C[k]*=(4*k-2),C[k]/=k+1;
}
\end{lstlisting}
\subsection{Eulerovo Číslo}
Vrátí $A_N(K)$ na modulu $MOD$.
\\Složitost je $O(N^2)$ pro vygenerování všech čísel (dynamika).
\\Není nutná inicializace - \textsf{T} v sobě potřebuje mít $0$.
\\Využití: Počet permutací délky $N$ s použitím přesně $K$ čísel s vlastností, že poslední číslo každého druhu (kromě 1) musí mít před sebou (kdekoliv v permutaci) číslo o jedna menší
\begin{lstlisting}[language=C++]
#define MOD (1000000007)
#define MX (5010)
ll T[MX][MX];
ll MD(ll a){return (a>=0?a:a+(-a/MOD+1)*MOD)%MOD;}
ll ET(ll N,ll K){
    ll &v(T[N][K]);
    if(v)return v;
    if(K==N)return 0;
    if(!K||K==N)return v=1;
    return v=MD((N-K)*ET(N-1,K-1)+(K+1)*ET(N-1,K));
}
\end{lstlisting}
Lze uchovávat i na intech!
\begin{lstlisting}[language=C++]
#define MOD (1000000007)
#define MX (5010)
int T[MX][MX];
int MD(ll a){return (a>=0?a:a+(-a/MOD+1)*MOD)%MOD;}
int ET(ll N,ll K){
    int &v(T[N][K]);
    if(v)return v;
    if(K==N)return 0;
    if(!K||K==N)return v=1;
    return v=MD((N-K)*1ll*ET(N-1,K-1)+(K+1ll)*ET(N-1,K));
}
\end{lstlisting}
\subsection{Fareyova Sequence}
Fareyova sequence jsou všechny podíly $\dfrac{a}{b}$, kde $b\leq N$ a zároveň gcd(a,b)==1.
\\Vygenerování Fareyovi Sequince (a po sléze získání k-tého členu).
\begin{lstlisting}[language=C++]
ii S[1<<21];
bool cp(ii a,ii b){return a.aa*b.bb<b.aa*a.bb;}
void far(int N,int K,ii&h){
    int L(0);
    F(N+1)FT(1,i+1)if(__gcd(i,k)==1)S[L++]={k,i};
    sort(S,S+L,cp);
    h=S[K-1];
}
\end{lstlisting}
Rychlejší a kratší - umí ovšem získat pouze k-tý člen
\begin{lstlisting}[language=C++]
void fn(int N,int K,int&a,int&b){
    int pa(0),pb(1),ta,tb,tk;
    a=1,b=N;
    while(--K)tk=(N+pb)/b,ta=tk*a-pa,tb=tk*b-pb,pa=a,pb=b,a=ta,b=tb;
}
\end{lstlisting}
Pokud dostaneme cestu ve Stern-Brocotově stromu, definovanou jeko výběr Levo/Pravo, můžeme správný node najít takto:
\begin{lstlisting}[language=C++]
pll sbt(char*s){
    ll a=0,b=1,c=1,d=1,e=1,f=0,x=1,y=1,L=strlen(s);
    F(L)if(s[i]^'R')x=a+c,y=b+d,e=c,f=d,c=x,d=y;
        else        x=e+c,y=f+d,a=c,b=d,c=x,d=y;
    return {x,y};
}
\end{lstlisting}
\subsection{Fibbonacciho čísla}
Získání k-tého Fibbonacciho čísla ($F_{n+1}=F_n+F_{n-1}$) pro $F_0=a$ a $F_1=b$ v modulu $m$.
\\Složitost $O(log(n))$
\begin{lstlisting}[language=C++]
typedef long long tp;
struct mx{
    mx(tp a,tp b,tp c,tp d):a(a),b(b),c(c),d(d){}
    tp a,b,c,d;
    void operator*=(const mx&r){
        tp A,B,C,D;
        A=a*r.a+b*r.c;
        B=a*r.b+b*r.d;
        C=c*r.a+d*r.c;
        D=c*r.b+d*r.d;
        a=A,b=B,c=C,d=D;
    }
    void nrm(tp M){
        a%=M,b%=M,c%=M,d%=M;
    }
    void pow(tp k,tp M){
        if(!k){a=b=c=d=1;return;}
        mx n(*this);--k;
        while(k){
            if(k&1)
                *this*=n,this->nrm(M);
            n*=n,k>>=1,n.nrm(M);
        }
    }
};
\end{lstlisting}
\begin{lstlisting}[language=C++]
mx h(1,1,1,0);
h.pow(n,m);
(h.c*b+h.d*a)%m;
\end{lstlisting}
\begin{center}
Oveření, zda-li je číslo Fibbonacciho číslem.
\end{center}
\begin{lstlisting}[language=C++]
bool isPS(int x){
    int s=sqrt(x);
    return (s*s==x);
}
#define isFibo(N) (isPS(5*N*N+4)||isPS(5*N*N-4))
\end{lstlisting}
$F(N)=\dfrac{\varphi^n-(-\dfrac{1}{\varphi})^n}{\sqrt{5}}$
\subsection{Jackobsthalova čísla}
\textbf{0,1,1,3,5,11,21,43,85,171,341,683,1365,2731,5461}
\\$J_n=J_{n-1}+2J_{n-2}$, $J_0=0,J_1=1$
\\PS: Do longu se nevejdou po několika desítkách číslech (50-80?)
\\Příklad využití: Počet po sobě jdoucích dvojic nul v $n$-tém tahu, jestliže se v každém tahu přepíší 0 na 10 a 1 na 01.
\begin{lstlisting}[language=C++]
struct big{
    static const long long MX=999999999;
    long long l,a[512];
    big(int A=0):l(1){a[0]=A;}
    bool eq(int h){return l==1&&a[0]==h;}
    void operator=(int h){
        a[0]=h;
        l=1;
    }/*Care - if used on itself, remove '&'!*/
    void operator+=(big &b){
        for(int i(0);i<b.l;++i)
            add(b.a[i],i);
    }
    void add(long long s,int nd){
        if(nd==l)
            a[l++]=0;
        a[nd]+=s;
        if(a[nd]>MX)
            a[nd]-=MX+1,add(1,nd+1);
    }
    void prt(void){
        printf("%lld",a[l-1]);
        for(int i(l-2);~i;--i)
            printf("%09lld",a[i]);
    }
}J[1024]={0,1};
void jh(int n){
    if(!n)return;
    if(J[n].l!=1||*J[n].a)return;
    jh(n-1),jh(n-2);
    J[n]+=J[n-1],J[n]+=J[n-2],J[n]+=J[n-2];
}
\end{lstlisting}
\subsection{Lucky Numbers}
Posloupnost čísel, ze které se vždy vyřadí \textsf{k}-tá čísla, kde \textsf{k} je nově nalezený prvek.
\\Zde je generování prvních $10^5$ prvků (už takhle to trvá dost dlouho).
\begin{lstlisting}[language=C++]
#define MX ((1<<21)+6)
#define MN (1429500) //10^5th number
int t[MX],S;
void clr(int s){CL(t,0);S=s;}
void inc(int i,int d){
    for(;i<S;i|=i+1)t[i]+=d;
}
int sum(int i){
    int s(0);
    while(~i)s+=t[i],i&=i+1,--i;
    return s;
}
int A[1<<17]={0,1};
int bs(int v){
    int B(0),E(MX-1),M,H;
    while(B<E){
        H=sum(M=(B+E+1)>>1);
        if(H>=v)E=M-1;
        else B=M;
    }++B;
    return B;
}
void lns(){
    int c(2),p(1),h,P,o;
    clr(MX);
    FT(1,MX+1)inc(k++,1);
    for(int i(3);i<=MN+1;i+=2)
        if((h=sum(i))!=p){
            A[c++]=i,P=(MN/i)*i;
            while(P>=i)o=bs(P),inc(o,-1),P-=i;
            p=h;
        }
}
\end{lstlisting}
\subsection{Möbiova funkce}
V $D$ bude uložena Möbiova funkce. Ta je definována jako:
\begin{itemize}
\item \textbf{1}: 1
\item \textbf{Číslo není square-free}: 0
\item \textbf{Lichý počet faktorů}: -1
\item \textbf{Sudý počet faktorů}: 1
\end{itemize}
\begin{lstlisting}[language=C++]
int D[MX]={0,1};
void mob(){
    static bool H[MX];
    fill(D+2,D+MX,1);
    FT(2,MX){
        if(!H[k])for(int i(k);i<MX&&++H[i];i+=k)
            if(!(i%(k*k)))D[i]=0;
            else D[i]*=-1;
    }
}
\end{lstlisting}
\subsection{Suma ukončujících nul v bázích 2 až nekonečno}
$\sum\limits_{b=2}^\infty fzero(n,b)$
\begin{lstlisting}[language=C++]
ll L,h[64],c[64],G,TP;
ll goal(int I,ll S){
    if(S>TP)return 0;
    ll v(0),T(S*S);
    if(T>1)while(T<=G&&!(G%T))T=T<TOP?T*S:G+1,++v;
    FT(I,L)if(c[k])
        --c[k],v+=goal(k,S*h[k]),++c[k];
    return v;
}
ll sl(ll n){
    TP=sqrt(n);
    ll t(1);G=n;
    for(ll i(0),ct(L=0);P[i]*P[i]<=n;++i,ct=0){
        while(!(n%P[i]))
            n/=P[i],++ct;
        t*=ct+1;
        if(ct)h[L]=P[i],c[L++]=ct;
    }
    if(n!=1)t<<=1,h[L]=n,c[L++]=1;
    t+=goal(0,1);
    return t-1;
}
\end{lstlisting}
\subsection{Padovanova sequence}
Definovaná jako $T(A)=T(A-2)+T(A-3), T(0)=1,T(1)=0,T(2)=0$
\\Prvních několik členů: \{	1, 0, 0, 1, 0, 1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 12, 16, 21, 28, 37, 49, 65, 86, 114, 151, 200, 265, 351, 465, 616, 816, 1081, 1432, 1897, 2513, 3329, 4410, 5842\}
\\Využití:
\begin{itemize}
\item Počet subgrafů v grafu, který vypadá jako cesta takových, že vrcholy nejsou spojené a zároveň nelze přidat další vrchol tak, aby se porušila tato podmínka. Pokud bychom uvažovali graf o velikosti 5 (1-2-3-4-5), pak subsety budou \{1,3,5\},\{2,4\},\{2,5\},\{1,4\}. V tomto případě je Padovanova sekvence posunuta o 6.
\item Počet kompozicí \textsf{n} do částí, kongruentních s 2 modulo 3 (ofset -1).
\end{itemize}
\begin{lstlisting}[language=C++]
#define MX (128)
ll P[MX]={1,0,0};
void ips(){FT(3,MX)P[k]=P[k-2]+P[k-3];}
\end{lstlisting}
\subsection{Partition function}
Prvních několik členů: \{0, 0, 1, 3, 7, 13, 22, 34, 50, 70, 95, 125, 161, 203, 252, 308, 372, 444, 525, 615, 715, 825, 946, 1078, 1222, 1378, 1547, 1729, 1925, 2135\}
\\Využití:
\begin{itemize}
\item Počet nedegenerovaných trojúhelníků, pokud máme strany délek od 1 do \textsf{N} (offset -2)
\item Počet neizomorfních rovin s \textsf{N} body a dvěma přímkami (offset -2).
\end{itemize}
\begin{lstlisting}[language=C++]
ll ps(ll n){return (4*n*n*n+6*n*n-4*n-3+3*(n&1?-1:1))/48;}
\end{lstlisting}
\subsection{Přelívání vody}
Nechť mám dvě vázy o velikostech \textbf{A} a \textbf{B}, a chci v některé mít \textbf{C} vody a mohu dělat následující operace [z prvu jsou prázdné]:
\begin{itemize}
\item Vylej vodu z vázy
\item Naplň vázu
\item Přelívej vázy dokud není jedna prázdná či druhá plná.
\end{itemize}
Výsledkem je minimální počet tahů (či \textbf{-1} pokud výsledku nelze dosáhnout)
\begin{lstlisting}[language=C++]
int por(int A,int B,int C){
    if(!C)return 0;
    if(A==C||B==C)return 1;
    if(C>max(A,B)||C%__gcd(A,B))return -1;//FAIL
    int X=INF;
    F(2){
        int S=1,a=A,b=0,p;
        while(a^C&&b^C){
            p=min(a,B-b),b+=p,a-=p,++S;
            if(a==C||b==C)break;
            if(b==B)b=0,++S; 
            else if(!a)a=A,++S;
        }
        X=min(X,S),swap(A,B);
    }
    return X;
}
\end{lstlisting}
\subsection{Přenášení krabic}
Necht je \textsf{N} lidí, kteří mohou brát krabice po jedné. V \textsf{a} je uložena jejich pozice a v \textsf{b} jestli nesou krabici ('1' pokud nesou). \textsf{B} je pak počet krabic na začátku a \textsf{f} je vzdálenost mezi začátkem a koncem.
\\Lidi vždy vezmou krabici, odnesou ji na konec a vrátí se.
\begin{lstlisting}[language=C++]
int gtm(int *a,int *b,int B,int f,int N){
    F(N)a[i]+=(cn[i]*(f-a[i]))<<1;
    nth_element(a,a+--B%N,a+N);
    return B/N*2*f+f+a[B%N];
}
\end{lstlisting}
\subsection{Součet posledních číslic čísla}
Sečte poslední číslice všech čísel až do čísla "u" [včetně]
\begin{lstlisting}[language=C++]
#define GS(N) ((N)*((N)+1)/2)
ll f(ll u){
    if(u<10)return GS(u);
    return u/10*45+GS(u%10)+f(u/10);
}
\end{lstlisting}
\subsection{Suma mocnin}
$\sum\limits_{i=1}^n i^k$
\\\textsf{pt} je paskalův trojúhelník
\\$pw$ je mocnení matic
\\Složitost $O(K^3log(N))$
\begin{lstlisting}[language=C++]
ll R[MM][MM],X[MM][MM];
ll ssm(long long N,int K){
    if(N==1)return 1;
    F(K+1)FF(i+1)X[i][j]=pt[i][j];
    FF(K+1)X[K+1][j]=pt[K][j];
    X[K+1][K+1]=1;
    pw(X,R,K+2,N-1);
    ll r(0);
    F(K+2)r+=R[K+1][i];
    return r;
}
\end{lstlisting}
\subsection{Suma k modulo i (od 1 do n)}
$\sum\limits_{i=1}^n k\ mod\ i$
\begin{lstlisting}[language=C++]
ll sum(ll a,ll d,ll n){
    return((a<<1)-d*n)*(n+1)>>1;
}
ll jp(ll n,ll k){
    ll r(0),i(1),q,p,a;
    if(n>k)r+=(n-k)*k,n=k-1;
    while(i<=n)q=k%i,p=k/i,a=p?q/p:1<<30,r+=sum(q,p,min(a,n-i)),i+=min(a,n-i)+1;
    return r;
}
\end{lstlisting}
\subsection{Ukončující nuly v bázi}
Počet bází, ve kterých má $N^K$ právě \textsf{T} ukončujících nul.
\\Je nutné importovat faktorizaci
\begin{lstlisting}[language=C++]
#define MOD (1000000007)
int NKZ(int N,int M,int T){
    static int f[64],c[64];
    ll L=fc(N,f,c),A=1,B=1;
    F(L)A*=c[i]*1ll*M/T+1,A%=MOD,B*=c[i]*1ll*M/(T+1)+1,B%=MOD;
    return (A-B+MOD)%MOD;
}
\end{lstlisting}
\newpage\section{Další}
\subsection{Vyzkoušet}
\begin{lstlisting}[language=C++]
//thx try
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
 
struct DLX
{
    int n, m, sz;
    int U[1<<16], D[1<<16], R[1<<16], L[1<<16], row[1<<16], col[1<<16];
    int H[1<<8], S[1<<8];
    int ansd;
    void init(int n, int m)
    {
        this->n=n;
        this->m=m;
        ansd=1<<16;
        for(int i=0; i<=m; i++)
        {
            S[i]=0;
            U[i]=D[i]=i;
            L[i]=i-1;
            R[i]=i+1;
        }
        R[m]=0, L[0]=m;
        sz=m;
        for(int i=1; i<=n; i++)
            H[i]=-1;
    }
    void Link(int r, int c)
    {
        ++S[col[++sz]=c];
        row[sz]=r;
        D[sz]=D[c];
        U[D[c]]=sz;
        U[sz]=c;
        D[c]=sz;
        if(H[r]<0)H[r]=L[sz]=R[sz]=sz;
        else
        {
            R[sz]=R[H[r]];
            L[R[H[r]]]=sz;
            L[sz]=H[r];
            R[H[r]]=sz;
        }
    }
    void remove(int c)
    {
        for(int i=D[c]; i!=c; i=D[i])
            L[R[i]]=L[i], R[L[i]]=R[i];
    }
    void resume(int c)
    {
        for(int i=U[c]; i!=c; i=U[i])
            L[R[i]]=R[L[i]]=i;
    }
    void Dance(int d)
    {
        if(d>=ansd)return ;
        if(R[0]==0)
        {
            ansd=min(d, ansd);
            return ;
        }
        int c=R[0];
        for(int i=R[0]; i; i=R[i])
            if(S[i]<S[c])
                c=i;
        for(int i=D[c]; i!=c; i=D[i])
        {
            remove(i);
            for(int j=R[i]; j!=i; j=R[j])remove(j);
            Dance(d+1);
            for(int j=L[i]; j!=i; j=L[j])resume(j);
            resume(i);
        }
    }
} dlx;
 
char str[1<<8][1<<8];
char mat[1<<8];
int vis[1<<8];
int l,m,n;
 
int check(int j)
{
    for(int k=0;k<l;k++)
    {
        if((mat[k]!='-')&&(mat[k]!=str[j][k]))
        {
            return 0;
        }
    }
    return 1;
}
 
int main()
{
    //freopen("k.in","r",stdin);
    int t;
    t=0;
    while((scanf("%d %d %d",&l,&m,&n)!=EOF)&&((l!=0)||(m!=0)||(n!=0)))
    {
        memset(vis,0,sizeof(vis));
        dlx.init(n, m);
        for(int i=1;i<=m;i++)
        {
            scanf("%s",str[i]);
        }
        for(int i=1;i<=n;i++)
        {
            scanf("%s",mat);
            for(int j=1;j<=m;j++)
            {
                if(check(j))
                {
                    vis[j]=1;
                    dlx.Link(i,j);
                }
            }
        }
        printf("Test #%d: ",++t);
        if(find(vis+1,vis+m+1,0)==vis+m+1)
        {
            dlx.Dance(0);
            printf("No of required PIs = %d \n",dlx.ansd);
        }
        else
        {
            printf("PIs don't cover all MTs \n");
        }
    }
    return 0;
}
\end{lstlisting}
\subsection{fastIO}
\begin{lstlisting}[language=C++]
#include <stdio.h>
//zaloha
/*inline bool gi(int &a){
    char c;
    bool lwr=false;
    while((c=getchar_unlocked())&&(c<'0'||c>'9')&&c!='-'&&c!=-1);
    if(!c||c==-1)return false;
    if(c=='-')
        a=0,lwr=true;
    else
        a=c-'0';
    while((c=getchar_unlocked())&&c>='0'&&c<='9')
        a*=10,a+=c-'0';
    if(lwr)
        a=-a;
    return true;
}*/
//THIS IS VERSION FOR BIG
inline void pn(ll k,int R=-1){
    if(!k&&~R){F(R)putchar_unlocked(48);return;}
    if(!k){putchar_unlocked('0');return;}
    ll l(0),i(0),j(0);
    while(k)l*=10,l+=k%10,k/=10,++i;
    if(~R)FT(i,R)putchar_unlocked(48);
    while(j++<i)
        putchar_unlocked('0'+l%10),l/=10;
}
void prt(void){
        pn(a[l-1]);
        for(int i(l-2);~i;--i)
            pn(a[i],9);
    }
    //ENDS HERE
inline bool isWS(char c){return c==' '||c=='\n';}
inline bool getChar(char &c){
    while((c=getchar_unlocked())&&isWS(c));
    return c;
}
inline int getString(char *a){
    char c;
    while((c=getchar_unlocked())&&isWS(c));
    if(!c)return 0;
    a[0]=c;
    int i(1);
    while((c=getchar_unlocked())&&!isWS(c))
        a[i++]=c;
    return i;
}
//negative on line
int ps(char*s,int*o){
    int L(-1),I(0),X;
    while(s[I]){
        o[++L]=X=0;
        if(s[I]==45)++I,X=1;
        while(isdigit(s[I]))o[L]*=10,o[L]+=s[I++]-48;
        if(X)o[L]=-o[L];
        while(s[I]&&!isdigit(s[I])&&s[I]^45)++I;
    }
    return L+1;
}
//gets all ints on line!
int ps(char*s,int*o){
    int L(-1),I(0);
    while(s[I]){
        o[++L]=0;
        while(isdigit(s[I]))o[L]*=10,o[L]+=s[I++]-48;
        while(s[I]&&!isdigit(s[I]))++I;
    }
    return L+1;
}
inline bool gd(double &a){
    char c;
    double dv(10);
    bool lwr=0;
    while((c=getchar_unlocked())&&(c<'0'||c>'9')&&c!='-'&&c!=-1);
    if(!c||!~c)return 0;
    if(c=='-')
        a=0,lwr=1;
    else
        a=c-'0';
    while((c=getchar_unlocked())&&c>='0'&&c<='9')
        a*=10,a+=c-'0';
    if(c=='.')
        while((c=getchar_unlocked())&&c>='0'&&c<='9')
            a+=(c-'0')/dv,dv*=10;
    if(lwr)
        a=-a;
    return 1;
}
inline void printSNum(int k){
    bool ng(k<0);
    k=k<0?-k:k;
    if(!k){putchar_unlocked('0');return;}
    int l(0),i(0),j(0);
    while(k)
        l*=10,l+=k%10,k/=10,++i;
    if(ng)
        putchar_unlocked('-');
    while(j++<i)
        putchar_unlocked('0'+l%10),l/=10;
}
inline void pd(double k,int d){
    int l(1),ll;
    if(k<ZERO)putchar_unlocked(45);
    for(int i(0);i<d;++i)
        l*=10;
    if(k<0)k-=0.5/l;
    long long ml=k*l,mm;//new?
    if((long long)(k*l*10)%(10)>=5)
        ++ml;
    printSNum(llabs(ml/l));
    if(ml<0)ml=-ml;//new
    if(!d)return;
    putchar_unlocked('.');
    ll=l/10,mm=ml%l;
    if(!mm){
        for(int i(0);i<d;++i)
            putchar_unlocked('0');
        return;
    }
    while(ll>mm)
        putchar_unlocked('0'),ll/=10;
    printSNum(mm);
}
#define gc getchar_unlocked()
#define pc(C) (putchar_unlocked(C))
inline char nx(){char c;while((c=gc)==10||32==c);return c;}
inline bool gi(int &a){
    char c;
    bool lwr(0);
    while((c=gc)&&(c<48||c>57)&&c!=45&&~c);
    if(!c||!~c)return 0;
    if(c==45)a=0,lwr=1;
    else a=c-48;
    while((c=gc)&&c>=48&&c<=57)a*=10,a+=c-48;
    if(lwr)a=-a;
    return 1;
}
inline void pn(int k){
    if(!k){putchar_unlocked(48);return;}
    int l(0),i(0),j(0);
    while(k)l*=10,l+=k%10,k/=10,++i;
    while(j++<i)pc(48+l%10),l/=10;
}
#define pe pc(10)
#define CS(H) (printf("Case "),pn(i+1),pc(':'),pc(32),pn(H),pc(10));
void ga(int N,int *A){F(N)gi(A[i]);}
int main(void){
    T.max_load_factor(.4);
    return 0;
}
\end{lstlisting}
\subsection{Alias}
\begin{lstlisting}[language=bash]
alias mpp='g++ -Wall -pedantic -std=c++11'
alias pc='mpp main.cpp'
alias p='pc;./a.out < src.txt'
alias pf='p|head'
alias pd='p>tmp;diff tmp out'
alias pt='pc;time ./a.out < src.txt'
alias pl='p|wc -l'

alias ct='find *.in *.txt | xargs -I % sh -c "echo Test %; ./a.out < %;"'
alias ca='pc && ct'
alias main='cp ~/Documents/main.cpp .'

set ts=4
set sw=4
set sr
set et
set sta
set nu
set bs=2
set ai
set tw=79
set fo=c,q,r,t
set bg=dark " only dark terminal bg
set mouse=a
set hid
nmap <C-S> :wa<CR>
imap <Tab> <C-P>
inoremap { {<CR>}<UP><C-O>$
filetype plugin indent on
syntax on
nnoremap <S-A-Down> :m .+1<CR>==
nnoremap <S-A-Up> :m .-2<CR>==
inoremap <S-A-Down> <Esc>:m .+1<CR>==gi
inoremap <S-A-Up> <Esc>:m .-2<CR>==gi
inoremap <C-E> <Esc>ddI
map <tab> :s,^,//,<cr>
map q :s,^//,,<cr>
\end{lstlisting}
\subsection{Makra}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;
#define PB push_back
#define ZERO (1e-10)
#define INF (1<<29)
#define CL(A,I) (memset(A,I,sizeof(A)))
#define DEB printf("DEB!\n");
#define D(X) cout<<"  "<<#X": "<<X<<endl;
#define EQ(A,B) (A+ZERO>B&&A-ZERO<B)
typedef long long ll;
typedef long double ld;
typedef pair<ll,ll> pll;
typedef vector<int> vi;
typedef pair<int,int> ii;
typedef vector<ii> vii;
#define IN(n) int n; cin >> n;
#define FOR(i, m, n) for (int i(m); i < n; i++)
#define REP(i, n) FOR(i, 0, n)
#define F(n) REP(i, n)
#define FF(n) REP(j, n)
#define FT(m, n) FOR(k, m, n)
#define aa first
#define bb second
void ga(int N,int *A){F(N)scanf("%d",A+i);}

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);    
    
    freopen("input.in","r",stdin);
    freopen("output.out","w",stdout);    
    
    return 0;
}
\end{lstlisting}
\end{document}
%Easier done than said?
% Divide two point-groups possible? doorsAndPinguins
